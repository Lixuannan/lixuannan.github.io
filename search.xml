<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/posts/0.html"/>
    <url>/posts/0.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>构建超强 OI 环境之安装 Arch Linux</title>
    <link href="/posts/60947.html"/>
    <url>/posts/60947.html</url>
    
    <content type="html"><![CDATA[<h2 id="准备安装镜像"><a href="#准备安装镜像" class="headerlink" title="准备安装镜像"></a>准备安装镜像</h2><p>大陆的用户可以前往<a href="https://mirrors.ustc.edu.cn/archlinux/iso/latest/">中科大的镜像站</a>下载安装 ISO 镜像。而身处海外心系祖国的同学可以去官网下载。</p><p>下载后找个自己喜欢的目录存储即可。</p><h2 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h2><p>这里使用 VirtualBoxVM，VMware 的也可以参考一下。首先点击创建虚拟机。填入名字，最好和 Arch Linux 有关，然后选择刚刚下载的安装镜像。</p><p><img src="https://cdn.jsdmirror.cn/gh/lixuannan/img/vm1.png" srcset="/img/loading.gif" lazyload></p><p>然后设置合适的 CPU 和内存，对于一般的情况，直接拖到绿色的最右侧即可。需要注意的是，一定要勾选 <strong>启用 EFI</strong>，要不然安装会出错。</p><p><img src="https://cdn.jsdmirror.cn/gh/lixuannan/img/vm2.png" srcset="/img/loading.gif" lazyload></p><p>此后选择合适的虚拟硬盘大小，这个将决定后面虚拟机可以使用的硬盘大小，建议尽量大一些，反正虚拟机用多少占用多少实际空间。</p><p><img src="https://cdn.jsdmirror.cn/gh/lixuannan/img/vm3.png" srcset="/img/loading.gif" lazyload></p><p>保存。然后进入设置-显示，并将显存设置到最大，开启 3D 加速。</p><p><img src="https://cdn.jsdmirror.cn/gh/lixuannan/img/vm5.png" srcset="/img/loading.gif" lazyload></p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>开启虚拟机，一般来说会进入到一个 Live 环境，就像下面这样。</p><p><img src="https://cdn.jsdmirror.cn/gh/lixuannan/img/vm6.png" srcset="/img/loading.gif" lazyload></p><p>下面的操作就都将在这个窗口里面进行。</p><h3 id="硬盘分区"><a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h3><h4 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h4><p>首先对硬盘进行分区，这里推荐使用 CF Disk. 我们在命令行中键入 <code>cfdisk /dev/sda</code> 命令中，<code>/dev/sda</code> 是被进行分区的硬盘，通常来说是这个，当然也可能出现其他情况，总之就是选择正确的盘即可。进入后先选择 <code>GPT</code> 分区表。</p><p>进入后首先会看到一个 Free Space，可以然后你需要通过操作键盘的左右键来选到 <code>New</code>，然后输入大小 <code>1G</code>，然后在选择 <code>Type</code>，将其设置为 EFI System. 此后的两个分区分别为至少 <code>4G</code> 的 Linux Swap 分区和剩余所有空间的 Linux Filesystem 分区。需要提醒的是，在分区的时候不填写大小就会默认使用所有空间。</p><p>完成分区操作后应该是下面这样的。</p><p><img src="https://cdn.jsdmirror.cn/gh/lixuannan/img/Screenshot%20from%202024-08-22%2018-35-09.png" srcset="/img/loading.gif" lazyload></p><p>然后你需要将通过左右键光标移动到 <code>Write</code> 回车并输入 <code>yes</code> 来写入分区表。最后 <code>Quit</code> 即可。</p><h4 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h4><p>然后我们需要格式化分区，首先我们使用 <code>mkfs.ext4 /dev/sda3</code> 命令来格式化刚刚创建的最大的分区，其中 <code>/dev/sda3</code> 是这个分区所在的位置，参考刚刚分区的页面显示。这个分区将成为我们未来的 Linux 文件系统根分区。在格式化的过程中，你不需要输入什么，只需要等到重新弹出那个等待输入命令的东西即可。</p><p>其次我们要格式化的是作为虚拟内存的分区，使用命令 <code>mkswap /dev/sda2</code>，含义同上。一般来说创建的很快，也是等待到弹出等待输入命令的字符即可。</p><p>最后格式化作为引导的分区，使用命令 <code>mkfs.fat -F 32 /dev/sda1</code> 这个分区将成为未来非常重要的分区。如果格式化成功，将不会有任何有颜色的东西输出，一般来说只会输出版本号之类的东西，无需多理。然后还是会依然弹出等待命令的东东。</p><h4 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h4><p>格式化完成我们就需要挂载这些分区，使用下面的命令：</p><ol><li><p><code>mount /dev/sda3 /mnt</code> 挂载文件系统分区，其中设备所在的目录与上文相同。</p></li><li><p><code>mount --mkdir /dev/sda1 /mnt/boot</code> 挂载 EFI 分区。</p></li><li><p><code>swapon /dev/sda2</code> 挂在虚拟内存分区。</p></li></ol><p>至此我们就完成了对硬盘进行分区的步骤。</p><h3 id="配置软件源"><a href="#配置软件源" class="headerlink" title="配置软件源"></a>配置软件源</h3><p>输入命令 <code>nano /etc/pacman.d/mirrorlist</code> 编辑文件，然后在文件中输入以下内容：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Server = http:<span class="hljs-regexp">//mi</span>rrors.bfsu.edu.cn<span class="hljs-regexp">/archlinux/</span><span class="hljs-variable">$repo</span><span class="hljs-regexp">/os/</span><span class="hljs-variable">$arch</span><br></code></pre></td></tr></table></figure><p>然后使用命令 <code>pacman -Sy</code> 命令来获取软件包列表。</p><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>我们使用 <code>pacstrap -K /mnt 软件包</code> 来安装软件包。必须的你需要安装 <code>base base-devel linux-zen linux-firmware linux-zen-headers networkmanager</code> 其中 <code>base</code> 和 <code>linux-firmware</code> 提供了基本系统和基本固件。<code>linux-zen</code> 和 <code>linux-zen-headers</code> 是 <code>linux-zen</code> 内核和其对应的用于编译和安装内核模块的头文件集。使用 <code>linux-zen</code> 内核是因为这个社区构建的版本提供了比 <code>linux</code> 内核这个原版的版本提供了更多的可用接口，更方便折腾。而 <code>networkmanager</code> 是网络管理器，如果不安装后续上不了网，不要问我为什么知道。<code>base-devel</code> 是更多方便操作的根据。</p><p>针对上面的软件包，我们需要使用命令 <code>pacstrap -K /mnt base base-devel linux-zen linux-firmware linux-zen-headers networkmanager</code> 来安装。</p><p>然后我们还需要一些方便配置配置的工具比如 <code>vim</code> 和 <code>nano</code>，使用命令 <code>pacstrap -K /mnt vim nano</code> 来安装。</p><p>为了方便我们暂时不安装桌面系统。</p><h3 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h3><h4 id="生成-fstab-文件"><a href="#生成-fstab-文件" class="headerlink" title="生成 fstab 文件"></a>生成 fstab 文件</h4><p>我们使用命令 <code>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</code> 来生成 fstab 文件。这个文件保存了电脑上存储设备和文件系统的信息。非常重要哦哦哦哦哦哦哦。不要忘记了！！！！！</p><h4 id="进入新系统"><a href="#进入新系统" class="headerlink" title="进入新系统"></a>进入新系统</h4><p>我们使用 <code>chroot</code> 进入新安装的系统中进行一些操作，但注意，现在系统的安装还没有完成。</p><p>使用命令 <code>arch-chroot /mnt</code> 来进行切换。</p><h4 id="设置时区、区域和本地化"><a href="#设置时区、区域和本地化" class="headerlink" title="设置时区、区域和本地化"></a>设置时区、区域和本地化</h4><p>首先我们使用命令 <code>ln -sf /usr/share/zoneinfo/Region（地区名）/City（城市名） /etc/localtime</code> 来设置时区，对于大陆的用户，我们可以使用命令 <code>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code> 来设置北京时间。</p><p>然后同步硬件时间：<code>hwclock --systohc</code>。</p><p>然后我们设置区域和本地化。首先你需要编辑文件 <code>/etc/locale.gen</code> 可以使用命令 <code>nano /etc/locale.gen</code> 或者 <code>vim /etc/locale.gen</code> 如果你会用 <code>vim</code>。在打开的文件中删除你需要的区域前面的 <code>#</code> 符号，比如 <code>en_US.UTF-8</code>。注意不建议使用中文，因为还没有安装必要的字体，设置中文会导致终端全是方块或者菱形，只能等死。</p><p>接着执行 <code>locale-gen</code> 生成区域和本地化信息。</p><p>然后创建 <code>/etc/locale.conf</code> 并在里面输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs conf">LANG=en_US.UTF-8<br></code></pre></td></tr></table></figure><p>也可以设置为你刚刚设置的其他东西。但是 <code>en_US.UTF-8</code> 是最为推荐的。</p><p>然后你还可以设置键盘布局，但是对于绝大部分用户，这是不需要的。因为默认是美式键盘。</p><h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><p>你需要创建 <code>/ect/hostname</code> 文件，在里面输入你的主机名，可以是任意字符串。但是这个主机名只能包含大小写字母和横杠 <code>-</code>。然后保存退出即可。</p><h4 id="设置-root-用户密码"><a href="#设置-root-用户密码" class="headerlink" title="设置 root 用户密码"></a>设置 root 用户密码</h4><p>root 用户是 linux 系统的超级管理员用户，也是这个系统目前唯一的用户，你需要设置他的密码使得你可以使用这个用户登陆。</p><p>使用 <code>passwd</code> 命令来设置密码，注意密码要重复两边输入。</p><h4 id="创建普通用户"><a href="#创建普通用户" class="headerlink" title="创建普通用户"></a>创建普通用户</h4><p>使用命令 <code>useradd -m 用户名</code> 创建你的用户名，其中 <code>-m</code> 指令在创建用户的同时创建这个用户的家目录（<code>HOME</code> 目录）。 注意用户名不要使用特殊字符。但是你需要知道的是这个用户现在并不是管理员用户。然后使用 <code>passwd 用户名</code> 设置你刚刚创建的用户的密码。</p><p>然后使用 <code>usermod -aG 用户名 wheel</code> 将这个用户加入管理员组，其中 <code>-a</code> 指的是复制用户到另外一个用户组而不是移动，这样做是必要的。<code>-G</code> 表示操作用户组。</p><p>最后编辑 <code>/etc/sodoers</code> 文件将下面这一行代码取消注释（删除前面的 <code>#</code>）。</p><p><img src="https://cdn.jsdmirror.cn/gh/lixuannan/img/Screenshot%20from%202024-08-22%2019-58-03.png" srcset="/img/loading.gif" lazyload></p><h3 id="配置引导程序"><a href="#配置引导程序" class="headerlink" title="配置引导程序"></a>配置引导程序</h3><p>这是最后，也是最关键的步骤。</p><p>首先使用命令 <code>pacman -S grub efibootmgr</code> 安装必要的软件包。</p><p>然后使用命令 <code>grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB</code> 安装引导程序。</p><p>最后使用 <code>grub-mkconfig -o /boot/grub/grub.cfg</code> 命令生成引导程序的配置文件。</p><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>在终端中输入 <code>exit</code>，退出新系统，然后在新产生的终端中输入 <code>umount -a</code> 弹出所有磁盘，不用管报错。</p><p>最后输入命令 <code>reboot</code> 重启即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>系统</tag>
      
      <tag>Arch Linux</tag>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024 TYOI 暑假集训游记</title>
    <link href="/posts/16092.html"/>
    <url>/posts/16092.html</url>
    
    <content type="html"><![CDATA[<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>第一天晚上刚到机房就被制裁了。原来放假的时候有比赛，一场没打）：，全去搞文化课了。</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>开幕雷击，上来就比赛，随便水了一下，接近垫底了。太久没有打比赛手感就是不好。</p><h1 id="Day-2-End"><a href="#Day-2-End" class="headerlink" title="Day 2 - End"></a>Day 2 - End</h1><p>此后就开始一直学算法，KMP、Trie 树、AC 自动机什么的都不难，到 DP 就老实了。还好后面回归算法，讲了树剖，舒服了。</p><p>最后一天打 CPC，</p>]]></content>
    
    
    
    <tags>
      
      <tag>游记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Luogu P7537 [COCI2016-2017#4] Rima 题解</title>
    <link href="/posts/42348.html"/>
    <url>/posts/42348.html</url>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>简单类说就是通过拼接字符串，实现两个字符串之间的最长公共后缀长度恰好是较长的字符串的长度 $-1$。并使得最长公共后缀长度最长。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><del>随便做即可。</del></p><p>首先我们观察到题目要求的是后缀，但是显然求后缀的算法并不是很多，于是我们考虑将其反转。然后题目就变成了求前缀。</p><p>反转完我们继续考虑怎么做，对于这种字符串的问题，我们果断猜测使用 Trie 树，或者说字典树。我们先将所有的字符串一起扔到一个字典树里面。</p><p>经过了一番的思考，我们发现在树上进行一次 DP 可以完成答案的统计。</p><p>于是我们从根据根节点开始往下 DFS 遍历整个 Trie 树。定义状态 $f_i$，我们每一次转移之前先获得子节点中 $f$ 值的最大值和次大值，用来统计答案。同时我们还要统计有多少字符串在子节点中截止。</p><p>当我们此时的状态是一个有字符串终结的状态时，我们才进行 $f_i$ 的转移，方程为 $f_i &#x3D; maxn + \max(cnt,, 1)$。其中 $maxn$ 是子节点中最大的 $f$ 值，$cnt$ 是子节点中截止的字符串的个数。</p><p>然后我们考虑如何统计答案。容易发现，对于每一个状态，其答案是 $maxn + smaxn + e_u + \max(0,, cnt - 2)$ 其中 $e_u$ 表示在状态 $u$ 终结的字符串数量，$smaxn$ 为次大值，其余同上。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string str[<span class="hljs-number">500009</span>];<br><span class="hljs-type">int</span> n, nxt[<span class="hljs-number">1000009</span>][<span class="hljs-number">30</span>], cnt, e[<span class="hljs-number">1000009</span>], f[<span class="hljs-number">1000009</span>], ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> dep)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, maxn = <span class="hljs-number">0</span>, smaxn = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nxt[u][i]) &#123;<br>            cnt += e[nxt[u][i]];<br>            <span class="hljs-built_in">dfs</span>(nxt[u][i], dep + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (maxn &lt; f[nxt[u][i]]) &#123;<br>                smaxn = maxn;<br>                maxn = f[nxt[u][i]];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (smaxn &lt; f[nxt[u][i]]) &#123;<br>                smaxn = f[nxt[u][i]];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (e[u]) &#123;<br>        f[u] = maxn + <span class="hljs-built_in">max</span>(cnt, <span class="hljs-number">1LL</span>);<br>    &#125;<br>    ans = <span class="hljs-built_in">max</span>(ans, maxn + smaxn + e[u] + <span class="hljs-built_in">max</span>(<span class="hljs-number">0LL</span>, cnt - <span class="hljs-number">2</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; str[i];<br>        <span class="hljs-built_in">reverse</span>(str[i].<span class="hljs-built_in">begin</span>(), str[i].<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> j: str[i]) &#123;<br>            <span class="hljs-keyword">if</span> (!nxt[p][j - <span class="hljs-string">&#x27;a&#x27;</span>]) &#123;<br>                nxt[p][j - <span class="hljs-string">&#x27;a&#x27;</span>] = ++cnt;<br>            &#125;<br>            p = nxt[p][j - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        e[p] += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OiClass PUJI P2232 Friends 题解</title>
    <link href="/posts/31541.html"/>
    <url>/posts/31541.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>容易发现枚举添加的是哪个字符是很好的，但是我们需要解决哈希的问题。</p><p>考虑拼凑，不难发现，对于 <code>ABXC</code> 去掉 <code>X</code> 之后的 <code>AB C</code> 这个字符串，他的哈希是 <code>AB</code> 的哈希乘上 <code>C</code> 的位权。于是我们分类讨论一下删去的字符在哪个位置，然后分别处理即可。</p><p>但是在统计答案的时候仍然有很多细节。首先是不能在每次都记录字串，因为取字串的函数复杂度并不优秀。我们需要记录答案的哈希值，然后每次先对比哈希值，如果不同再更新答案。这样在去重的同时可以解决取子串不快的问题。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> hs[<span class="hljs-number">2000009</span>], pw[<span class="hljs-number">2000009</span>];<br>string s;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">Hash</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">return</span> hs[r] - hs[l - <span class="hljs-number">1</span>] * pw[r - l + <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>cin &gt;&gt; n &gt;&gt; s;<br><span class="hljs-keyword">if</span> ((s.<span class="hljs-built_in">size</span>() &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;NOT POSSIBLE&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>pw[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>pw[i] = pw[i - <span class="hljs-number">1</span>] * <span class="hljs-number">38734667</span>;<br>hs[i] = hs[i - <span class="hljs-number">1</span>] * <span class="hljs-number">38734667</span> + s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;A&#x27;</span>;<br>&#125;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> hashs = <span class="hljs-number">1</span>;<br>string str;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> h1, h2;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>h1 = <span class="hljs-built_in">Hash</span>(<span class="hljs-number">2</span>, (n &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>), h2 = <span class="hljs-built_in">Hash</span>((n &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>, n);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; (n &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>h1 = <span class="hljs-built_in">Hash</span>(<span class="hljs-number">1</span>, (n &gt;&gt; <span class="hljs-number">1</span>)), h2 = <span class="hljs-built_in">Hash</span>((n &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>, i) * pw[n - (i + <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>] + <span class="hljs-built_in">Hash</span>(i + <span class="hljs-number">2</span>, n);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == (n &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>h1 = <span class="hljs-built_in">Hash</span>(<span class="hljs-number">1</span>, (n &gt;&gt; <span class="hljs-number">1</span>)), h2 = <span class="hljs-built_in">Hash</span>((n &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>, n);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>h1 = <span class="hljs-built_in">Hash</span>(<span class="hljs-number">1</span>, i) * pw[(n &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span> - (i + <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>] + <span class="hljs-built_in">Hash</span>(i + <span class="hljs-number">2</span>, (n &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>), h2 = <span class="hljs-built_in">Hash</span>((n &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>, n);<br>&#125;<br><span class="hljs-keyword">if</span> (h1 == h2) &#123;<br><span class="hljs-keyword">if</span> (h1 == hashs) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>string s;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>s = ::s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, n &gt;&gt; <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; (n &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>s = ::s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, n &gt;&gt; <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == (n &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>s = ::s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, n &gt;&gt; <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s = ::s.<span class="hljs-built_in">substr</span>((n &gt;&gt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>, n &gt;&gt; <span class="hljs-number">1</span>);<br>&#125;<br>cnt += <span class="hljs-number">1</span>;<br>hashs = h1;<br>str = s;<br><span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;NOT UNIQUE&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br>cout &lt;&lt; (cnt &gt; <span class="hljs-number">0</span> ? str : <span class="hljs-string">&quot;NOT POSSIBLE&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1368E Ski Accidents 题解</title>
    <link href="/posts/28582.html"/>
    <url>/posts/28582.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先我们看到题中给出，这个图是一个 DAG，因此很容易的就可以想到拓扑排序。那么我们在思考一下，如何满足题目中给出的删除的点不超过 $\frac{4}{7}n$ 的要求。我们可以举一个例子，看到下面的二叉树：</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/graph-2024-2-25.png" srcset="/img/loading.gif" lazyload></p><p>如果我们按照拓扑排序遍历，每次遍历到深度对 $3$ 取模为 $0$ 的节点，就删除。那么很显然，这个策略可以正常的分割出符合条件的链。同时，对于这个具有 $7$ 个节点的图，他只删除了 $4$ 个节点，满足题目 $\frac{4}{7}n$ 的限制。</p><p>由此我们可以发现，无论怎么删除，都可以满足题目 $\frac{4}{7}n$ 的限制。那么只要我们按照拓扑序遍历这个图，遇到深度超的就删除，就可以简单的水掉这一道紫题。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>拓扑序遍历即可，注意多测要清空。代码如下：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m, u, v, d[<span class="hljs-number">200009</span>], dp[<span class="hljs-number">200009</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; g[<span class="hljs-number">200009</span>], ans, a[<span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            d[i] = <span class="hljs-number">0</span>;<br>            dp[i] = <span class="hljs-number">0</span>;<br>            g[i].<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        ans.<span class="hljs-built_in">clear</span>();<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            g[u].<span class="hljs-built_in">push_back</span>(v);<br>            d[v] += <span class="hljs-number">1</span>;<br>        &#125;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!d[i]) &#123;<br>                q.<span class="hljs-built_in">push</span>(i);<br>                dp[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (dp[u] &gt;= <span class="hljs-number">3</span>) &#123;<br>                dp[u] = <span class="hljs-number">0</span>;<br>                ans.<span class="hljs-built_in">push_back</span>(u);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v: g[u]) &#123;<br>                d[v] -= <span class="hljs-number">1</span>;<br>                dp[v]= <span class="hljs-built_in">max</span>(dp[v], dp[u] + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (!d[v]) &#123;<br>                    d[v] = <span class="hljs-number">-1</span>;<br>                    q.<span class="hljs-built_in">push</span>(v);<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i: ans) &#123;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OiClass TIGAO P3280 牛牛的猜球游戏题解</title>
    <link href="/posts/21737.html"/>
    <url>/posts/21737.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先考虑暴力的做法，直接依题意模拟模拟，时间复杂度是 $\mathcal{O}(nm)$，显然不能通过。但是我们可以发现这种修改方式似乎很适合预处理，然后我就想到了使用前缀和的做法。然后每次进行替代，但是经过一段时间的调试，无法通过，果断放弃。</p><p>我们考虑时间复杂度稍高的分块做法，我们规定块长为 $\sqrt{n}$，然后将 $n$ 次操作分成 $\sqrt{n}$ 个块，对于每个块，我们使用暴力的方式预处理每一个快中操作的结果。</p><p>然后对于每一次查询，我们先是用暴力的方法跳到一个块的起点，然后一块一块的王后跳，跳到不够一个块的时候就再次使用暴力的方法往后计算答案。这样操作时间复杂度是 $\mathcal{O}(n + m\sqrt{n})$ 的，跑满只要 $3 \times 10^7$，非常可过。事实也证明了这一点，我的程序最满点只要 $300, \rm ms$ 就能跑完。但是隔壁 ty_xyz 的代码需要整整 $1.5,\rm s$，不知为何。</p><p>当然，由于分块和线段树有很多共性，我们可以使用线段树维护这样的东西，我想不明白，就不讲了，时间复杂度 $\mathcal{O}(m \log n)$，也是非常优的（参考 ty_xyz 的做法）。当然如果你是 DP 大佬，也可以 $O(m + n)$ 做，但是我也不会，可以参考 lovely_akcode 的做法。  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m, blksize, blkcnt, blk[<span class="hljs-number">100009</span>][<span class="hljs-number">20</span>], a[<span class="hljs-number">20</span>], b[<span class="hljs-number">20</span>];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; v;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;ball.in&quot;</span>, <span class="hljs-string">&quot;rt&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;ball.out&quot;</span>, <span class="hljs-string">&quot;wt&quot;</span>, stdout);<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    blksize = <span class="hljs-built_in">sqrt</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>        a[j] = j;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, a, b; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        v.<span class="hljs-built_in">push_back</span>(&#123;a, b&#125;);<br>        <span class="hljs-built_in">swap</span>(::a[a], ::a[b]);<br>        <span class="hljs-keyword">if</span> (i % blksize == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">memcpy</span>(blk[blkcnt++], ::a, <span class="hljs-built_in">sizeof</span>(::a));<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>                ::a[j] = j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, l, r; i &lt;= m; i++) &#123;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        l -= <span class="hljs-number">1</span>; r -= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>            a[j] = j;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (; l % blksize != <span class="hljs-number">0</span> &amp;&amp; l &lt;= r; l++) &#123;<br>            <span class="hljs-built_in">swap</span>(a[v[l].first], a[v[l].second]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (; l + blksize &lt;= r; l += blksize) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>                b[j] = a[blk[l / blksize][j]];<br>            &#125;<br>            <span class="hljs-built_in">memcpy</span>(a, b, <span class="hljs-built_in">sizeof</span>(a));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (; l &lt;= r; l++) &#123;<br>            <span class="hljs-built_in">swap</span>(a[v[l].first], a[v[l].second]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>            cout &lt;&lt; a[j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OiClass TIGAO P3279 牛牛的方程式题解</title>
    <link href="/posts/7145.html"/>
    <url>/posts/7145.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先观察一下方程：$ax+by+cz&#x3D;d$。观察可以得到，他有整数解当且仅当 $\gcd(a,, b,, c) \equiv 0 \pmod d$，也就是说 $d$ 被 $a,, b,, c$ 的最大公因数整除。显然这是正确的。</p><p>但是通过以上的思路，我们只能通过小样例，在面对大样例的时候这个方法仍然有些力不从心。在 $a,,b,,c$ 三者之中如果出现了 $0$，那么显然此时公因数就会是 $0$，这时取余就会出事。于是我们考虑如何判断。观察大样例就会发现，这个方程有解当且仅当 $d \neq 0$，其余情况无解。</p><p>于是这样我们就可以不知所以然的通过这题。</p><p>听 GPT 说好像是通过拓展贝祖定理得到的，不会，可以自行 BDFS。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t, a, b, c, d;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;func.in&quot;</span>, <span class="hljs-string">&quot;rt&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;func.out&quot;</span>, <span class="hljs-string">&quot;wt&quot;</span>, stdout);<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;<br>        a = <span class="hljs-built_in">abs</span>(a), b = <span class="hljs-built_in">abs</span>(b);<br>        c = <span class="hljs-built_in">abs</span>(c), d = <span class="hljs-built_in">abs</span>(d);<br>        <span class="hljs-type">int</span> e = __gcd(__gcd(a, b), c);<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (d == <span class="hljs-number">0</span>) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (d % e == <span class="hljs-number">0</span>) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OiClass TIGAO P3333 路径难题题解</title>
    <link href="/posts/24926.html"/>
    <url>/posts/24926.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先考虑暴力建边的做法，我们使用 $\mathcal{O}({t_i}^2)$ 的时间建立公交站的边。然后我们考虑如何计算答案。考虑到每次坐公交车的时候都会进行出租车的结算，于是我们直接累计到最后才向上取整的做法是没有正确性的。</p><p>于是我们考虑每次到公交节点的时候就进行向上取整，这样就可以保证 Dijkstra 的正确性。</p><p>这样就解决了正确性的问题，然后考虑如何优化公交的建边。我们可以采用常用的套路：虚点。通过建立一个和所有公交站点连线的虚点来表示一个公交站。其中，向虚点的“上车”路线代价是 $c$，下车的从虚点到站点的代价是 $0$。这样就解决的建边时间复杂度的问题。</p><p>给予上面的思路简单实现即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m, k, r, q;<br><span class="hljs-type">double</span> dis[<span class="hljs-number">200009</span>];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt;&gt; g[<span class="hljs-number">200009</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">127</span>, <span class="hljs-built_in">sizeof</span>(dis));<br>    dis[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = pq.<span class="hljs-built_in">top</span>().second;<br>        pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [v, w] : g[u]) &#123;<br>            <span class="hljs-keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;<br>                <span class="hljs-keyword">if</span> (v &gt; n) &#123;<br>                    dis[v] = <span class="hljs-built_in">ceil</span>(dis[u] + w);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dis[v] = dis[u] + w;<br>                &#125;<br>                pq.<span class="hljs-built_in">push</span>(&#123;-dis[v], v&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;path.in&quot;</span>, <span class="hljs-string">&quot;rt&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;path.out&quot;</span>,<span class="hljs-string">&quot;wt&quot;</span>, stdout);<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; r &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u, v, w, i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        g[u].<span class="hljs-built_in">push_back</span>(&#123;v, w * <span class="hljs-number">1.0</span> / r&#125;);<br>        g[v].<span class="hljs-built_in">push_back</span>(&#123;u, w * <span class="hljs-number">1.0</span> / r&#125;);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, t, c; i &lt;= k; i++) &#123;<br>        cin &gt;&gt; t &gt;&gt; c;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>, x; j &lt;= t; j++) &#123;<br>            cin &gt;&gt; x;<br>            g[n + i].<span class="hljs-built_in">push_back</span>(&#123;x, <span class="hljs-number">0</span>&#125;);<br>            g[x].<span class="hljs-built_in">push_back</span>(&#123;n + i, c&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, u, v; i &lt;= q; i++) &#123;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        <span class="hljs-built_in">dijkstra</span>(u);<br>        cerr &lt;&lt; endl;<br>        cout &lt;&lt; (<span class="hljs-type">int</span>) <span class="hljs-built_in">ceil</span>(dis[v]) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OiClass PU2TI P3042 拓展的奇拼图题解</title>
    <link href="/posts/32290.html"/>
    <url>/posts/32290.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先发现这题是八数码问题的加强版，但是数据量非常大，爆搜+剪枝的方法非常的不可取，于是我们考虑是否可以通过一些神秘的判断方法来判断出是否可以构造出来。</p><p>从数据量可以感受出来应该是使用某种接近线性的算法，果断猜测是否是逆序对。把矩阵展开后去掉 $0$，然后计算逆序对个数，判断奇偶性即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, a[<span class="hljs-number">250009</span>], c[<span class="hljs-number">250009</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= n * n; i += <span class="hljs-built_in">lowbit</span>(i)) &#123;<br>        c[i] += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i -= <span class="hljs-built_in">lowbit</span>(i)) &#123;<br>        res += c[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(c, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(c));<br>    num *= num;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x, cnt = <span class="hljs-number">1</span>, i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;<br>        cin &gt;&gt; x;<br>        <span class="hljs-keyword">if</span> (x) &#123;<br>            a[cnt++] = x;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; num; i++) &#123;<br>        res += i - <span class="hljs-number">1</span> - <span class="hljs-built_in">query</span>(a[i]);<br>        <span class="hljs-built_in">add</span>(a[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>        <span class="hljs-type">int</span> a = <span class="hljs-built_in">work</span>(n), b = <span class="hljs-built_in">work</span>(n);<br>        cout &lt;&lt; ((a &amp; <span class="hljs-number">1</span>) == (b &amp; <span class="hljs-number">1</span>) ? <span class="hljs-string">&quot;TAK\n&quot;</span> : <span class="hljs-string">&quot;NIE\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OiClass PU2TI P3186 小美的排队次数 题解</title>
    <link href="/posts/21158.html"/>
    <url>/posts/21158.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><del>以下格式模仿睿智的官方题解。</del></p><ul><li>$10,%$ 做法：呵呵，对于这种神奇的算法还是表示不明觉厉。</li><li>$40,%$ 做法：呵呵，依题意模拟计数即可。</li><li>$100,%$ 做法：呵呵，<del>随便做即可</del>。考虑以下先做一轮，观察一下有什么性质。手磨样例，一轮以后是 <code>1, 2, 3, 5, 4, 6</code> 发现每一次只可能交换相邻的两个数，于是猜测逆序对。简单再次手磨以下， <code>1, 2, 3, 5, 4, 6</code> 的逆序对个数是 $1$ 个，巧了，过样例！下载个大样例，也过了，爽！然后自信提交，$80 {\rm pts}$​？<strong>十年 OI 一场空，不开 <code>long long</code> 见祖宗！</strong>。</li></ul><p>补一句，树状数组跑的还是比线段树和归并快很多的。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240619165706940.png" srcset="/img/loading.gif" lazyload alt="image-20240619165706940"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, h[<span class="hljs-number">100009</span>], t[<span class="hljs-number">100009</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) &#123;<br>t[i] += <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i)) &#123;<br>res += t[i];<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cin &gt;&gt; h[i];<br>&#125;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l &lt;= n; l++) &#123;<br><span class="hljs-type">int</span> r = l;<br><span class="hljs-keyword">for</span> (r; r &lt;= n <span class="hljs-keyword">and</span> h[r + <span class="hljs-number">1</span>] &lt;= h[r] <span class="hljs-keyword">and</span> h[r + <span class="hljs-number">1</span>] != <span class="hljs-number">0</span>; r++);<br><span class="hljs-keyword">if</span> (l == r) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-built_in">reverse</span>(h + l, h + r + <span class="hljs-number">1</span>);<br>cnt += <span class="hljs-number">1</span>;<br>l = r;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cnt += i - <span class="hljs-number">1</span> - <span class="hljs-built_in">query</span>(h[i]);<br><span class="hljs-built_in">add</span>(h[i]);<br>&#125;<br>cout &lt;&lt; cnt;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPOJ SETSTACK 题解</title>
    <link href="/posts/51536.html"/>
    <url>/posts/51536.html</url>
    
    <content type="html"><![CDATA[<h2 id="题意">题意</h2><p>有一个装着集合的栈，需要你实现以下操作：</p><ul><li><strong>PUSH</strong>. 将把空集 <spanclass="math inline">\(\{\}\)</span> 推到堆栈上。</li><li><strong>DUP</strong>.将复制最顶层的集合（弹出堆栈，然后将该集合推入堆栈两次）。</li><li><strong>UNION</strong>.会弹出堆栈两次，然后将两个集合的联合值推入堆栈。</li><li><strong>INTERSECT</strong>.会弹出堆栈两次，然后将两个集合的交集推到堆栈上。</li><li><strong>ADD</strong>.会弹出堆栈两次，将第一个集合加入第二个集合，然后将得到的集合推到堆栈上。</li></ul><p>对于每一次操作，输出操作后栈顶集合的大小，集合的大小为集合中元素的个数，嵌套的集合算一个，具体举个例子：</p><ul><li><span class="math inline">\(s = \{\{\{\{\{\}\}\}\},\,\{\{\}\}\}\)</span>，<span class="math inline">\(|s| = 2\)</span>。</li></ul><h2 id="思路">思路</h2><p><del>其实很简单，依题意模拟即可。</del></p><p>PUSH 和 DUP比较简单，不讲。我们下面开始考虑如何进行其他三个操作：</p><ul><li><strong>ADD</strong>.对于这个操作，我们将第一个集合取出来，然后用一个哈希表保存集合的唯一编号，将编号加入第二个集合即可。</li><li><strong>INTERSECT</strong>. 注意不是 <strong>INTERSECTION</strong>！！！！！我因为这个交了整整一页，在这里对洛谷和 SPOJ表示诚挚的歉意。废话不多说，我们考虑如何求这两个集合的交集。观察到<code>algorithm</code> 库中有一个叫做 <code>set_intersection</code>的函数，看起来可以求交集。的确可以，假设我们有三个集合 <spanclass="math inline">\(s_1,\,s_2,\,s_3\)</span>，我们要求 <spanclass="math inline">\(s_1 \cap s_2\)</span> 的代码就是<code>set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(s3, s3.begin()));</code>很简单，对吧！</li><li><strong>UNION</strong>. 再次观察到 <code>algorithm</code>库中还有一个叫做 <code>set_union</code>的函数，显然可以求并集。用法如下：<code>set_union(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(s3, s3.begin()));</code></li></ul><p>对于每一次操作，很容易发现其实答案就是栈顶元素的<code>size</code>，因为每一次有新的集合出现都会被压缩成一个数字，不会产生嵌套被多次统计的情况。</p><p>简单实现即可，注意千万不要打错<strong>INTERSECT</strong>！！！！！！</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t, n, cnt;<br>string s;<br>set&lt;<span class="hljs-type">int</span>&gt; emp;<br>map&lt;set&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt; mp;<br>stack&lt;set&lt;<span class="hljs-type">int</span>&gt;&gt; stk;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sign_up</span><span class="hljs-params">(set&lt;<span class="hljs-type">int</span>&gt; st)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!mp.<span class="hljs-built_in">count</span>(st)) &#123;<br>mp[st] = ++cnt;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; t;<br><span class="hljs-keyword">while</span> (t--) &#123;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n--) &#123;<br>cin &gt;&gt; s;<br><span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;PUSH&quot;</span>) &#123;<br><span class="hljs-built_in">sign_up</span>(emp);<br>stk.<span class="hljs-built_in">push</span>(emp);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;DUP&quot;</span>) &#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1 = stk.<span class="hljs-built_in">top</span>();<br>stk.<span class="hljs-built_in">push</span>(s1);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;UNION&quot;</span>) &#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1, s2, s3;<br>s1 = stk.<span class="hljs-built_in">top</span>();<br>stk.<span class="hljs-built_in">pop</span>();<br>s2 = stk.<span class="hljs-built_in">top</span>();<br>stk.<span class="hljs-built_in">pop</span>();<br><span class="hljs-built_in">set_union</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(s3, s<span class="hljs-number">3.</span><span class="hljs-built_in">begin</span>()));<br><span class="hljs-built_in">sign_up</span>(s3);<br>stk.<span class="hljs-built_in">push</span>(s3);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;INTERSECT&quot;</span>) &#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1, s2, s3;<br>s1 = stk.<span class="hljs-built_in">top</span>();<br>stk.<span class="hljs-built_in">pop</span>();<br>s2 = stk.<span class="hljs-built_in">top</span>();<br>stk.<span class="hljs-built_in">pop</span>();<br><span class="hljs-built_in">set_intersection</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), s<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(s3, s<span class="hljs-number">3.</span><span class="hljs-built_in">begin</span>()));<br><span class="hljs-built_in">sign_up</span>(s3);<br>stk.<span class="hljs-built_in">push</span>(s3);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;ADD&quot;</span>) &#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1, s2;<br>s1 = stk.<span class="hljs-built_in">top</span>();<br>stk.<span class="hljs-built_in">pop</span>();<br>s2 = stk.<span class="hljs-built_in">top</span>();<br>stk.<span class="hljs-built_in">pop</span>();<br>s<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(mp[s1]);<br><span class="hljs-built_in">sign_up</span>(s2);<br>stk.<span class="hljs-built_in">push</span>(s2);<br>&#125;<br>cout &lt;&lt; stk.<span class="hljs-built_in">top</span>().<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;***\n&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>SPOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPOJ MARTIAN 题解</title>
    <link href="/posts/57531.html"/>
    <url>/posts/57531.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先简单理解一下题目，会发现题目就是在网格上选择若干列（或列的上面一段）以及若干行（或行的左边一段）似的这些被选中的列和行之间的和最大。具体可以看题目的这张图：</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/SP2884/ffb61c2e9bce1280c236f5e44fd476053da539eb.png" srcset="/img/loading.gif" lazyload></p><p>很明显这是一个 DP 问题，于是我们着手设计状态转移方程。首先我们先分别预处理出纵向的和横向的两个前缀和分别是 $y_{i,,j}$ 和 $b_{i,,j}$，字母对应题目的矿物名称首字母。然后我们设状态 $f_{i,,j}$ 表示从这个位置开始到左上角的答案（最多的采矿数量和）。然后我们发现状态 $f_{i,,j}$ 只与 $f_{i - 1, j}$ 和 $f_{i,, j - 1}$ 有关。</p><p>稍加思考即可得出我们的状态转移方程：<br>$$<br>f_{i,,j} &#x3D; \max\left(f_{i - 1,,j} + b_{i,,j},, f_{i,,j - 1} + y_{i,,j}\right)<br>$$<br>于是就可以快乐 DP 了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m, y[<span class="hljs-number">509</span>][<span class="hljs-number">509</span>], b[<span class="hljs-number">509</span>][<span class="hljs-number">509</span>], f[<span class="hljs-number">509</span>][<span class="hljs-number">509</span>];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> &amp;&amp; m == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>cin &gt;&gt; b[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>cin &gt;&gt; y[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>b[i][j] += b[i][j - <span class="hljs-number">1</span>];<br>y[i][j] += y[i - <span class="hljs-number">1</span>][j];<br>&#125;<br>&#125;<br><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> f);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j] + b[i][j], f[i][j - <span class="hljs-number">1</span>] + y[i][j]);<br>&#125;<br>&#125;<br>cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>SPOJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AtCoder ABC206D KAIBUNsyo 题解</title>
    <link href="/posts/30504.html"/>
    <url>/posts/30504.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>观察到替换数字的过程，实际上就是将两个数字归为一类。借此不难联想到并查集的工作过程，因此我们可以考虑使用并查集解决这个问题。</p><p>我们使用并查集维护当前数字所属的集合，初始时对于数字 $x$，它位于集合 $x$ 中。当我们发现本应相同但是并不在同一个集合内的数字时，我们不得不将其合并，并记录下一次操作。在操作的过程中，你不需要去判断究竟是改为了左边的或者右边的数字，只需要知道它们二者同属一个集合即可。需要注意的是，对于 $a_i$，他一开始属于集合 $a_i$ 而不是集合 $i$，这个搞得我调了好一会儿，服了。</p><p>简单分析可以得到，程序的时间复杂度控制在了极其优秀的 $\mathcal{O}(n ,\alpha(n))$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> get(x) (n - x + 1)</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, fa[<span class="hljs-number">200009</span>], a[<span class="hljs-number">200009</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cin &gt;&gt; a[i];<br>fa[a[i]] = a[i];<br>&#125;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / <span class="hljs-number">2</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(a[i]) != <span class="hljs-built_in">find</span>(a[<span class="hljs-built_in">get</span>(i)])) &#123;<br>fa[<span class="hljs-built_in">find</span>(a[i])] = <span class="hljs-built_in">find</span>(a[<span class="hljs-built_in">get</span>(i)]);<br>ans += <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>AtCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OiClass PUJI P3827 函数 题解</title>
    <link href="/posts/47712.html"/>
    <url>/posts/47712.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先化简一下公式：<br>$$<br>\begin{align*}<br>f(n,,r)&amp;&#x3D;{\rm C}^r_n (n - r)!\<br>&amp;&#x3D;\frac{A^r_n(n - r)!}{r!}\<br>&amp;&#x3D;\frac{n!}{r!}\<br>&amp;&#x3D;\prod _{i&#x3D;r + 1}^n i<br>\end{align*}<br>$$<br>但是数据范围很大，于是我们考虑使用数据结构来优化这个查询。第一感觉是 ST 表，结果发现预处理和查询都会遇到除法，这就会导致你需要使用逆元，能不能卡过去切不好说，代码难度已经很高了。</p><p>于是我们使用众所周知的线段树来解决区间查询的问题，就十分简单了，简单建一下树然后直接查询就可以了，根本不用修改之类的操作，十分简单。就是需要注意一下开 <code>__int128</code>，要不然计算的过程中会爆 <code>long long</code>，大寄。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> q, mod, n, r;<br>__int128 tree[<span class="hljs-number">400009</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> node, <span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l == r) &#123;<br>tree[node] = l;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">build</span>(node &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br><span class="hljs-built_in">build</span>(node &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>tree[node] = (tree[node &lt;&lt; <span class="hljs-number">1</span>] * tree[node &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]) % mod;<br>&#125;<br><br><span class="hljs-function">__int128 <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> <span class="hljs-type">int</span> L, <span class="hljs-type">const</span> <span class="hljs-type">int</span> R)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;<br><span class="hljs-keyword">return</span> tree[node];<br>&#125;<br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>__int128 ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (L &lt;= mid) &#123;<br>ans *= <span class="hljs-built_in">query</span>(node &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R);<br>ans %= mod;<br>&#125;<br><span class="hljs-keyword">if</span> (R &gt; mid) &#123;<br>ans *= <span class="hljs-built_in">query</span>(node &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R);<br>ans %= mod;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; q &gt;&gt; mod;<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>);<br><span class="hljs-keyword">while</span> (q--) &#123;<br>cin &gt;&gt; n &gt;&gt; r;<br>cout &lt;&lt; (<span class="hljs-type">int</span>) <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>, r + <span class="hljs-number">1</span>, n) &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1612D X-Magic Pair 题解</title>
    <link href="/posts/9199.html"/>
    <url>/posts/9199.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们首先假定 $a &lt; b$ ，那么我们可以通过题目给定的方式将 $(a,,b)$ 转移到：</p><ul><li>$(b - a,,b)$</li><li>$(a,,b- a)$</li></ul><p>这是显然的。但是我们发现如果我们转化为 $(b - a,, a)$，那么下一步就会转移到：</p><ul><li>$((b - a) - (b - a),, a) &#x3D; (0,,a)$</li><li>$(b - a,, a - (b - a)) &#x3D; (b -a,, 2a - b)$</li></ul><p>很显然这两种情况都是相当复杂且并不优的，于是我们只考虑转移到 $(a,, b - a)$ 的情况。</p><p>在这种情况中，如果一直转换，就会变成 $(a,,b - ka)$，其中 $k \in \mathbb{Z}^+$。</p><p>知道了转移方式，我们就只需要判断 $b - ka &#x3D; x$ 或者 $a &#x3D; x$ 即可，而 $b - ka &#x3D; x$ 又可以被表达为 $b - x \equiv 0 \pmod a$，使得判断更为简单。此后类似辗转相除的递归 $(b \bmod a, a)$ 判断即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t, a, b, x;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (b &lt; a) &#123;<br><span class="hljs-built_in">swap</span>(a, b);<br>&#125;<br><span class="hljs-keyword">if</span> (a &lt;= <span class="hljs-number">0</span> || b &lt;= <span class="hljs-number">0</span> || b &lt; x) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (a == x || (b - x) % a == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(b % a, a, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; t;<br><span class="hljs-keyword">while</span> (t--) &#123;<br>cin &gt;&gt; a &gt;&gt; b &gt;&gt; x;<br><span class="hljs-keyword">if</span> (b &lt; a) &#123;<br><span class="hljs-built_in">swap</span>(a, b);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(a, b, x)) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA929 Number Maze 题解</title>
    <link href="/posts/7177.html"/>
    <url>/posts/7177.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单看一下题目，可以理解为在网格上寻找从点 $(1,,1)$ 到点 $(n,,m)$ 的最短路，其中权值为点权。</p><p>我们可以考虑直接使用 Dijkstra 算法在网格上跑一遍最短路算法，求得答案。下面简述一下 Dijkstra 算法的过程：</p><ol><li><p>创建一个大小与顶点数量相等的数组 $f$，用于存储起始点到各个顶点的当前最短距离估计值。</p></li><li><p>将起始点的距离值设置为起始点的点权，其他点的距离值设置为无穷大（或一个足够大的值）。</p></li><li><p>将起始点加入优先队列，按照距离值从小到大进行排序。</p></li><li><p>重复以下步骤直到优先队列为空：</p><ul><li>弹出队首元素，表示当前最短路径已确定。</li><li>遍历队首元素的所有邻接网格，如果通过对首到达邻居的距离比当前记录的距离更短，则更新邻居的距离值。</li><li>如果值更新了，那么将邻居其加入队列。</li></ul></li><li><p>最终得到的 $f$ 数组即为起始点到各个点的最短距离。</p></li></ol><p>这样就可以轻松的通过本题啦！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t, n, m, a[<span class="hljs-number">1009</span>][<span class="hljs-number">1009</span>], f[<span class="hljs-number">1009</span>][<span class="hljs-number">1009</span>];<br><span class="hljs-type">int</span> xx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, yy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">63</span>, <span class="hljs-keyword">sizeof</span> f);<br>f[x][y] = a[x][y];<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; pq;<br>pq.<span class="hljs-built_in">push</span>(&#123;-f[x][y], &#123;x, y&#125;&#125;);<br><span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> fx = pq.<span class="hljs-built_in">top</span>().second.first, fy = pq.<span class="hljs-built_in">top</span>().second.second;<br>pq.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br><span class="hljs-type">int</span> nx = fx + xx[i], ny = fy + yy[i];<br><span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">1</span> || ny &lt; <span class="hljs-number">1</span> || nx &gt; n || ny &gt; m) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (f[nx][ny] &gt; f[fx][fy] + a[nx][ny]) &#123;<br>f[nx][ny] = f[fx][fy] + a[nx][ny];<br>pq.<span class="hljs-built_in">push</span>(&#123;-f[nx][ny], &#123;nx, ny&#125;&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; t;<br><span class="hljs-keyword">while</span> (t--) &#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>cin &gt;&gt; ch;<br>a[i][j] = ch - <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AT_arc132_b Shift and Reverse 题解</title>
    <link href="/posts/38985.html"/>
    <url>/posts/38985.html</url>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个序列，你可以将它<strong>翻转</strong>或者将<strong>第一个数挪到最后面</strong>，求最小的操作使得序列升序的次数。<strong>数据保证有解</strong>。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先我们可以看到题目中说<strong>保证一定有解</strong>，因此我们可以发现挪动的方式一定是将前面的数整体挪到到后面或者翻转后将前面的数移到后面再翻转回来。看一个例子：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>答案显然是将序列整体翻转后将 <code>2 1</code> 挪到最后面然后再翻转回来，次数为 <code>4</code>。</p><p>有了上面的结论，我们就可以分类讨论一下：</p><ul><li><strong>有序。</strong> 直接输出 $0$。</li><li><strong>直接移动</strong>。 答案为 $n - a_1 + 1$。</li><li><strong>翻转后移动再翻转。</strong> 答案为 $a_1 +1$。</li></ul><p>对于后面的两种情况，取最小值即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, a[<span class="hljs-number">3</span>];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n &gt;&gt; a[<span class="hljs-number">1</span>] &gt;&gt; a[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">if</span> (a[<span class="hljs-number">1</span>] == <span class="hljs-number">1</span> &amp;&amp; a[<span class="hljs-number">2</span>] == <span class="hljs-number">2</span>) &#123;<br>cout &lt;&lt; <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-built_in">min</span>(a[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, n - a[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>AtCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Luogu P2568 GCD 题解</title>
    <link href="/posts/33139.html"/>
    <url>/posts/33139.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先我们可以根据题意列出式子：<br>$$<br>\sum_{p \in {\mathbb P}}\sum_{i &#x3D; 1}^{n} \sum_{j&#x3D;1}^n [\gcd(i, j)&#x3D;p]<br>$$<br>根据一些神秘的直觉，可以将式子化简成下面的样子：<br>$$<br>\sum_{p \in {\mathbb P}} \sum_{i &#x3D; 1}^{\left\lfloor\frac n p\right\rfloor}\sum_{j &#x3D; 1}^{\left\lfloor\frac n p\right\rfloor}[\gcd(i, j) &#x3D; 1]<br>$$<br>根据欧拉函数 $\varphi$ 的定义，我们可以把式子进一步化简：<br>$$<br>\begin{align*}<br>原式 &amp;&#x3D; \sum_{p \in {\mathbb P}} \sum_{i &#x3D; 1}^{\left\lfloor\frac n p\right\rfloor} \left(2 \times \left(\sum_{j &#x3D; 1}^i [\gcd(i, j)]\right)- 1\right)\<br>&amp;&#x3D; \sum_{p \in {\mathbb P}} \left(2 \times\sum_{i &#x3D; 1}^{\left\lfloor\frac n p\right\rfloor} \varphi(i)\right) - 1<br>\end{align*}<br>$$<br>然后线性筛筛出所有质数和欧拉函数值，做一下前缀和就可以了。时间复杂度是 ${\mathcal O}(n)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, ans, phi[<span class="hljs-number">10000009</span>];<br>bitset&lt;10000009&gt; p;<br>vector&lt;<span class="hljs-type">int</span>&gt; pri;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (!p[i]) &#123;<br>pri.<span class="hljs-built_in">push_back</span>(i);<br>phi[i] = i - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j: pri) &#123;<br><span class="hljs-keyword">if</span> (i * j &gt; n) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>p[i * j] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) &#123;<br>phi[i * j] = phi[i] * j;<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>phi[i * j] = phi[i] * phi[j];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>phi[i] += phi[i - <span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-built_in">init</span>(n);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i: pri) &#123;<br>ans += (phi[n / i] &lt;&lt; <span class="hljs-number">1LL</span>) - <span class="hljs-number">1</span>;<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TYCPC 游记</title>
    <link href="/posts/61466.html"/>
    <url>/posts/61466.html</url>
    
    <content type="html"><![CDATA[<h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>感觉出题人就是 ___ ，出的全是人类智慧题，罚时吃饱了！</p><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>不会。</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>分解质因数秒了，就是有点担心 <code>unordered_map</code> 常数太大，不过卡过去了，不慌。</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>排序建图后然后直接分联通块就可以了。但是不知道关掉同步流以后 <code>puts</code> 不可以和 <code>cout</code> 一起用，多吃了一发罚时，大悲。</p><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>可以发现，一棵树上的任何一个节点（除根节点）一定入度是 $1$，于是对总度数倒序排序，然后直接建树就可以了，如果度数没用完，就是无解，否则直接输出。</p><h3 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h3><p>纯纯找规律题，一开始找到了一个正确但是不完全的规律，最后放弃。</p><p>突然找到了正确的规律，一遍过掉了 $f_i &#x3D; 3f_{i - 1} - f_{i - 2}$。</p><h3 id="T6-sim-T7"><a href="#T6-sim-T7" class="headerlink" title="T6 $\sim$ T7"></a>T6 $\sim$ T7</h3><p>会不了一点。</p><h3 id="T8"><a href="#T8" class="headerlink" title="T8"></a>T8</h3><p>写一个辅助程序从大样例里面提取出 $26$ 个字母即可，水题。</p><h3 id="T9"><a href="#T9" class="headerlink" title="T9"></a>T9</h3><p>水题，小学生都会。没看到 <code>ull</code> 又奉献了一发罚时，呜呜呜呜呜。</p><h3 id="T10"><a href="#T10" class="headerlink" title="T10"></a>T10</h3><p>容易发现其实就是所有正数的和，特判一下没有正数的情况就是最大的负数即可，特判错了又周一发罚时。</p><h3 id="T11-sim-T12"><a href="#T11-sim-T12" class="headerlink" title="T11 $\sim$ T12"></a>T11 $\sim$ T12</h3><p>做不出来。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>精准控分，成功去不了 GDCPC。都怪罚时太多，服了啊啊啊！</p><p>放一个非常不好评价的颁奖典礼：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe  src="//player.bilibili.com/player.html?bvid=BV18s421K7ju&page=1" scrolling="no" border="0" style="position:absolute; height: 100%; width: 100%;" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div>]]></content>
    
    
    
    <tags>
      
      <tag>OiClass</tag>
      
      <tag>游记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Luogu P1495 题解</title>
    <link href="/posts/48509.html"/>
    <url>/posts/48509.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先看一下题目，可以理解为求解下面的方程：</p><p>$$<br>\left{ \begin{array}{c} x \equiv b_1 \pmod {a_1} \ x \equiv b_2 \pmod {a_2} \ \cdots \ x \equiv b_n \pmod {a_n} \ \end{array} \right.<br>$$</p><p>很显然可以用中国剩余定理求解，下面讲一下具体过程。</p><ul><li>求出 $as &#x3D; \prod a_i$。</li><li>对于每一个方程，求出 $mi &#x3D; \frac {as} {a_i}$，用 <code>exgcd</code> 求出 $mi$ 在 $\mod a_i$ 意义下的逆元。</li><li>更新答案为 $ans + b_i \times mi \times inv$，注意对 $as$ 取模。</li></ul><p>简单实现即可，注意对于 Luogu 版本的数据，需要使用 <code>__int128</code> 通过，应该是卡掉 <code>exgcd</code> 了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>__int128 n, a[<span class="hljs-number">20</span>], b[<span class="hljs-number">20</span>], ans;<br><br><span class="hljs-function">__int128 <span class="hljs-title">exgcd</span><span class="hljs-params">(__int128 a, __int128 b, __int128 &amp;x, __int128 &amp;y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    __int128 d = <span class="hljs-built_in">exgcd</span>(b, a % b, x, y);<br>    __int128 t = x;<br>    x = y;<br>    y = t - a / b * y;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> tmp;<br>    cin &gt;&gt; tmp;<br>    n = tmp;<br>    __int128 as = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; tmp;<br>        a[i] = tmp;<br>        cin &gt;&gt; tmp;<br>        b[i] = tmp;<br>        as = as * a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        __int128 mi = as / a[i], b, y;<br>        <span class="hljs-built_in">exgcd</span>(mi, a[i], b, y);<br>        ans = (ans + ::b[i] * mi * b) % as;<br>    &#125;<br>    cout &lt;&lt; (<span class="hljs-type">int</span>) ((ans % as + as) % as);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024 成都七中多校联训游记</title>
    <link href="/posts/49007.html"/>
    <url>/posts/49007.html</url>
    
    <content type="html"><![CDATA[<h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>早上 6:00 准时起床，跑到番禺校区门口。看到我们的<strong>公务车</strong>，感觉很高级。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0834(20240329-202147).JPG" srcset="/img/loading.gif" lazyload alt="IMG_0834(20240329-202147)"></p><p>结果我们五个学生在车上等 lily 一个人，相当抽象啊。</p><p>到了机场先和番禺的人一起办了值机，然后越秀的说刚出发蚌埠住了。等啊等，看了 $20 \rm min$​​ 的 B 站，感觉他们可能还要很久。准备启动，然后刚进游戏，他们来了！！！受不了一点。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0839(20240329-202147).JPG" srcset="/img/loading.gif" lazyload alt="IMG_0839(20240329-202147)"></p><p>落地成都，在国际到达（下一班飞湾湾），要坐摆渡车到国内到达，顺手拍下了隔壁的一架很好看的飞机。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/32C765EEB412EDC9E9BB24D22C0465E6.png" srcset="/img/loading.gif" lazyload alt="32C765EEB412EDC9E9BB24D22C0465E6"></p><p>在摆渡车上面研究开通成都的乘车码，微信显示不支持该城市。感觉好抽象啊，居然有城市不支持微信乘车码。不过后来打脸了，成都有自己的小程序，叫做<strong>成都地铁</strong>和<strong>成都公交</strong>。地铁和公交甚至都是分开的，相当难绷。总之觉得便民程度不高。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/B762E1FD48469FF1EA54063757253BF4.png" srcset="/img/loading.gif" lazyload alt="B762E1FD48469FF1EA54063757253BF4"></p><p>取行李的时候，非常成功的搞丢了一件行李（SYL 的）。一开始国航说是落在广州了，NB。后来工作人员又过来说卡在传送带里面。直到下一班新疆-成都的行李都出来之后 SYL 的行李在拿到，成功耽误一个半小时。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0845.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0845"></p><p>然后坐地铁去学校，没想到机场的地铁站还要安检？是觉得机场的安检不够严格吗？第一次遇见没有免安检机制的机场。</p><p>到学校附近吃了一碗牛肉面，感觉不辣，挺香的，就是喷了一身红油，失败呜呜呜。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0852.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0852"></p><p>步行 1.5 公里到学校，感觉别人的学校哪哪都要薄纱我们的 TY。学校据说是 2021 年落成的，各项基础设施都很好，宿舍环境超级好。简单买了一些生活用品就去吃饭了。个人认为别人学校的饭各方面薄纱 TY（虽然后面发现鸡腿并没有 TY 的好吃），而且价格很便宜。放几张图：</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0921.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0921"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0896.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0896"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0853.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0853"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0869.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0869"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0871.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0871"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0875.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0875"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0883.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0883"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0884.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0884"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0922.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0922"></p><p>吃完饭开始腐朽，我们一群人聚众联机<strong>速通</strong>（三个半小时） MC，很爽，就是我觉得我连扔两个末影珍珠是很 SB 的行为，整整浪费了一个小时左右的时间。还是太菜了。</p><h2 id="Day-1-sim-Day-5"><a href="#Day-1-sim-Day-5" class="headerlink" title="Day 1 $\sim $ Day 5"></a>Day 1 $\sim $ Day 5</h2><p>Day 1 比赛保龄了，感觉好菜，好在 Day 2 手感略微回复，打的稍微好了一点，勉强给 TY 兜底，总分 Rk. 12。</p><p>每天下午的训练感觉效果不如自学。主要 ACCoders 这个网站太老了，是 HUSTOJ 这个老平台，经常卡常。我 Day 1 比赛就是被卡常卡没的，$RP -&#x3D; inf$。训练的时候也是，在 OiClass 和 Luogu 的 Ac Code 直接交上去平均只有 $80 \rm pts$。一通卡常猛如虎之后通常没有任何进步，SB OJ。再喷一点，就是这个 OJ 提供的题目好多都是题面和数据不符的。举个例子，题面上写着输出 <code>Yes</code>，结果交上去一直 WA，打开一看 **Read <code>Yes</code>, Except <code>YES</code>**。直接蚌埠住了。还有就是这个弱智 OJ 禁用了一些语法，比如 <code>ctime</code> 库、<code>auto</code> 语句，这些都是很重要的东西啊啊啊啊啊。这个弱智网站已经使我倒退回 C++98 时代，毫无现代语法了。STL 的使用也得小心翼翼，毕竟常数啊啊。</p><p>课程的方面，PPT 质量很高，但是讲课的人把超高水平的 PPT 硬是念出了念经的感觉，声音一大一小，跟 xiaosi 一样。而且给的题单超级多题目，整整 $30+$，不过一般有 $\sim 10$ 的原题，很爽。</p><p>开幕式是在 Day 1 晚上举行的，请了不少领导和教练讲话，都很精彩。最震惊的是这边的宿管竟然讲话能力异常的好，拿捏我们的德育处主任。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0862.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0862"></p><h3 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h3><p>今天是休息日！！！出去玩！！！</p><p>我们先去了杜甫草堂，感觉园林设计的很好，加上前一天晚上下了雨，给人一种很通透的感觉，放几张图：</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0940.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0940"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0942.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0942"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0948.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0948"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0954.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0954"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0955.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0955"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0960.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0960"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0974.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0974"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0976.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0976"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0978.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0978"></p><p>中午在锦里，实际上锦里并不大，而且没有什么新鲜的东西，如果不是去武侯祠的话，并不推荐去，建议闭坑。不过虽然东西不丰富，还是买了很多纪念品的，吃的话没什么好推荐，连钵钵鸡我个人也认为一般。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0984.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0984"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0985.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0985"></p><p>下午在武侯祠，实际上就是杜甫草堂 Pro Max，但是更有文化底蕴吧。拜了刘关张，愿保佑我进队。顺便拍了一张刘备墓的照片，交作业（清明节作业）。感觉刘备四舍五入也算是先烈吧，毕竟为大汉做出了不少贡献。差点建立了统一的多民族国家（学历史学魔怔了）。补一句，$400$ 大洋雇的导游讲解会很好，我们 TY 和 SS 一起，$20$ 多人性价比很高。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_1034.JPG" srcset="/img/loading.gif" lazyload alt="IMG_1034"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_1039.JPG" srcset="/img/loading.gif" lazyload alt="IMG_1039"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_1041.JPG" srcset="/img/loading.gif" lazyload alt="IMG_1041"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_1016.JPG" srcset="/img/loading.gif" lazyload alt="IMG_1016"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_1026.JPG" srcset="/img/loading.gif" lazyload alt="IMG_1026"></p><p>晚上在宽窄巷子吃饭，龙请客，加上 SS 花了 $3000+$​，很豪爽。不过说真的，挺好吃，而且氛围很好，所有人都吃的很嗨，总之爽了。吃饭还有表演看，没想到第一次看川剧变脸是在饭店：）。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_1054.JPG" srcset="/img/loading.gif" lazyload alt="IMG_1054"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_1064.JPG" srcset="/img/loading.gif" lazyload alt="IMG_1064"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_1067.JPG" srcset="/img/loading.gif" lazyload alt="IMG_1067"></p><p>饭后下了一点小雨，和 HH_yst 撑一把伞逛街，有些抽象，毕竟满街 CP，突然想她了。事实证明，宽巷子并不是很宽，窄巷子也不窄，应该只是商业炒作诞生的噱头罢了。不过我还是在宽窄巷子买了一直小熊猫，超级可爱！（づ￣3￣）づ╭❤～</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_1076.JPG" srcset="/img/loading.gif" lazyload alt="IMG_1076"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_1088.JPG" srcset="/img/loading.gif" lazyload alt="IMG_1088"></p><h2 id="Day-7-sim-Day-14"><a href="#Day-7-sim-Day-14" class="headerlink" title="Day 7 $\sim$ Day 14"></a>Day 7 $\sim$ Day 14</h2><p>训练上没什么好说的，和原来都一样，只是感觉自己确实有所进步了 ヾ(◍°∇°◍)ﾉﾞ</p><p>值得说的是，我和 syl 和 sxd 完成了 TYOI 史上的第一场洛谷公开赛！！！一开始我们准备出小月赛，然后开始出题，感觉良好，于是决定出大月赛，狠狠捞 kkksc03 一笔。突然发现我们并没有完成一道原创紫黑的能力，大悲！就在我们都想咕咕咕的时候，我突然发现！</p><p>这些题刚好够出一场基础赛诶！然后请 sxd 口胡了一道黄题出来，够了！这道黄题的诞生也是十分坎坷，我们派 sxd 完成这个艰巨的任务，他很快就口胡出来了。这会我在处理另外一题的数据，苏神在按照我刚刚狂码出来的题面做题。sxd 说他标程好了，我直接 copy 过来花两分钟用 python 谢了一个数据生成器，然后无脑造数据。苏神一交，五颜六色！感觉不妙，我赶紧 $5$ 分钟随便码了一个出来，交上去和苏神一毛一样。可以断定 sxd 的标程错了呜呜呜呜呜呜。我快速用我的代码重造了数据，苏神也是直接就过了。然后我们去写题解，sxd 调了半个小时，笑死。</p><p>最后希望我们的基础赛过审吧！爱死你了小 E，一定要让我过审啊！</p>]]></content>
    
    
    
    <tags>
      
      <tag>游记</tag>
      
      <tag>成都七中</tag>
      
      <tag>多校联训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024 成都七中多校联训内容</title>
    <link href="/posts/8218.html"/>
    <url>/posts/8218.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是较为完整的训练内容，当然有若干场训练并没有整理出题单，而是写在了 PPT 里面，懒了，不搬了。其次有一场讲评的录屏是不完整的，这个要怪讲评人。</p><h2 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h2><p>题目原题均在 ACCoders，被 CodingCow 搬到了 OiClass（有些没搬），题面可能略有修改，数据并非原数据，是重新造的。</p><h3 id="2024-多校集训-C-层-冲刺-NOIP-模拟-1"><a href="#2024-多校集训-C-层-冲刺-NOIP-模拟-1" class="headerlink" title="2024 多校集训 C 层 - 冲刺 NOIP 模拟 1"></a>2024 多校集训 C 层 - 冲刺 NOIP 模拟 1</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ol><li><a href="http://www.oiclass.com/p/P9006"><strong>P9006</strong> 操作</a></li><li><a href="http://www.oiclass.com/p/P9007"><strong>P9007</strong> 染色 II</a></li><li><a href="http://www.oiclass.com/p/P9008"><strong>P9008</strong> 旅游</a></li><li><a href="http://www.oiclass.com/p/P9009"><strong>P9009</strong> 游戏</a></li></ol><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/4716.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="2024-多校集训-C-层-冲刺-NOIP-模拟-2"><a href="#2024-多校集训-C-层-冲刺-NOIP-模拟-2" class="headerlink" title="2024 多校集训 C 层 - 冲刺 NOIP 模拟 2"></a>2024 多校集训 C 层 - 冲刺 NOIP 模拟 2</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><ol><li><a href="http://www.oiclass.com/p/P9010"><strong>P9010</strong> 差异</a></li><li><a href="http://www.oiclass.com/p/P9011"><strong>P9011</strong> 染色 I</a></li><li><a href="http://www.oiclass.com/p/P9012"><strong>P9012</strong> 好数</a></li><li><a href="http://www.oiclass.com/p/P9013"><strong>P9013</strong> &#x2F;tp</a></li></ol><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/4717.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="2024-多校集训-C-层-冲刺-NOIP-模拟-3"><a href="#2024-多校集训-C-层-冲刺-NOIP-模拟-3" class="headerlink" title="2024 多校集训 C 层 - 冲刺 NOIP 模拟 3"></a>2024 多校集训 C 层 - 冲刺 NOIP 模拟 3</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><ol><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240331145527.png" srcset="/img/loading.gif" lazyload></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240331145853.png" srcset="/img/loading.gif" lazyload></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240331150128.png" srcset="/img/loading.gif" lazyload></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240331150317.png" srcset="/img/loading.gif" lazyload></li></ol><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/4718.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="2024-多校集训-C-层-冲刺-NOIP-模拟-4"><a href="#2024-多校集训-C-层-冲刺-NOIP-模拟-4" class="headerlink" title="2024 多校集训 C 层 - 冲刺 NOIP 模拟 4"></a>2024 多校集训 C 层 - 冲刺 NOIP 模拟 4</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><ol><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/a.png" srcset="/img/loading.gif" lazyload></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/b.png" srcset="/img/loading.gif" lazyload></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/c.png" srcset="/img/loading.gif" lazyload></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/d.png" srcset="/img/loading.gif" lazyload></li></ol><h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/4719.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="2024-多校集训-C-层-冲刺-NOIP模拟-5"><a href="#2024-多校集训-C-层-冲刺-NOIP模拟-5" class="headerlink" title="2024 多校集训 C 层 - 冲刺 NOIP模拟 5"></a>2024 多校集训 C 层 - 冲刺 NOIP模拟 5</h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><ol><li><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/11143.pdf" width="100%" height="550" type="application/pdf"></div></li><li><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/11144.pdf" width="100%" height="550" type="application/pdf"></div></li><li><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/11155.pdf" width="100%" height="550" type="application/pdf"></div></li><li><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/11156.pdf" width="100%" height="550" type="application/pdf"></div></li></ol><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/4720.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="2024-多校集训-C-层-冲刺-NOIP-模拟-6"><a href="#2024-多校集训-C-层-冲刺-NOIP-模拟-6" class="headerlink" title="2024 多校集训 C 层 - 冲刺 NOIP 模拟 6"></a>2024 多校集训 C 层 - 冲刺 NOIP 模拟 6</h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/4721.pdf" width="100%" height="550" type="application/pdf"></div><h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/solution4721.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="2024-多校集训-C-层-冲刺-NOIP-模拟-7"><a href="#2024-多校集训-C-层-冲刺-NOIP-模拟-7" class="headerlink" title="2024 多校集训 C 层 - 冲刺 NOIP 模拟 7"></a>2024 多校集训 C 层 - 冲刺 NOIP 模拟 7</h3><h4 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/4722.pdf" width="100%" height="550" type="application/pdf"></div><h4 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/solution4722.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>训练题非常多，有原题的放了原题，没有的是截图，见谅。</p><h3 id="2024-多校集训-C-层-基础算法：-二分、三分、哈希、高精度、位运算、模拟退火"><a href="#2024-多校集训-C-层-基础算法：-二分、三分、哈希、高精度、位运算、模拟退火" class="headerlink" title="2024 多校集训 C 层 - 基础算法： 二分、三分、哈希、高精度、位运算、模拟退火"></a>2024 多校集训 C 层 - 基础算法： 二分、三分、哈希、高精度、位运算、模拟退火</h3><h4 id="课件"><a href="#课件" class="headerlink" title="课件"></a>课件</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/day1-%E4%BA%8C%E5%88%86%EF%BC%8C%E4%B8%89%E5%88%86%EF%BC%8C%E5%93%88%E5%B8%8C%EF%BC%8C%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%8C%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%8C%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB.pdf" width="100%" height="550" type="application/pdf"></div><h4 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h4><div style="position: relative; width: 100%;  height: 0;padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=1002718283&bvid=BV1fx4y1a78Q&cid=1490226997&p=1" scrolling="no" border="0" style="position:absolute; height: 100%; width: 100%;" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h4 id="题单"><a href="#题单" class="headerlink" title="题单"></a>题单</h4><ol><li>[<a href="https://www.luogu.com.cn/problem/P1080">NOIP2012 提高组] 国王游戏</a></li><li>[<a href="https://www.luogu.com.cn/problem/P1083">NOIP2012 提高组] 借教室</a></li><li>[<a href="https://www.luogu.com.cn/problem/P1084">NOIP2012 提高组] 疫情控制</a></li><li>[<a href="https://www.luogu.com.cn/problem/P2678">NOIP2015 提高组] 跳石头</a></li><li>[<a href="https://www.luogu.com.cn/problem/P2680">NOIP2015 提高组] 运输计划</a></li><li>[<a href="https://www.luogu.com.cn/problem/P1314">NOIP2011 提高组] 聪明的质监员</a></li><li><a href="https://www.luogu.com.cn/problem/P1661">扩散</a></li><li>[<a href="https://www.luogu.com.cn/problem/P1525">NOIP2010 提高组] 关押罪犯</a></li><li><a href="https://www.luogu.com.cn/problem/UVA10385">Duathlon</a></li><li>[<a href="https://www.luogu.com.cn/problem/P5931">清华集训2015] 灯泡</a></li><li><a href="https://www.luogu.com.cn/problem/P2142">高精度减法</a></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240401171335912.png" srcset="/img/loading.gif" lazyload alt="image-20240401171335912"></li><li><a href="https://www.acwing.com/problem/content/93/">最短Hamilton路径</a></li><li>[<a href="https://www.luogu.com.cn/problem/P1337">JSOI2004] 平衡点 &#x2F; 吊打XXX</a></li><li><a href="http://www.oiclass.com/d/puji/p/P2514"><strong>P2514</strong> 收集雪花</a></li><li>[<a href="https://www.luogu.com.cn/problem/P2503">HAOI2006] 均分数据</a></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240401172011196.png" srcset="/img/loading.gif" lazyload alt="image-20240401172011196"></li><li><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1694"><strong>YBT1694</strong> 回文串</a></li></ol><h3 id="2024-多校集训-C-层-数学：排列组合、扩展欧几里得德、快筛素数、欧拉函数、容斥原理、逆元、BSGS、莫比乌斯反演、LUCAS"><a href="#2024-多校集训-C-层-数学：排列组合、扩展欧几里得德、快筛素数、欧拉函数、容斥原理、逆元、BSGS、莫比乌斯反演、LUCAS" class="headerlink" title="2024 多校集训 C 层 - 数学：排列组合、扩展欧几里得德、快筛素数、欧拉函数、容斥原理、逆元、BSGS、莫比乌斯反演、LUCAS"></a>2024 多校集训 C 层 - 数学：排列组合、扩展欧几里得德、快筛素数、欧拉函数、容斥原理、逆元、BSGS、莫比乌斯反演、LUCAS</h3><h4 id="课件-1"><a href="#课件-1" class="headerlink" title="课件"></a>课件</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/day2-%E6%95%B0%E8%AE%BA.pdf" width="100%" height="550" type="application/pdf"></div><h4 id="课程-1"><a href="#课程-1" class="headerlink" title="课程"></a>课程</h4><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=1652723394&bvid=BV1SE421g7RT&cid=1490229120&p=1" scrolling="no" border="0" style="position:absolute; height: 100%; width: 100%;" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h4 id="题单-1"><a href="#题单-1" class="headerlink" title="题单"></a>题单</h4><ol><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240401190008593.png" srcset="/img/loading.gif" lazyload alt="image-20240401190008593"></li><li>[<a href="https://www.luogu.com.cn/problem/P2522">HAOI2011] Problem b</a></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240401190407192.png" srcset="/img/loading.gif" lazyload alt="image-20240401190407192"></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240401190521192.png" srcset="/img/loading.gif" lazyload alt="image-20240401190521192"></li><li><a href="https://www.luogu.com.cn/problem/P3811">【模板】模意义下的乘法逆元</a></li><li>[<a href="https://www.luogu.com.cn/problem/P1082">NOIP2012 提高组] 同余方程</a></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240401190643142.png" srcset="/img/loading.gif" lazyload alt="image-20240401190643142"></li><li>[<a href="https://www.luogu.com.cn/problem/P6076">JSOI2015] 染色问题</a></li><li><a href="https://hydro.ac/d/bzoj/p/4403"><strong>P4403</strong> 序列统计</a></li><li>[<a href="https://www.luogu.com.cn/problem/P3455">POI2007] ZAP-Queries</a></li><li>[<a href="https://hydro.ac/d/bzoj/p/2440">中山市选2011]完全平方数</a></li><li><a href="https://hydro.ac/d/bzoj/p/2818"><strong>P2818</strong> Gcd</a></li><li><a href="https://hydro.ac/d/bzoj/p/3643"><strong>P3643</strong> Phi的反函数</a></li><li><a href="https://hydro.ac/d/bzoj/p/1409"><strong>P1409</strong> Password</a></li><li>[<a href="https://www.luogu.com.cn/problem/P3312">SDOI2014] 数表</a></li><li><a href="https://www.luogu.com.cn/problem/SP3105">MOD - Power Modulo Inverted</a></li><li><a href="https://www.luogu.com.cn/problem/P2158">[SDOI2008] 仪仗队</a></li><li><a href="https://www.luogu.com.cn/problem/P2155">[SDOI2008] 沙拉公主的困惑</a></li><li><a href="https://www.luogu.com.cn/problem/P5228">[AHOI2013] 找硬币</a></li><li><a href="https://hydro.ac/d/bzoj/p/4173"><strong>P4173</strong> 数学</a><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240401191723618.png" srcset="/img/loading.gif" lazyload alt="image-20240401191723618"></li><li>[<a href="https://www.luogu.com.cn/problem/P3747">六省联考 2017] 相逢是问候</a></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240401191939429.png" srcset="/img/loading.gif" lazyload alt="image-20240401191939429"></li><li><a href="https://www.luogu.com.cn/problem/P4296">[AHOI2007] 密码箱</a></li></ol><h3 id="2024-多校集训-C-层-动态规划：背包、树形、状压、数位、期望DP"><a href="#2024-多校集训-C-层-动态规划：背包、树形、状压、数位、期望DP" class="headerlink" title="2024 多校集训 C 层 - 动态规划：背包、树形、状压、数位、期望DP"></a>2024 多校集训 C 层 - 动态规划：背包、树形、状压、数位、期望DP</h3><h4 id="课件-2"><a href="#课件-2" class="headerlink" title="课件"></a>课件</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.pdf" width="100%" height="550" type="application/pdf"></div><h4 id="课程-2"><a href="#课程-2" class="headerlink" title="课程"></a>课程</h4><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=1052725878&bvid=BV18H4y1n7At&cid=1490248378&p=1" scrolling="no" border="0" style="position:absolute; height: 100%; width: 100%;" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h4 id="题单-2"><a href="#题单-2" class="headerlink" title="题单"></a>题单</h4><ol><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240401192335544.png" srcset="/img/loading.gif" lazyload alt="image-20240401192335544"></li><li>[<a href="https://www.luogu.com.cn/problem/P1541">NOIP2010 提高组] 乌龟棋</a></li><li><a href="http://www.oiclass.com/p/P1264"><strong>P1264</strong> 沙子合并</a></li><li><a href="https://www.luogu.com.cn/problem/P1879">[USACO06NOV] Corn Fields G</a></li><li><a href="http://www.oiclass.com/d/puji/p/P1453"><strong>P1453</strong> 二叉苹果树</a></li><li>[<a href="https://www.luogu.com.cn/problem/P1896">SCOI2005] 互不侵犯</a></li><li><a href="https://www.luogu.com.cn/problem/B3637">最长上升子序列</a></li><li><a href="http://www.oiclass.com/p/P1227"><strong>P1227</strong> 合唱队形</a></li><li><a href="https://www.luogu.com.cn/problem/P1020">[NOIP1999 提高组] 导弹拦截</a></li><li><a href="https://www.acwing.com/problem/content/1080/">旅游规划</a></li><li><a href="https://www.luogu.com.cn/problem/P1352">没有上司的舞会</a></li><li><a href="https://www.luogu.com.cn/problem/P3155">[CQOI2009] 叶子的染色</a></li><li><a href="https://www.luogu.com.cn/problem/P2607">[ZJOI2008] 骑士</a></li><li><a href="https://www.luogu.com.cn/problem/P5336">[THUSC2016] 成绩单</a></li><li><a href="https://www.luogu.com.cn/problem/P3736">[HAOI2016] 字符合并</a></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/TIM%E6%88%AA%E5%9B%BE20191028134304(2).png" srcset="/img/loading.gif" lazyload></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/1777.png" srcset="/img/loading.gif" lazyload></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/1778.png" srcset="/img/loading.gif" lazyload></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/1779.png" srcset="/img/loading.gif" lazyload></li><li><a href="http://www.oiclass.com/p/P1192"><strong>P1192</strong> 滑雪</a></li><li><a href="http://www.oiclass.com/p/P1241"><strong>P1241</strong> 最长公共子序列</a></li><li><a href="https://www.luogu.com.cn/problem/P4290">[HAOI2008] 玩具取名</a></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240401194016408.png" srcset="/img/loading.gif" lazyload alt="image-20240401194016408"></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240401194032073.png" srcset="/img/loading.gif" lazyload alt="image-20240401194032073"></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240401194049647.png" srcset="/img/loading.gif" lazyload alt="image-20240401194049647"></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240401194101973.png" srcset="/img/loading.gif" lazyload alt="image-20240401194101973"></li><li><a href="https://www.luogu.com.cn/problem/P1064">[NOIP2006 提高组] 金明的预算方案</a></li><li><a href="https://www.luogu.com.cn/problem/P2966">[USACO09DEC] Cow Toll Paths G</a></li><li><a href="http://www.oiclass.com/d/puji/p/P1458"><strong>P1458</strong> 电脑网络</a></li><li><a href="https://www.luogu.com.cn/problem/P2602">[ZJOI2010] 数字计数</a></li><li><a href="https://www.luogu.com.cn/problem/P4206">[NOI2005] 聪聪与可可</a></li><li><a href="https://www.luogu.com.cn/problem/P4316">绿豆蛙的归宿</a></li></ol><h3 id="2024-多校集训-C-层-基础数据结构：-单调栈、单调队列、树的遍历、直径、哈夫曼树、二叉排序树、LCA、RMQ"><a href="#2024-多校集训-C-层-基础数据结构：-单调栈、单调队列、树的遍历、直径、哈夫曼树、二叉排序树、LCA、RMQ" class="headerlink" title="2024 多校集训 C 层 - 基础数据结构： 单调栈、单调队列、树的遍历、直径、哈夫曼树、二叉排序树、LCA、RMQ"></a>2024 多校集训 C 层 - 基础数据结构： 单调栈、单调队列、树的遍历、直径、哈夫曼树、二叉排序树、LCA、RMQ</h3><h4 id="课件-3"><a href="#课件-3" class="headerlink" title="课件"></a>课件</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.pdf" width="100%" height="550" type="application/pdf"></div><h4 id="课程-3"><a href="#课程-3" class="headerlink" title="课程"></a>课程</h4><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=1952520670&bvid=BV1WC411L7Ai&cid=1490249307&p=1" scrolling="no" border="0" style="position:absolute; height: 100%; width: 100%;" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h4 id="题单-3"><a href="#题单-3" class="headerlink" title="题单"></a>题单</h4><ol><li><a href="https://www.luogu.com.cn/problem/P5788">【模板】单调栈</a></li><li><a href="https://www.luogu.com.cn/problem/P1886">滑动窗口 &#x2F;【模板】单调队列</a></li><li><a href="https://www.luogu.com.cn/problem/CF372C">Watching Fireworks is Fun</a></li><li><a href="https://www.luogu.com.cn/problem/P4381">[IOI2008] Island</a></li><li><a href="https://www.luogu.com.cn/problem/P8251">[NOI Online 2022 提高组] 丹钓战</a></li><li><a href="https://www.luogu.com.cn/problem/P3865">【模板】ST 表</a></li><li><a href="https://www.luogu.com.cn/problem/P2471">[SCOI2007] 降雨量</a></li><li><a href="https://www.luogu.com.cn/problem/P7596">「EZEC-8」游戏蛇</a></li><li><a href="https://www.luogu.com.cn/problem/CF1476F">Lanterns</a></li><li><a href="https://www.luogu.com.cn/problem/P2168">[NOI2015] 荷马史诗</a></li><li><a href="https://www.luogu.com.cn/problem/P3379">【模板】最近公共祖先（LCA）</a></li><li><a href="https://www.luogu.com.cn/problem/P3398">仓鼠找 sugar</a></li><li><a href="https://www.luogu.com.cn/problem/P3304">[SDOI2013] 直径</a></li><li><a href="https://www.luogu.com.cn/problem/P4408">[NOI2003] 逃学的小孩</a></li><li><a href="https://www.luogu.com.cn/problem/CF418D">Big Problems for Organizers</a></li><li><a href="https://www.luogu.com.cn/problem/CF1192B">Dynamic Diameter</a></li></ol><h3 id="2024-多校集训-C-层-图论：最短路径、最小生成树、拓扑排序、连通分量、割点与桥、二分图、简单网络流"><a href="#2024-多校集训-C-层-图论：最短路径、最小生成树、拓扑排序、连通分量、割点与桥、二分图、简单网络流" class="headerlink" title="2024 多校集训 C 层 - 图论：最短路径、最小生成树、拓扑排序、连通分量、割点与桥、二分图、简单网络流"></a>2024 多校集训 C 层 - 图论：最短路径、最小生成树、拓扑排序、连通分量、割点与桥、二分图、简单网络流</h3><h4 id="课件-4"><a href="#课件-4" class="headerlink" title="课件"></a>课件</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/3%E5%9B%BE%E8%AE%BA.pdf" width="100%" height="550" type="application/pdf"></div><h4 id="课程-4"><a href="#课程-4" class="headerlink" title="课程"></a>课程</h4><p>无</p><h4 id="题单-4"><a href="#题单-4" class="headerlink" title="题单"></a>题单</h4><ol><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240402170527221.png" srcset="/img/loading.gif" lazyload alt="image-20240402170527221"></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240402170627027.png" srcset="/img/loading.gif" lazyload alt="image-20240402170627027"></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240402170654227.png" srcset="/img/loading.gif" lazyload alt="image-20240402170654227"></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240402170738769.png" srcset="/img/loading.gif" lazyload alt="image-20240402170738769"></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240402170850629.png" srcset="/img/loading.gif" lazyload alt="image-20240402170850629"></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240402170932608.png" srcset="/img/loading.gif" lazyload alt="image-20240402170932608"></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240402171020465.png" srcset="/img/loading.gif" lazyload alt="image-20240402171020465"></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240402171104838.png" srcset="/img/loading.gif" lazyload alt="image-20240402171104838"></li><li><a href="https://www.luogu.com.cn/problem/P3386">【模板】二分图最大匹配</a></li><li><a href="https://www.luogu.com.cn/problem/P3254">圆桌问题</a></li><li><a href="https://www.luogu.com.cn/problem/P4015">运输问题</a></li><li><a href="https://www.luogu.com.cn/problem/P4014">分配问题</a></li><li><a href="https://www.luogu.com.cn/problem/P2053">[SCOI2007] 修车</a></li><li><a href="https://www.luogu.com.cn/problem/P3376">【模板】网络最大流</a></li><li>[<a href="https://www.luogu.com.cn/problem/P2341">USACO03FALL &#x2F; HAOI2006] 受欢迎的牛 G</a></li><li>[<a href="https://www.luogu.com.cn/problem/P1894">USACO4.2] 完美的牛栏The Perfect Stall</a></li><li><a href="https://www.luogu.com.cn/problem/P2731">[USACO3.3] 骑马修栅栏 Riding the Fences</a></li><li><a href="https://www.luogu.com.cn/problem/P1119">灾后重建</a></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240402172247198.png" srcset="/img/loading.gif" lazyload alt="image-20240402172247198"></li><li>[<a href="https://www.luogu.com.cn/problem/P3275">SCOI2011] 糖果</a></li><li><a href="https://www.luogu.com.cn/problem/UVA1723">Intervals</a></li><li><a href="https://www.luogu.com.cn/problem/P4180">[BJWC2010] 严格次小生成树</a></li><li><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20240402185649017.png" srcset="/img/loading.gif" lazyload alt="image-20240402185649017"></li><li>[<a href="https://www.luogu.com.cn/problem/P2860">USACO06JAN] Redundant Paths G</a></li><li><a href="https://www.luogu.com.cn/problem/SP2878">KNIGHTS - Knights of the Round Table</a></li><li><a href="https://www.luogu.com.cn/problem/P1640">[SCOI2010] 连续攻击游戏</a></li><li>[<a href="https://www.luogu.com.cn/problem/P2754">CTSC1999] 家园 &#x2F; 星际转移问题</a></li><li>[<a href="https://www.luogu.com.cn/problem/P4452">国家集训队] 航班安排</a></li><li>[<a href="https://www.luogu.com.cn/problem/P4177">CEOI2008] order</a></li><li><a href="https://www.luogu.com.cn/problem/P6768">[USACO05MAR] Ombrophobic Bovines 发抖的牛</a></li></ol><h3 id="2024-多校集训-C-层-数据结构：线段树、树状数组、主席树"><a href="#2024-多校集训-C-层-数据结构：线段树、树状数组、主席树" class="headerlink" title="2024 多校集训 C 层 - 数据结构：线段树、树状数组、主席树"></a>2024 多校集训 C 层 - 数据结构：线段树、树状数组、主席树</h3><h4 id="课件-5"><a href="#课件-5" class="headerlink" title="课件"></a>课件</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8E%E5%B9%B3%E8%A1%A1%E6%A0%91.pdf" width="100%" height="550" type="application/pdf"></div><h4 id="课程-5"><a href="#课程-5" class="headerlink" title="课程"></a>课程</h4><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=1802689722&bvid=BV1Ut421n7dx&cid=1494265735&p=1" scrolling="no" border="0" style="position:absolute; height: 100%; width: 100%;" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=1702635652&bvid=BV1VK421h79J&cid=1494866822&p=1" scrolling="no" border="0" style="position:absolute; height: 100%; width: 100%;" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h4 id="题单-5"><a href="#题单-5" class="headerlink" title="题单"></a>题单</h4><ol><li><a href="https://www.luogu.com.cn/problem/CF438D">The Child and Sequence</a></li><li><a href="https://www.luogu.com.cn/problem/P1502">窗口的星星</a></li><li><a href="https://www.luogu.com.cn/problem/CF558E">A Simple Task</a></li><li><a href="https://www.luogu.com.cn/problem/P1637">三元上升子序列</a></li><li><a href="https://www.luogu.com.cn/problem/CF869E">The Untended Antiquity</a></li><li><a href="https://www.luogu.com.cn/problem/P3567">[POI2014] KUR-Couriers</a></li><li><a href="https://www.luogu.com.cn/problem/P1168">中位数</a></li><li>[<a href="https://www.luogu.com.cn/problem/P2757">国家集训队] 等差子序列</a></li><li>[<a href="https://www.luogu.com.cn/problem/P1972">SDOI2009] HH的项链</a></li></ol><h3 id="2024-多校集训-C-层-DFS、BFS记忆化搜索、迭代加深搜索、二分搜索、剪枝-、双向广度优先搜索、A-算法"><a href="#2024-多校集训-C-层-DFS、BFS记忆化搜索、迭代加深搜索、二分搜索、剪枝-、双向广度优先搜索、A-算法" class="headerlink" title="2024 多校集训 C 层 - DFS、BFS记忆化搜索、迭代加深搜索、二分搜索、剪枝 、双向广度优先搜索、A*算法"></a>2024 多校集训 C 层 - DFS、BFS记忆化搜索、迭代加深搜索、二分搜索、剪枝 、双向广度优先搜索、A*算法</h3><h4 id="课件-6"><a href="#课件-6" class="headerlink" title="课件"></a>课件</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/DFS%E3%80%81BFS%20%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E3%80%81%E9%80%89%E4%BB%A3%E5%8A%A0%E6%B7%B1%E6%90%9C%E7%B4%A2%E3%80%81%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E3%80%81%E5%89%AA%E6%9E%9D%E5%8F%8C%E5%90%91%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E3%80%81Astar%E7%AE%97%E6%B3%95.pdf" width="100%" height="550" type="application/pdf"></div><h4 id="课程-6"><a href="#课程-6" class="headerlink" title="课程"></a>课程</h4><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=1502963830&bvid=BV1PD421p7M2&cid=1497647970&p=1" scrolling="no" border="0" style="position:absolute; height: 100%; width: 100%;" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h4 id="题单-6"><a href="#题单-6" class="headerlink" title="题单"></a>题单</h4><p>无</p><h3 id="2024-多校集训-C-层-动态规划：概率-DP（最基础）、DP-的简单优化"><a href="#2024-多校集训-C-层-动态规划：概率-DP（最基础）、DP-的简单优化" class="headerlink" title="2024 多校集训 C 层 - 动态规划：概率 DP（最基础）、DP 的简单优化"></a>2024 多校集训 C 层 - 动态规划：概率 DP（最基础）、DP 的简单优化</h3><h4 id="课件-7"><a href="#课件-7" class="headerlink" title="课件"></a>课件</h4><div class="row">    <embed src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E8%AF%BE%E4%BB%B6.pdf" width="100%" height="550" type="application/pdf"></div><h4 id="课程-7"><a href="#课程-7" class="headerlink" title="课程"></a>课程</h4><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=1152877229&bvid=BV1uZ421q7cZ&cid=1498271852&p=1" scrolling="no" border="0" style="position:absolute; height: 100%; width: 100%;" frameborder="no" framespacing="0" allowfullscreen="true"></div><h4 id="题单-7"><a href="#题单-7" class="headerlink" title="题单"></a>题单</h4><ol><li>[<a href="https://www.luogu.com.cn/problem/P3628">APIO2010] 特别行动队</a></li><li><a href="https://www.luogu.com.cn/problem/P3195">[HNOI2008] 玩具装箱</a></li><li><a href="https://www.luogu.com.cn/problem/P5468">[NOI2019] 回家路线</a></li><li><a href="https://www.luogu.com.cn/problem/P4767">[IOI2000] 邮局</a></li><li><a href="https://www.luogu.com.cn/problem/P6246">[IOI2000] 邮局 加强版</a></li><li>[<a href="https://www.luogu.com.cn/problem/P9963">THUPC 2024 初赛] 前缀和</a></li><li>[<a href="https://www.luogu.com.cn/problem/P3175">HAOI2015] 按位或</a></li><li>[<a href="https://www.luogu.com.cn/problem/P2569">SCOI2010] 股票交易</a></li><li><a href="https://www.luogu.com.cn/problem/P1912">[NOI2009] 诗人小G</a></li><li><a href="https://www.luogu.com.cn/problem/AT_agc058_b">AGC058B] Adjacent Chmax</a></li><li><a href="https://www.luogu.com.cn/problem/P3147">[USACO16OPEN] 262144 P</a></li><li>[<a href="https://www.luogu.com.cn/problem/AT_arc146_e">ARC146E] Simple Speed</a></li><li><a href="https://www.luogu.com.cn/problem/P1365">WJMZBMR打osu! &#x2F; Easy</a></li><li><a href="https://www.luogu.com.cn/problem/P1850">[NOIP2016 提高组] 换教室</a></li><li><a href="https://www.luogu.com.cn/problem/P1654">OSU!</a></li><li>[<a href="https://www.luogu.com.cn/problem/P4284">SHOI2014] 概率充电器</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>成都七中</tag>
      
      <tag>多校联训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法详解 - 素数</title>
    <link href="/posts/29158.html"/>
    <url>/posts/29158.html</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>素数</strong>，又被称为<strong>质数</strong>。我们一般定义质数为除了 $1$ 和自身之外没有其他因数的数，特别的 $1 $ 不是质数。</p><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><h3 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h3><p>我们考虑如何判断质数，一种很显然的思路就是枚举这个数的因数。假设这个数是 $x$，则我们可以枚举 $[2,,\sqrt{x}]$ 之间的整数，判断是否可以整除，如果没有找到一个可以整除的数，那么可以认为这是一个质数。时间复杂度是 $O(\sqrt{x})$​​。显然这并不是很快。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(a)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt; a; i++)<br>        <span class="hljs-keyword">if</span> (a % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Fermat-素数测试"><a href="#Fermat-素数测试" class="headerlink" title="Fermat 素数测试"></a>Fermat 素数测试</h3><p>我们都知道，对于素数 $p$，根据费马小定理：<br>$$<br>a^{p-1} \equiv 1 \pmod p<br>$$<br>那么我们猜想是否这个逆定理也成立，也就是说，如果 $a^{p - 1} \equiv 1 \pmod p$，那么 $p$ 是质数。很显然，你可以举出很多反例，大悲。</p><p>于是我们再次猜想多枚举几个 $a$ 是否可以判断掉更多的伪质数？显然是可以的，但是有一些数即使你遍历完 $[2,,p - 1]$ 的所有数，也无法判断出来。这些数被称为<strong>卡迈克尔数</strong>（Carmichael Number），也被称为<strong>强伪素数</strong>。举个例子，$561$ 就是最小的卡迈克尔数。</p><p>很不幸的是，卡迈克尔数有无数个，但是很幸运的是 $10^8$ 以内的卡迈克尔数只有 $255$ 个，特判一下即可。显然复杂度更加劣了，正确性也堪忧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">fermat</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> n == <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// test_time 为测试次数,建议设为不小于 8</span><br>    <span class="hljs-comment">// 的整数以保证正确率,但也不宜过大,否则会影响效率</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= test_time; ++i) &#123;<br>        <span class="hljs-type">int</span> a = <span class="hljs-built_in">rand</span>() % (n - <span class="hljs-number">2</span>) + <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">quickPow</span>(a, n - <span class="hljs-number">1</span>, n) != <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Miller–Rabin-素性测试"><a href="#Miller–Rabin-素性测试" class="headerlink" title="Miller–Rabin 素性测试"></a>Miller–Rabin 素性测试</h3><p>Miller-Rabin 是一种极其快速的新型素数判定方法，其本质是对 Fermat 素数测试的一些优化和新的判断方式。首先我们需要知道一些定理。</p><ul><li><strong>二次探测定理</strong>。我们令 $p$ 为任意一个奇素数，则若 $x^2 \equiv 1 \pmod p$ 的解为 $x \equiv 1 \pmod p$ 或 $x \equiv p - 1 \pmod p$。</li></ul><p>于是我们可以将二次探测定理和费马素数测试结合起来，得到一个较稳稳定的算法。</p><p>我们考虑将费马素数判断中的式子 $a^{p - 1} \equiv 1 \pmod p$ 改写成 $\left(a^{\frac{p - 1}{2}}\right)^2 \equiv 1 \pmod p$。为什么我们可以这样改呢？很显然 ， $p$ 是质数当且仅当 $p$ 是奇数（$2$ 除外），因此 $p - 1$ 必然是偶数。于是我们可以用二次探测定理来将 $\left(a^{\frac{p - 1}{2}}\right)^2 \equiv 1 \pmod p$ 化为 $a^{\frac{p - 1}{2}} \equiv 1 \pmod p$ 或 $a^{\frac{p - 1}{2}} \equiv p - 1 \pmod p$，判断是否符合费马素数测试。如果符合，那么继续分解测试下去，，直到变成奇数。注意不要产生 $a^{p - 1} \equiv 0 \pmod p$ （$p,|,a^{p -1 }$） 的情况。</p><p>然后就是底数的选择了。经过数千万 oier 的验证，在 <code>int</code> 范围内，使用 ${2,,7,,61}$ 这三个底数是足够的。在 <code>long long</code> 的范围内，使用 ${2,,325,,9375,,28178,,450775,,9780504,,1795265022}$ 这 $7$ 个底数也是完全足够的。时间复杂度为 $\mathcal{O}(\log_3n)$ 带一个 $7$ 或 $3$​​ 倍的常数，非常优秀！</p><p>下面给出一种正确性较高的实现方式（源自 oi-wiki）</p><pre><code class="cpp">bool millerRabin(int n) &#123;    if (n &lt; 3 || n % 2 == 0) return n == 2;    int u = n - 1, t = 0;    while (u % 2 == 0) u /= 2, ++t;    // test_time 为测试次数，建议设为不小于 8    // 的整数以保证正确率，但也不宜过大，否则会影响效率    for (int i = 0; i &lt; test_time; ++i) &#123;        int a = rand() % (n - 2) + 2, v = quickPow(a, u, n);        if (v == 1) continue;        int s;        for (s = 0; s &lt; t; ++s) &#123;            if (v == n - 1) brea</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法详解</tag>
      
      <tag>素数</tag>
      
      <tag>质数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法详解 - 重链剖分</title>
    <link href="/posts/9181.html"/>
    <url>/posts/9181.html</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>重链剖分</strong>，也被称为<strong>树链剖分</strong>，一般的，OIer 口中的树链剖分就是指重链剖分。今天我们就来一起学习重链剖分。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="重儿子"><a href="#重儿子" class="headerlink" title="重儿子"></a>重儿子</h3><p>既然是重链剖分，那么我们就要理解什么是重。我们定义一个点的子节点中子树最大的点为这个点的重儿子。我们可以通过下面的一个例子来理解：</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/graph2024481955.png" srcset="/img/loading.gif" lazyload></p><p>其中，节点 $1$ 的子节点有三个，分别是 $3,,5,,6$，它们的子树大小分别是 $4,,1,,2$，于是我们按照定义可以得到节点 $1$ 的重儿子就是子树大小为 $4$ 的节点 $3$。</p><h3 id="重链"><a href="#重链" class="headerlink" title="重链"></a>重链</h3><p>顾名思义，重链就是重儿子所连成的链，举个例子：</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/hld.png" srcset="/img/loading.gif" lazyload></p><p>其中深色的点就是重儿子，绿色方框框起来的就是一条条重链。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>顾名思义，重链剖分就是把重链找出来。于是我们考虑如何找出来重链。一种很显然的方式就是进行 DFS，我们需要执行两次 DFS。</p><ol><li>在第一次 DFS 中，我们记录出每个节点的子树大小、重儿子、深度的信息。</li><li>第二次，我们按照重儿子优先的顺序再次遍历树，然后记录 DFN 序（也就是 DFS 访问时的时间戳）以及每一条重链的<strong>重链头</strong>。</li></ol><p>由此我们获得的这棵树的 DFN 值，但是这有什么用呢？我们需要先来了解一些性质。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li>每一个树上的节点<strong>属于且仅属于一条重链</strong>。这个其实也很好证明。由于每一个点只有一个重儿子，因此连接这个点的重链有且仅有一条。因此我们会发现重链可以把任意一棵树<strong>完全剖分</strong>（即将一棵树完全的分为若干条链）。</li><li><strong>重链内的 DFN 是连续的</strong>。这个性质很容易得到，因为我们是重度优先搜索的，因此我们必然优先搜索同一条重链上的点，于是我们同一条重链上的 DFN 就是连续的。</li><li><strong>一棵子树内的 DFN 是连续的</strong>。这个是 DFS 决定的，很好理解。你可以发现，DFS 总是遍历完当前子树再去做其他考虑，于是很容易就发现同一棵子树内的 DFN 是连续的。</li><li><strong>树上的路径可以被拆分为不超过 $\log_2n$ 条重链</strong>。这个性质对于我们的复杂度分析是十分有用的。同时这个性质也是非常容易得到的。当我们遍历的时候，总是将子树分为<strong>重子树</strong>和<strong>其余节点</strong>，因此子树的大小总是被除以 $2$。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我们会发现，<strong>重链剖分</strong>后 DFN 的连续性是十分可用的。这就给我们使用区间数据结构的机会了。通过这个性质，我们可以在树上借助 DFN 维护一棵线段树。线段树的下标就是对应节点的 DFN 值。</p><p>于是我们就可以动态维护一些树上的区间和、区间方差、最大最小值之类的东西，同时顺手求出 LCA，复杂度还和倍增法差距不大。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们将引入一道例题以加深你对重链剖分的理解。</p><blockquote><p><strong><a href="https://www.luogu.com.cn/problem/P2146">[NOI2015] 软件包管理器</a></strong></p><p>动态维护树上的区间和。</p></blockquote><p>我们看到题目给出软件包的依赖关系，很容易的就自然联想到图论上，对吧？对吧？然后我们再观察一下，发现题目刚好描述了一棵树。</p><p>我们把样例的树建出来，是这样的：</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/graph2024482022.png" srcset="/img/loading.gif" lazyload></p><p>我们设每个点的初始权值为 $0$，也就是未安装。</p><ul><li>当安装软件包的时候，我们将该软件包到根软件包的路径上的软件包全部安装，也就是全部设置为 $1$，并统计有多少个原本不是 $1$ 的，计入答案，输出。</li><li>当卸载软件包时，我们卸载这个软件包及其所在子树上的软件包，也就是把整个子树都设为 $0$，然后统计原来有多少个 $1$，输出即可。</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>我们首先用两个 DFS 预处理出我们所需的信息：深度、子树大小、重儿子、DFN 序、重链头等信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>sz[u] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 设置子树的大小初始为 1</span><br><span class="hljs-type">int</span> maxn = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化最大子树大小</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v: g[u]) &#123;<br><span class="hljs-keyword">if</span> (v != fa) &#123; <span class="hljs-comment">// 不走回头路</span><br>f[v] = u; <span class="hljs-comment">// 记录 v 的父亲为 u</span><br>dep[v] = dep[u] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录 v 的深度为 u 的深度 + 1</span><br><span class="hljs-built_in">dfs1</span>(v, u); <span class="hljs-comment">// 遍历</span><br>sz[u] += sz[v]; <span class="hljs-comment">// 更新 u 的子树大小</span><br><span class="hljs-keyword">if</span> (sz[v] &gt; maxn) &#123; <span class="hljs-comment">// 如果发现重量更大的节点</span><br>maxn = sz[v]; <span class="hljs-comment">// 更新最大子树大小</span><br>son[u] = v; <span class="hljs-comment">// 更新重儿子</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> hd, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>head[u] = hd; <span class="hljs-comment">// 记录重链头</span><br>dfn[u] = ++dfncnt; <span class="hljs-comment">// 记录 DFN 序</span><br><span class="hljs-keyword">if</span> (!son[u]) &#123; <span class="hljs-comment">// 如果是叶子节点</span><br><span class="hljs-keyword">return</span>; <span class="hljs-comment">// 不再遍历，避免死循环</span><br>&#125;<br><span class="hljs-built_in">dfs2</span>(son[u], hd, u); <span class="hljs-comment">// 优先遍历重儿子</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v: g[u]) &#123; <span class="hljs-comment">// 遍历轻儿子</span><br><span class="hljs-keyword">if</span> (!dfn[v]) &#123; <span class="hljs-comment">// 如果没有遍历过</span><br><span class="hljs-built_in">dfs2</span>(v, v, u); <span class="hljs-comment">// 遍历轻儿子下去</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行预处理后，我们开始建树。</p><p>首先简单写一下线段树的两个基本操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> </span>&#123;<br>tree[node] = tree[node &lt;&lt; <span class="hljs-number">1</span>] + tree[node &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]; <span class="hljs-comment">// 更新子节点的数据到父节点（上传）</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (tag[node] != <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// 如果有未下传的数据</span><br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>tag[node &lt;&lt; <span class="hljs-number">1</span>] = tag[node]; <span class="hljs-comment">// 下传标记，注意是直接覆盖，不是累加</span><br>tag[node &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = tag[node]; <span class="hljs-comment">// 下传标记</span><br>tree[node &lt;&lt; <span class="hljs-number">1</span>] = (mid - l + <span class="hljs-number">1</span>) * tag[node]; <span class="hljs-comment">// 更新数据</span><br>tree[node &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = (r - mid) * tag[node]; <span class="hljs-comment">// 更新数据，注意是 [mid + 1, r]，区间大小 = (r - (mid + 1) + 1) = r - mid</span><br>tag[node] = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 清除未下传状态</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们写一个区间修改操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> <span class="hljs-type">int</span> L, <span class="hljs-type">const</span> <span class="hljs-type">int</span> R, <span class="hljs-type">const</span> <span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123; <span class="hljs-comment">// 如果遍历到的区间被待修改区间包含</span><br>tag[node] = x; <span class="hljs-comment">// 直接修改</span><br>tree[node] = (r - l + <span class="hljs-number">1</span>) * x;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">push_down</span>(node, l, r); <span class="hljs-comment">// 下传标记</span><br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (L &lt;= mid) &#123; <span class="hljs-comment">// 如果左儿子与待修改区间有交集</span><br><span class="hljs-built_in">update</span>(node &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R, x); <span class="hljs-comment">// 修改</span><br>&#125;<br><span class="hljs-keyword">if</span> (R &gt; mid) &#123; <span class="hljs-comment">// 如果右儿子与带修改区间有交集</span><br><span class="hljs-built_in">update</span>(node &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R, x); <span class="hljs-comment">// 修改</span><br>&#125;<br><span class="hljs-built_in">push_up</span>(node); <span class="hljs-comment">// 上传修改</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后类似地写一个区间查询。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> <span class="hljs-type">int</span> L, <span class="hljs-type">const</span> <span class="hljs-type">int</span> R)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123; <span class="hljs-comment">// 如果当前区间被待查区间完全包含</span><br><span class="hljs-keyword">return</span> tree[node]; <span class="hljs-comment">// 返回值</span><br>&#125;<br><span class="hljs-built_in">push_down</span>(node, l, r); <span class="hljs-comment">// 下传标记</span><br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (L &lt;= mid) &#123; <span class="hljs-comment">// 如果左儿子与待查询区间有交集</span><br>ans += <span class="hljs-built_in">query</span>(node &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R); <span class="hljs-comment">// 统计答案</span><br>&#125;<br><span class="hljs-keyword">if</span> (R &gt; mid) &#123; <span class="hljs-comment">// 如果右儿子与待查询区间有交集</span><br>ans += <span class="hljs-built_in">query</span>(node &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R); <span class="hljs-comment">// 统计答案</span><br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们来看一下如何遍历某一个节点到 $1$ 节点的路径，我们考虑类似 LCA 的方法往上跳，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (head[x] != head[y]) &#123; <span class="hljs-comment">// 如果还没到</span><br><span class="hljs-keyword">if</span> (dep[head[x]] &lt; dep[head[y]]) &#123; <span class="hljs-comment">// 优先跳较深的节点，于是判断一下</span><br><span class="hljs-built_in">swap</span>(x, y);<br>&#125;<br>ans += <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[head[x]], dfn[x]); <span class="hljs-comment">// 统计答案</span><br>x = f[head[x]]; <span class="hljs-comment">// 将较深的节点调到重链头的父节点</span><br>&#125;<br><span class="hljs-keyword">if</span> (dep[x] &gt; dep[y]) &#123; <span class="hljs-comment">// 让较浅的节点是 x，而较深的节点为 y，方便后续操作</span><br><span class="hljs-built_in">swap</span>(x, y);<br>&#125;<br>ans += <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[x], dfn[y]); <span class="hljs-comment">// 统计二者之间路径的答案</span><br></code></pre></td></tr></table></figure><p>当然在我们的题目中，$y$ 始终不变，于是乎我们可以将这段代码简化一下，就像这样（加上了修改的过程，注意先查再改）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ans = dep[x] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始时假定整条路径都没有安装</span><br><span class="hljs-keyword">while</span> (head[x] != head[<span class="hljs-number">1</span>]) &#123;<br>    ans -= <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[head[x]], dfn[x]); <span class="hljs-comment">// 减去已安装的</span><br>    <span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[head[x]], dfn[x], <span class="hljs-number">1</span>); <span class="hljs-comment">// 修改</span><br>    x = f[head[x]]; <span class="hljs-comment">// 更新</span><br>&#125;<br>ans -= <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[<span class="hljs-number">1</span>], dfn[x]); <span class="hljs-comment">// 减去已安装</span><br><span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[<span class="hljs-number">1</span>], dfn[x], <span class="hljs-number">1</span>); <span class="hljs-comment">// 更新</span><br></code></pre></td></tr></table></figure><p>此时我们的 <code>ans</code> 就是所要求的需要额外安装的节点数量啦。</p><p>然后我们来考虑如何更新子树上的东西。我们在刚刚提到了一个性质：<strong>一棵子树内的 DFN 是连续的</strong>，于是利用这个性质，我们可以很容易的得出区间。假设子树的根节点是 $u$，那么这个子树 DFN 序最小的必然就是根节点了，又由于子树内下标连续，因此我们可以计算出最后一个属于子树的下标是 $dfn_u + sz_u - 1$（根节点 DFN + 字数大小 - 1）。这样我们就可以很快的统计出答案啦！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[x], dfn[x] + sz[x] - <span class="hljs-number">1</span>) &lt;&lt; endl;<br><span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[x], dfn[x] + sz[x] - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>最后贴一下整体的代码，希望你喜欢这篇文章呀：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, q, dfncnt, tree[<span class="hljs-number">400009</span>], tag[<span class="hljs-number">400009</span>], dep[<span class="hljs-number">100009</span>], head[<span class="hljs-number">100009</span>], dfn[<span class="hljs-number">100009</span>], f[<span class="hljs-number">1000009</span>], sz[<span class="hljs-number">100009</span>], son[<span class="hljs-number">100009</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; g[<span class="hljs-number">100009</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>sz[u] = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> maxn = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v: g[u]) &#123;<br><span class="hljs-keyword">if</span> (v != fa) &#123;<br>f[v] = u;<br>dep[v] = dep[u] + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs1</span>(v, u);<br>sz[u] += sz[v];<br><span class="hljs-keyword">if</span> (sz[v] &gt; maxn) &#123;<br>maxn = sz[v];<br>son[u] = v;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> hd, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>head[u] = hd;<br>dfn[u] = ++dfncnt;<br><span class="hljs-keyword">if</span> (!son[u]) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">dfs2</span>(son[u], hd, u);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v: g[u]) &#123;<br><span class="hljs-keyword">if</span> (!dfn[v]) &#123;<br><span class="hljs-built_in">dfs2</span>(v, v, u);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_up</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> </span>&#123;<br>tree[node] = tree[node &lt;&lt; <span class="hljs-number">1</span>] + tree[node &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (tag[node] != <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>tag[node &lt;&lt; <span class="hljs-number">1</span>] = tag[node];<br>tag[node &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = tag[node];<br>tree[node &lt;&lt; <span class="hljs-number">1</span>] = (mid - l + <span class="hljs-number">1</span>) * tag[node];<br>tree[node &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = (r - mid) * tag[node];<br>tag[node] = <span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> <span class="hljs-type">int</span> L, <span class="hljs-type">const</span> <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;<br>tag[node] = x;<br>tree[node] = (r - l + <span class="hljs-number">1</span>) * x;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">push_down</span>(node, l, r);<br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (L &lt;= mid) &#123;<br><span class="hljs-built_in">update</span>(node &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R, x);<br>&#125;<br><span class="hljs-keyword">if</span> (R &gt; mid) &#123;<br><span class="hljs-built_in">update</span>(node &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R, x);<br>&#125;<br><span class="hljs-built_in">push_up</span>(node);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> <span class="hljs-type">int</span> L, <span class="hljs-type">const</span> <span class="hljs-type">int</span> R)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;<br><span class="hljs-keyword">return</span> tree[node];<br>&#125;<br><span class="hljs-built_in">push_down</span>(node, l, r);<br><span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (L &lt;= mid) &#123;<br>ans += <span class="hljs-built_in">query</span>(node &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R);<br>&#125;<br><span class="hljs-keyword">if</span> (R &gt; mid) &#123;<br>ans += <span class="hljs-built_in">query</span>(node &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, x; i &lt;= n; i++) &#123;<br>cin &gt;&gt; x;<br>x += <span class="hljs-number">1</span>;<br>g[x].<span class="hljs-built_in">push_back</span>(i);<br>g[i].<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><span class="hljs-built_in">memset</span>(tag, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> tag);<br><span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>cin &gt;&gt; q;<br>string op;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= q; i++) &#123;<br>cin &gt;&gt; op &gt;&gt; x;<br>x += <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;install&quot;</span>) &#123;<br><span class="hljs-type">int</span> ans = dep[x] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (head[x] != head[<span class="hljs-number">1</span>]) &#123;<br>ans -= <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[head[x]], dfn[x]);<br><span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[head[x]], dfn[x], <span class="hljs-number">1</span>);<br>x = f[head[x]];<br>&#125;<br>ans -= <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[<span class="hljs-number">1</span>], dfn[x]);<br><span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[<span class="hljs-number">1</span>], dfn[x], <span class="hljs-number">1</span>);<br>cout &lt;&lt; ans &lt;&lt; endl;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;uninstall&quot;</span>) &#123;<br>cout &lt;&lt; <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[x], dfn[x] + sz[x] - <span class="hljs-number">1</span>) &lt;&lt; endl;<br><span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[x], dfn[x] + sz[x] - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法详解</tag>
      
      <tag>重链剖分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法详解 - 自适应辛普森法</title>
    <link href="/posts/44079.html"/>
    <url>/posts/44079.html</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>我们可以看道一个奇怪的式子：</p><p>$$<br>\int^R_L f(x), \textrm{d}x<br>$$</p><p>究竟是什么意思呢？其实就是求函数 $f(x)$ 在 $L$ 到 $R$ 之间的定值积分。在讲求值之前，要先讲一下映射、函数和积分。</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>再讲函数之前，先要讲一讲映射。首先我们考虑有两个非空集合 $X$ 和 $Y$，如果存在一种法则 $f$，使得  $X$ 中的每一个元素 $x$，按法则 $f$，在集合 $Y$ 中有唯一确定的元素 $y$  与之对应。那么此时我们称 $f$ 为 $X$ 到 $Y$ 的映射，形式化的记作：</p><p>$$<br>f:X\to Y<br>$$</p><p>在这之中，我们把  $y$ 称为元素 $x$ 在映射 $f$ 下的像，记作：</p><p>$$<br>y&#x3D;f(x)<br>$$</p><p>而元素  $x$ 称为元素 $y$ 在映射 $f$ 中的一个原像。</p><p>映射有两个必须知道的基本概念，<strong>值域</strong>和<strong>定义域</strong>。其中：</p><ul><li><strong>值域</strong>：即映射的所有像组成的集合。</li><li><strong>定义域</strong>：即映射的所有原像组成的集合。</li></ul><p>对于辛普森法，关于映射，这些就已经足够了，想了解更多，可以去翻看一下《高等数学第7版-上册》。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>或许接触过函数的人看到映射中那些名词会感觉有一些熟悉，这是应该的，因为从高等数学的角度上看，函数就是实数集（或它的子集）到实数集的一个映射。形式化的说：我们设数集 $D\subset\mathbf{R}$，则称映射 $f:D\to \mathbf{R}$ 为定义在 $D$ 上的函数，简记为：</p><p>$$<br>y&#x3D;f(x),,x\in D<br>$$</p><p>其中 $x$ 称为<strong>自变量</strong>，$y$ 为<strong>因变量</strong>，$D$ 称为函数的<strong>定义域</strong>，记作 $D_f$ 即 $D_f&#x3D;D$。</p><p>常见的函数有一次函数、二次函数、三角函数、对数函数等等，它们的函数图像如图。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0.png" srcset="/img/loading.gif" lazyload alt="图1-左：一次函数"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0.png" srcset="/img/loading.gif" lazyload alt="图1-右：二次函数"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0.png" srcset="/img/loading.gif" lazyload alt="图2-左：对数函数"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0.png" srcset="/img/loading.gif" lazyload alt="图2-右：三角函数"></p><p>你还需要会知道一些函数的特性：</p><ul><li><strong>函数的有界性</strong>：由于函数的定义域是一定的，这可能会导致函数的值域并不是整个实数域。</li><li><strong>函数的周期性</strong>：如果存在一个正数 $l$，使得 $f(x)&#x3D;f(x + l)$ 恒成立，那么我们称这个函数为<strong>周期函数</strong>，且我们称 $l$ 是函数 $f$ 的周期，一般地，我们称周期为函数的。正弦函数（$\sin$）就是常见的周期函数。</li></ul><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><p>积分问题通常被分为两类：<strong>不定积分</strong>和<strong>定积分</strong>。对于辛普森法，你只需要理解定积分。一般定积分以下属方式表达：</p><p>$$<br>\int_a^b f(x),\textrm{d}x<br>$$</p><p>其中 $b$ 为<strong>积分上限</strong>、$a$ 为 <strong>积分下限</strong>，二者组成了一个<strong>积分区间</strong> $[a,,b]$、$f(x)$ 被称为<strong>被积函数</strong>，而 $f(x),\textrm{d}x$ 称为<strong>被积表达式</strong>。</p><p>当然，聪明的你可定发现了，有些函数是不可以积分的，简称不可积。那么那些函数是可积的呢？《高等数学》告诉了我们答案：</p><ul><li>设 $f(x)$ 在区间 $[a,,b]$ 上连续，则 $f(x)$ 在 $[a,,b]$ 上可积。</li><li>设 $f(x)$ 在区间 $[a,,b]$ 上有界，且只有有限个间断点，则 $f(x)$ 在 $[a,,b]$ 上可积。</li></ul><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E5%AE%9A%E7%A7%AF%E5%88%86.png" srcset="/img/loading.gif" lazyload alt="图3：定积分例1 - 普通函数"></p><p>好的，那么积分是什么呢？实际上对于定积分，你可以认为他是在一段区间内函数值的和，但是这个求和是连续的，看到图3。图 3 中棕色的部分面积就是图中黑色函数在积分区间 $[-2,,20]$ 的积分值。这就是积分的几何意义。</p><p>但是你可能会发现一个问题，就是如果函数在积分区间内有负值，那么怎么办呢？我么可以通过一个例子来理解这个问题。我们可以构造一个周期函数，然后尝试求他的积分值。图4就是一个正弦函数的图像。图像中棕色部分就是函数值为正的部分，区间为 $[0,,\pi]$，蓝色部分是函数值为负的部分，区间 $[\pi,,2\pi]$ 我们可以大胆猜测一下，函数 $\sin (x)$ 在区间 $[0, 2\pi]$ 的积分值是棕色部分减去蓝色部分，也就是 $0$。拿出计算器计算一下就会发现，结论正确。定积分值实际上就是函数位于$x$ 轴上方部分的面积减去 $x$ 轴下方的面积！</p><p>到这里，你已经基本掌握了辛普森法所需的知识，让我们<del>出发吧，旅行者！</del></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0.png" srcset="/img/loading.gif" lazyload alt="图4：定积分例2 - 周期函数"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="积分值计算"><a href="#积分值计算" class="headerlink" title="积分值计算"></a>积分值计算</h3><p>首先解决积分求值的问题，我们从最简单的矩形逼近开始。我们尝试把函数下的图形用矩形逼近，或者说常使用一些矩形把函数下的部分填满，如图5（左）。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E7%9F%A9%E5%BD%A2%E9%80%BC%E8%BF%91.png" srcset="/img/loading.gif" lazyload alt="图5-左：矩形逼近"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E6%A2%AF%E5%BD%A2%E9%80%BC%E8%BF%91.png" srcset="/img/loading.gif" lazyload alt="图5-右：梯形逼近"></p><p>很容易发现即使我们把面积分成这么多块，精度还是十分的低。我们考虑把矩形换成梯形，就像图 5（右）。这样看起来精度似乎提升了，但是效率似乎很低，我们亟需一种高效且精度高的定积分求值方式。</p><p>如果你翻看一篇内容杂糅的<a href="https://dl.acm.org/doi/epdf/10.1145/367766.368179">论文</a>，你就会找到一种神奇的算法：辛普森法。这种算法使用一些二次函数来逼近我们要积的函数。</p><p>原论文中对算法数学推倒的过程非常少，因此下面给出一种 Simpson 公式的非原著推导过程，我们设 $g(x) &#x3D; ax^2+bx+c$ 为拟合后的函数，则推导过程如下：</p><p>$$<br>\begin{align*}<br>\int_L^R f(x),\textrm{d}x &amp;\approx \frac{1}{3}a\left(R^3-L^3\right)+\frac{1}{2}b\left(R^2-L^2\right)+c\left(R-L\right)\<br>        &amp;&#x3D; \frac{R-L}{6}\left(2a\left(L^2+LR+R^2\right)+3b\left(L+R\right)+6c\right)\<br>        &amp;&#x3D; \frac{R-L}{6}\left( aL^2+bL+c+aR^2+bR+c+4a\left(\frac{L+R}{2}\right)^2+4b\left(\frac{L+R}{2}\right) + 4c\right)\<br>        &amp;&#x3D; \frac{R-L}{6}\left(f(L)+4f\left(\frac{L+R}{2}\right)+f(R)\right)<br>\end{align*}<br>$$</p><p>这就是大名鼎鼎的辛普森公式：</p><p>$$<br>\int_L^R f(x),\textrm{d}x \approx \frac{R-L}{6}\left(f(L)+4f\left(\frac{L+R}{2}\right)+f(R)\right)<br>$$</p><p>获得了辛普森公式，正当你计算时，你就会发现精度根本不足！因为一个二次函数很显然是不足以逼近一个复杂函数的。</p><p>为了解决精度问题，我们可以考虑将函数分段，我们可以将积分区间砍半，分为两次计算。每次都将区间砍半，直到精度达标。在估算精度的过程中，还存在着一个技巧。这个技巧在《数值分析》一书中有提到。</p><p>这个技巧来源于推广中值定理[^2]。根据这个定理，我们可以发现当辛普森法算出来的积分值误差 $\leq 15eps$ （$eps$ 为给定的容差值（TOL）），那么这个值加上误差的 $\frac{1}{15}$ 就是我们需要得到的足够精度的值了。具体证明参考原书 P240。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>下面给出<a href="https://www.luogu.com.cn/problem/P4525">【模板】自适应辛普森法 1</a>的代码，其实就是一直二分区间直到精度达标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">long</span> <span class="hljs-type">double</span> a, b, c, d, l, r;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((c * x) + d) / (a * x + b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> a, <span class="hljs-type">long</span> <span class="hljs-type">double</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (b - a) * (<span class="hljs-built_in">f</span>(a) + <span class="hljs-built_in">f</span>(b) + <span class="hljs-number">4.0</span> * <span class="hljs-built_in">f</span>((a + b) / <span class="hljs-number">2.0</span>)) / <span class="hljs-number">6</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-title">asr</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> l, <span class="hljs-type">long</span> <span class="hljs-type">double</span> r, <span class="hljs-type">long</span> <span class="hljs-type">double</span> ans)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">double</span> lx = <span class="hljs-built_in">g</span>(l, mid), rx = <span class="hljs-built_in">g</span>(mid, r), x = lx + rx;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(ans - x) &lt; <span class="hljs-number">0.00000001</span>) &#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">asr</span>(l, mid, lx) + <span class="hljs-built_in">asr</span>(mid, r, rx);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; l &gt;&gt; r;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6llf&quot;</span>, <span class="hljs-built_in">asr</span>(l, r, <span class="hljs-built_in">g</span>(l, r)));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法详解</tag>
      
      <tag>自适应辛普森法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OiClass P2688 简单计算题解</title>
    <link href="/posts/41221.html"/>
    <url>/posts/41221.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们简单导一下柿子：</p><p>$$<br>\begin{align*}<br>\sum_{i&#x3D;0}^{p} \left\lfloor\frac{iq}{p}\right\rfloor &amp;&#x3D; \left\lfloor\frac{0q}{p}\right\rfloor + \left\lfloor\frac{1q}{p}\right\rfloor + \cdots + \left\lfloor\frac{pq}{p}\right\rfloor \newline<br>&amp;&#x3D; \frac{0q}{p} - \frac{0q,%,p}{p} + \frac{1q}{p} - \frac{1q,%,p}{p} + \cdots + \frac{pq}{p} - \frac{pq,%,p}{p} \newline<br>&amp;&#x3D; \frac{\frac{(p + 1)(0 + pq)}{2}}{p} -\frac{0q,%,p + 1q,%,p + \cdots+ pq,%,p}{p}\newline<br>&amp;&#x3D; \frac{(p + 1)q}{2} - \frac{0q,%,p + 1q,%,p + \cdots+ pq,%,p}{p}\newline<br>\end{align*}<br>$$</p><p>然后发现导不出来了，尝试找规律。设 $p &#x3D; 6$，$q&#x3D;4$。则：</p><p>$$<br>\begin{align*}<br>原式&amp;&#x3D;\frac{(6+1)\times 4}{2} - \frac{0,%,6 + 4,%,6+8,%,6+12,%,6+16,%,6+20,%,6+24,%,6}{6}\newline<br>&amp;&#x3D;14-\frac{0+4+2+0+4+2+0}{6}<br>\end{align*}<br>$$</p><p>似乎存在一个循环节，长度为 $2$，猜一下循环节的长度就是 $\frac{p}{(p,,q)} &#x3D; 3$【$(a,,b)$ 为 $a$、$b$ 的最大公因数】。然后我们把序列倒着读，就像这样：</p><p>$$<br>0,,2,,4,,0,,2,,4,,0<br>$$</p><p>我们会发现，舍弃最后一个 $0$ 之后，数列就是 $(p,,q)$ 个长度为 $\frac{p}{(p,,q)}$，公差为 $(p,,q)$ 的等差数列。</p><p>于是我们可以如此化简：</p><p>$$<br>设,, d &#x3D; (p,,q),,,l&#x3D;\frac{p}{d},, 则:\newline<br>\begin{align*}<br>原式&amp;&#x3D; \frac{(p +1)q}{2} - \frac{d \left(\frac{l(0 + d\left(l - 1\right))}{2}\right)}{p}<br>\end{align*}<br>$$</p><p>然后简单实现一下即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, p, q;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        cin &gt;&gt; p &gt;&gt; q;<br>        <span class="hljs-type">int</span> d = __gcd(p, q);<br>        <span class="hljs-type">int</span> l = p / __gcd(p, q);<br>        <span class="hljs-type">int</span> a = (d * (l - <span class="hljs-number">1LL</span>)) * l / <span class="hljs-number">2LL</span>;<br>        <span class="hljs-type">int</span> ans = (p + <span class="hljs-number">1LL</span>) * q / <span class="hljs-number">2LL</span> - d * a / p;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TYOI 省选集训 and 2024 GD 省选游记</title>
    <link href="/posts/38827.html"/>
    <url>/posts/38827.html</url>
    
    <content type="html"><![CDATA[<h2 id="集训"><a href="#集训" class="headerlink" title="集训"></a>集训</h2><h3 id="Day-INF"><a href="#Day-INF" class="headerlink" title="Day -INF"></a>Day -INF</h3><p>知道可以来集训，感觉特别开心，因为可以合法逃学两周！</p><h3 id="Day-3-sim-Day-0"><a href="#Day-3-sim-Day-0" class="headerlink" title="Day -3 $\sim$ Day 0"></a>Day -3 $\sim$ Day 0</h3><p>大年初五就从潮州回到广州，收拾了一下东西，年初七大家就到了学校。</p><p>很好，又和高中生一起住，不过这次我们来得很早，所以高二还没有开学。一开始宿舍里面只有我、includeCPP、jr_linys 三个人。所以 includeCPP 非常放纵。</p><h3 id="Day-1-sim-Day-17"><a href="#Day-1-sim-Day-17" class="headerlink" title="Day 1 $\sim$ Day 17"></a>Day 1 $\sim$ Day 17</h3><p>每天都是比赛，每天都爆零。不过 Day 17 有奶茶，还有一帮 D 班 xxs 家长过来参观。当时我们在打球，真的好尴尬。</p><p>虽然每天都爆零，但是还是改出来了几题，<img src="https://cdn.jsdmirror.com/gh/lixuannan/img/07610D0B.png" srcset="/img/loading.gif" lazyload alt="07610D0B">。</p><h2 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h2><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>中午出发，下午 $2$ 点左右就到了。开始试机，简单打了一个 Dijkstra，运行正常。然后又写了一个经典的 dlt 代码，一坤秒电脑就黑屏了，闪了一下正常了。感觉松山湖电脑性能很好，准备在虚拟机里面打题。但是 VSCode 不装 CPP 插件真的是只有 CCF 干得出来。没办法，打算用 vim。有一说一， vim 的手感是真的很好，高速输入的时候几乎感觉不到一点延迟。</p><p>试机完出来才知道原来 NOI Linux 里面的 Sublime Text 是有自动补全的，于是决定赛时用 Sublime。</p><p>试机之后，回到熟悉的 klyd 酒店，一起看<strong>超脑少年团第二季</strong>，ljy 没加大 Y 是真的很搞笑~</p><p>晚上请 sly 帮忙点了外卖，感觉还行。</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><h4 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h4><p>一眼二分，考虑如何 <code>check</code>。很容易发现，原式可以这样化简：<br>$$<br>\begin{align}<br>\sum_{i&#x3D;0}^{m-1}\left(x_{i}^{\prime}+x_{i ! \mod ! n}\right) &amp;&#x3D; x \newline<br>\sum_{i&#x3D;0}^{m-1}x_{i}^{\prime}+ \sum_{i&#x3D;0}^{m-1} x_{i ! \mod ! n}&amp;&#x3D; x \newline<br>\sum_{i&#x3D;0}^{m-1}x_{i}^{\prime} &amp;&#x3D; x - \sum_{i&#x3D;0}^{m-1}x_{i ! \mod ! n}<br>\end{align}<br>$$<br>又因为 $x_{i}^{\prime}$ 是实数，于是：<br>$$<br>x_{i}^{\prime}&#x3D; \frac{\left|x - \displaystyle\sum_{i&#x3D;0}^{m-1}x_{i ! \mod ! n}\right|}{m}<br>$$<br>因此我们可以用此判断是否合法，对于 $y$，也可以如法炮制。</p><p>先是写了一个 $\mathcal{O}(m)$ 的 <code>check()</code>，测样例需要很长时间。想了一会突然发现可以预处理整个数列的和，然后用 $\mathcal {O}(n, %, m)$ 的时间就可以统计出答案。但是发现即使这样可无法通过样例。因为 C++ 的 <code>double</code> 精度不够，改成 <code>long double</code> 就可以通过小样例。但是如果你测试大样例，仍然无法通过。</p><p>我们考虑将实数转化为整数。我们可以讲不等式左右两边同乘 $m$，如下：<br>$$<br>\begin{align}<br>\frac{\left|x - \displaystyle\sum_{i&#x3D;0}^{m-1}x_{i ! \mod ! n}\right|}{m} &amp;\leq k \newline<br>{\left|x - \displaystyle\sum_{i&#x3D;0}^{m-1}x_{i ! \mod ! n}\right|} &amp;\leq km<br>\end{align}<br>$$<br>然后我们用 <code>__int128</code> 存一下就可以通过样例。然后你就可以通过样例。但是如果你测试大样例，仍然无法通过。赛时的我以为是没有特判 $k &#x3D; 0$ 的情况。特判之后仍然调不出来，摆了。</p><hr><p>赛后才知道原来是解一下那个不等式，wssb。</p><h4 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h4><p>不会，随便打了暴力。</p><h4 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h4><p>SB 出题人，题目看不懂，摆了。</p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><h4 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a>T1</h4><p>不会，打了一个暴力，拿下 $25 \rm pts$。</p><h4 id="T2-T3"><a href="#T2-T3" class="headerlink" title="T2 &amp; T3"></a>T2 &amp; T3</h4><p>不会，摆了 (o_ _)ﾉ。</p><h2 id="赛后"><a href="#赛后" class="headerlink" title="赛后"></a>赛后</h2><p>mod 剑神 rk. 6，飞神 rk. 20。</p>]]></content>
    
    
    
    <tags>
      
      <tag>游记</tag>
      
      <tag>TYOI</tag>
      
      <tag>省选</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1244C 题解</title>
    <link href="/posts/36804.html"/>
    <url>/posts/36804.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们看到题目，给定四个数 $n$、$p$、$w$、$d$，求解三元一次不定方程组：<br>$$<br>\left{<br>\begin{array}{l}<br>x\cdot w+y\cdot d&#x3D;p\<br>x+y+z&#x3D;n<br>\end{array}<br>\right.<br>$$<br>观察一下你就会发现 $z$ 的值是你可以随便指定的，因为他只对 $n$ 产生影响，而不对方程一产生任何贡献。于是我们忽略 $z$ 的取值。</p><p>由此我们就可以把方程组化简为一条二元一次不定方程：<br>$$<br>x\cdot w+y\cdot d&#x3D;p<br>$$<br>由于 $w&gt;d$，可以发现使 $y$ 最小就可以得到一组可能存在的解。因此考虑枚举 $y$。分析数据范围可以发现 $\frac{p}{n}$ 的范围刚好就是 $w$ 和 $d$ 的最大范围，因此我们可以证明，如果原方程组有非负正整数解，那么解中的 $y$ 必定在区间 $[0,,w)$ 中。</p><p>故枚举 $y \in [0, ,w)$ 然后判断解是否合法即可，若找不到，则原方程必定无解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, p, w, d;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; p &gt;&gt; w &gt;&gt; d;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; w; y++) &#123;<br>        <span class="hljs-keyword">if</span> ((p - y * d) &gt;= <span class="hljs-number">0</span> &amp;&amp; (p - y * d) % w == <span class="hljs-number">0</span> &amp;&amp; n - ((p - y * d) / w + y) &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> x = (p - y * d) / w;<br>            cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; n - (x + y);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AT_abc255_e 题解</title>
    <link href="/posts/26210.html"/>
    <url>/posts/26210.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h3><p>首先我们考虑一定可以有一个点是幸运数，于是我们可以考虑遍历每一个 $S_i$，钦定 $a_i$ 是一个幸运数，然后我们就可以反推出 $a_1$ 的值。然后我们统计 $a_1$ 重复被计算出的次数。因为只要有一个 $a_i$ 被确定了，整个序列就确定了。也就是说，$a_1$ 的重复次数就是我们要求的最多的幸运数个数，因为他们都是同一个序列。如果我们这样做，时间复杂度是 $\mathcal{O}(n^2m)$，很显然无法通过本题。</p><h3 id="优化做法"><a href="#优化做法" class="headerlink" title="优化做法"></a>优化做法</h3><p>我们考虑如何优化这个算法。我们回顾一下计算 $a_1$ 值的过程。我们假设已经确定了 $a_x$ 的值：</p><ul><li>如果 $x$ 是<strong>奇数</strong>，那么很显然<br>  $$<br>  \begin{align}<br>  a_x &amp;&#x3D; S_{x - 1}-S_{x-2}+S_{x-3}-\cdots+S_{1}-a_1\<br>  a_1 &amp;&#x3D; (-1)^{x-1}\left(a_x - \left(S_{x - 1}-S_{x-2}+S_{x-3}-\cdots+S_{1}\right)\right)<br>  \end{align}<br>  $$</li><li>如果 $x$ 是<strong>偶数</strong>，那么仍然很显然的是式子是<br>  $$<br>  \begin{align}<br>  a_x &amp;&#x3D; S_{x-1}-S_{x-2}+S_{x-3}-\cdots-S_1+a_1\<br>  a_1 &amp;&#x3D; (-1)^{x-1}\left(a_x - \left(S_{x-1}-S_{x-2}+S_{x-3}-\cdots-S_1\right)\right)<br>  \end{align}<br>  $$</li></ul><p>很显然，由于 $S_i$ 不会改变，$\pm a_1$ 之前的一长串式子也不会改变，因此我们可以考虑预处理 $\pm a_1$ 前面的式子，然后 $\mathcal{O}(1)$ 求值。</p><p>让我们设 $f_{i,,0}$ 为此时 $S_i$ 系数为负的情况，$f_{i,,1}$ 为此时 $S_{i}$ 系数为正的情况。聪明的你可能发现了，$f_{i,,0}$ 在最终计算时不需要的，但是在预处理的过程中，这是必要的。很容易推出状态转移方程<br>$$<br>\begin{array}{c}<br>f_{i,,0}&#x3D;f_{i-1,,1}-S_i\<br>f_{i,,1}&#x3D;f_{i-1,,0}+S_i<br>\end{array}<br>$$<br>则对于选定的 $a_x$，其对应的 $a_1&#x3D;(-1)^{x-1}(a_x - f_{x-1,,0})$。</p><p>我们可以 $\mathcal{O}(n)$ 预处理，然后采用朴素做法的思路统计答案，总复杂度为 $\mathcal{O}(nm)$，可以通过。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m, s[<span class="hljs-number">100009</span>], x[<span class="hljs-number">20</span>], f[<span class="hljs-number">100009</span>][<span class="hljs-number">2</span>];<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; s[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        cin &gt;&gt; x[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        f[i][<span class="hljs-number">0</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + s[i];<br>        f[i][<span class="hljs-number">1</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - s[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            mp[(j &amp; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>) * (x[i] - f[j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>])] += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[i, j]: mp) &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, j);<br>    &#125;<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>AtCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OiClass 2024 CSP-J 公益赛 #4 题解</title>
    <link href="/posts/24397.html"/>
    <url>/posts/24397.html</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这场比赛出题人认为是 $\approx$ CSP-J + 的难度，预估的平均分在 $200$ 分左右。比赛的命题思路简单来说就是第一题水题但是考虑在题面里面写很多抽象的东西混淆视听；第二题有些思路的结论题，如果猜出了结论复杂度应该还是非常优秀的；第三题是本场比赛最难的题，算法本身并不难，但是这个思路上有一个优化很难想，这就给很多选手做题带来了很大的困扰，可能无人 AC；第四题是原题加强的版本，卡掉了原题的一种水法，是一道比较好想的 DP，代码上有两个坑，希望有人 AC；第五题纯粹出于兴趣，老天保佑有人 AC。</p><p>总而言之，这场比赛都是<strong>原题&#x2F;原题的加强题目</strong>，具体对应关系如下：</p><ol><li><p>好吧，T1 并不是原题。</p></li><li><p>Codeforces Round 913 (Div. 3) C（CF1907C）改输入格式。</p></li><li><p>COCI 2006 $\sim$ 2007 #6 T4 KAMEN（洛谷 P6370）改输入格式。</p></li><li><p>OiClass PUJI 域 C 班赛后康复训练赛 T3（OiClass PUJI 域<br>1348）改输入格式。</p></li></ol><p>当然，所有题的题目背景和题目的描述都经过了巨大的改动，同时数据也都是有出题人亲手制造的。有需要者可以向出题人索要数据。</p><h2 id="突破突破突破-upgrade"><a href="#突破突破突破-upgrade" class="headerlink" title="突破突破突破 (upgrade)"></a>突破突破突破 (upgrade)</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不难发现，全部使用经验值最少的绿色经验书是最优秀的。因此我们直接计算 $\lfloor \frac{x}{10} \rfloor$ 即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> x;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;upgrade.in&quot;</span>, <span class="hljs-string">&quot;rt&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;upgrade.out&quot;</span>, <span class="hljs-string">&quot;wt&quot;</span>, stdout);<br>    cin &gt;&gt; x;<br>    cout &lt;&lt; x / <span class="hljs-number">10</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="压缩名字-compress"><a href="#压缩名字-compress" class="headerlink" title="压缩名字 (compress)"></a>压缩名字 (compress)</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先，这道题一眼看上去应该是可以用某种策略搞定的，但是由于策略太难想，并没有任何人采用这种方式（不过出题人猜测是因为这种方法时间复杂度不够优秀）。于是我们便看可以考虑如何统计出删除后的数字。我们从删除的策略入手，题目说<strong>删除相邻的两个不同的字符</strong>，实际上如果我们利用这个策略一直删，无论相隔多远，这要某一个字符能被删除，广义上来讲，就可以和任何另一个可删除的字符所相互配对。那么也就是说，我们把题目中给出的条件变为了<strong>删除任意两个不同的字符</strong>。然后我们考虑用这种策略删除后的情况。</p><ul><li><p>如果一个字母的出现次数 $&gt; \frac{1}{2} |s_i|$ （大于字符串长度的二分之一），那么此时这个字符串是无法被消除完的，即使所有的字符都用于消除这个特别多的字符，也会剩下一些。这个一些很容易计算，如果我们设字符串长度为 $n$，最多的字符数量为 $m$，那么就是 $n - 2(n - m) &#x3D; 2m - n$。</p></li><li><p>其余的情况，如果字符串长度是奇数，那么答案为 $1$，否则为 $0$。</p></li></ul><p>简单实现即可，时间复杂度为 $\mathcal{O}(n\cdot|s_i|) \leq 10^8$ 可以通过。但是由于题目的输入量非常大，简单的 <code>cin</code> &#x2F; <code>cout</code> 是无法在如此的时间内完成输入的。同时又因为题目十分恶心的没有给出字符串的长度，因此我们必须使用 <code>cin</code> &#x2F; <code>cout</code> 或者快读。那么 <code>cin</code> &#x2F; <code>cout</code> 还能优化了吗？</p><h4 id="cin-cout-优化"><a href="#cin-cout-优化" class="headerlink" title="cin &#x2F; cout 优化"></a><code>cin</code> &#x2F; <code>cout</code> 优化</h4><p>答案显然是可以的，我们首先可以关闭流输入输出（<code>cin</code> &#x2F; <code>cout</code>，下同）与标准输入输出（<code>printf</code>&#x2F;<code>scanf</code>，下同）的连接，使用代码 <code>ios::sync_with_stdio(false)</code>（无需额外头文件），然后我们解除流输入输出所绑定的函数，两行代码：<code>cin.tie(nullptr)</code> 和 <code>cout.tie(nullptr)</code>。这样我们的流输入输出便跑的比较快了。不过需要注意的是，关闭输入流同步后，不可以混用 <code>cin</code> &#x2F; <code>scanf</code> 或 <code>cout</code> &#x2F; <code>printf</code>，但是 <code>cin</code> &#x2F; <code>printf</code> 和 <code>scanf</code> &#x2F; <code>cout</code> 的组合仍然是可以使用的。</p><h4 id="快读快写"><a href="#快读快写" class="headerlink" title="快读快写"></a>快读快写</h4><p>快读快写是一种更进阶的方式，可以将输入输出的效率推到极致，但是编写不当导致 RE 的风险很高，慎用。这种方法效率高的原因主要是因为没有繁杂的处理，运用自定义的函数来达到极高的效率，下面给出一个可用的快读快写模板（调用 <code>read(...)</code> &#x2F; <code>write(...)</code> 使用）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp;x)</span> </span>&#123; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;x); &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, x); &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> &amp;x)</span> </span>&#123; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%Lf&quot;</span>, &amp;x); &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x)</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%Lf&quot;</span>, x); &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> type&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(type &amp;x)</span> </span>&#123;<br>    x = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch))flag ^= ch == <span class="hljs-string">&#x27;-&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(ch))x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + (ch ^ <span class="hljs-number">48</span>), ch = <span class="hljs-built_in">getchar</span>();<br>    flag ? x = -x : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> type&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(type x)</span> </span>&#123;<br>    x &lt; <span class="hljs-number">0</span> ? x = -x, <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>) : <span class="hljs-number">0</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">short</span> Stack[<span class="hljs-number">50</span>], <span class="hljs-built_in">top</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">do</span> Stack[++top] = x % <span class="hljs-number">10</span>, x /= <span class="hljs-number">10</span>; <span class="hljs-keyword">while</span> (x);<br>    <span class="hljs-keyword">while</span> (top)<span class="hljs-built_in">putchar</span>(Stack[top--] | <span class="hljs-number">48</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">char</span> &amp;ch)</span> </span>&#123;<br>    <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (c == <span class="hljs-string">&#x27; &#x27;</span> || c == <span class="hljs-string">&#x27;\n&#x27;</span>)c = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> ch = c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">char</span> *x)</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> ch;<br>    <span class="hljs-built_in">read</span>(ch);<br>    <span class="hljs-keyword">do</span> *(x++) = ch; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isspace</span>(ch = <span class="hljs-built_in">getchar</span>()) &amp;&amp; ~ch);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> type&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(type *x)</span> </span>&#123; <span class="hljs-keyword">while</span> (*x)<span class="hljs-built_in">putchar</span>(*(x++)); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(std::string &amp;x)</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> ch;<br>    <span class="hljs-built_in">read</span>(ch), x.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">do</span> x += ch; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isspace</span>(ch = <span class="hljs-built_in">getchar</span>()) &amp;&amp; ~ch);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;x)</span> </span>&#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, len = x.<span class="hljs-built_in">length</span>(); i &lt; len; ++i)<span class="hljs-built_in">putchar</span>(x[i]); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;ch)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">putchar</span>(ch); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> type, <span class="hljs-keyword">typename</span> ...T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(type &amp;x, T &amp;...y)</span> </span>&#123; <span class="hljs-built_in">read</span>(x), <span class="hljs-built_in">read</span>(y...); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> type, <span class="hljs-keyword">typename</span> ...T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(type x, T...y)</span> </span>&#123; <span class="hljs-built_in">write</span>(x), <span class="hljs-built_in">write</span>(y...); &#125;<br></code></pre></td></tr></table></figure><p>通过上面对输入输出的优化，我们就可以正常的 AC 了。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="简单优化版本"><a href="#简单优化版本" class="headerlink" title="简单优化版本"></a>简单优化版本</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, a[<span class="hljs-number">30</span>];<br>string s;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;compress.in&quot;</span>, <span class="hljs-string">&quot;rt&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;compress.out&quot;</span>, <span class="hljs-string">&quot;wt&quot;</span>, stdout);<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; s;<br>        <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> j: s) &#123;<br>            a[j - <span class="hljs-string">&#x27;a&#x27;</span>] += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++) &#123;<br>            x = <span class="hljs-built_in">max</span>(x, a[j]);<br>        &#125;<br>        cout &lt;&lt; (x &gt; (s.<span class="hljs-built_in">size</span>() &gt;&gt; <span class="hljs-number">1</span>) ? (x &lt;&lt; <span class="hljs-number">1</span>) - s.<span class="hljs-built_in">size</span>() : s.<span class="hljs-built_in">size</span>() &amp; <span class="hljs-number">1</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="快读快写版本"><a href="#快读快写版本" class="headerlink" title="快读快写版本"></a>快读快写版本</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp;x)</span> </span>&#123; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;x); &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, x); &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> &amp;x)</span> </span>&#123; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%Lf&quot;</span>, &amp;x); &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x)</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%Lf&quot;</span>, x); &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> type&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(type &amp;x)</span> </span>&#123;<br>    x = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(ch))flag ^= ch == <span class="hljs-string">&#x27;-&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(ch))x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + (ch ^ <span class="hljs-number">48</span>), ch = <span class="hljs-built_in">getchar</span>();<br>    flag ? x = -x : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> type&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(type x)</span> </span>&#123;<br>    x &lt; <span class="hljs-number">0</span> ? x = -x, <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>) : <span class="hljs-number">0</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">short</span> Stack[<span class="hljs-number">50</span>], <span class="hljs-built_in">top</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">do</span> Stack[++top] = x % <span class="hljs-number">10</span>, x /= <span class="hljs-number">10</span>; <span class="hljs-keyword">while</span> (x);<br>    <span class="hljs-keyword">while</span> (top)<span class="hljs-built_in">putchar</span>(Stack[top--] | <span class="hljs-number">48</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">char</span> &amp;ch)</span> </span>&#123;<br>    <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span> (c == <span class="hljs-string">&#x27; &#x27;</span> || c == <span class="hljs-string">&#x27;\n&#x27;</span>)c = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> ch = c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">char</span> *x)</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> ch;<br>    <span class="hljs-built_in">read</span>(ch);<br>    <span class="hljs-keyword">do</span> *(x++) = ch; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isspace</span>(ch = <span class="hljs-built_in">getchar</span>()) &amp;&amp; ~ch);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> type&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(type *x)</span> </span>&#123; <span class="hljs-keyword">while</span> (*x)<span class="hljs-built_in">putchar</span>(*(x++)); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(std::string &amp;x)</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">char</span> ch;<br>    <span class="hljs-built_in">read</span>(ch), x.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">do</span> x += ch; <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isspace</span>(ch = <span class="hljs-built_in">getchar</span>()) &amp;&amp; ~ch);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;x)</span> </span>&#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, len = x.<span class="hljs-built_in">length</span>(); i &lt; len; ++i)<span class="hljs-built_in">putchar</span>(x[i]); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;ch)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">putchar</span>(ch); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> type, <span class="hljs-keyword">typename</span> ...T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(type &amp;x, T &amp;...y)</span> </span>&#123; <span class="hljs-built_in">read</span>(x), <span class="hljs-built_in">read</span>(y...); &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> type, <span class="hljs-keyword">typename</span> ...T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(type x, T...y)</span> </span>&#123; <span class="hljs-built_in">write</span>(x), <span class="hljs-built_in">write</span>(y...); &#125;<br><br><span class="hljs-type">int</span> n, a[<span class="hljs-number">30</span>];<br>string s;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;compress.in&quot;</span>, <span class="hljs-string">&quot;rt&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;compress.out&quot;</span>, <span class="hljs-string">&quot;wt&quot;</span>, stdout);<br>    <span class="hljs-built_in">read</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">read</span>(s);<br>        <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> j: s) &#123;<br>            a[j - <span class="hljs-string">&#x27;a&#x27;</span>] += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++) &#123;<br>            x = <span class="hljs-built_in">max</span>(x, a[j]);<br>        &#125;<br>        <span class="hljs-built_in">write</span>(x &gt; (s.<span class="hljs-built_in">size</span>() &gt;&gt; <span class="hljs-number">1</span>) ? (x &lt;&lt; <span class="hljs-number">1</span>) - s.<span class="hljs-built_in">size</span>() : s.<span class="hljs-built_in">size</span>() &amp; <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">write</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="破解谜题-puzzle"><a href="#破解谜题-puzzle" class="headerlink" title="破解谜题 (puzzle)"></a>破解谜题 (puzzle)</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>考虑使用 DFS 处理每一次请求。直接从请求起始的位置开始往下搜索，直到满足题目给出的不再移动的条件停下，然后赋值即可。</p><p>DFS 函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x == r) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a[x + <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;X&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a[x + <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((a[x + <span class="hljs-number">1</span>][y - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;.&#x27;</span> || a[x][y - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;.&#x27;</span>) &amp;&amp; (a[x + <span class="hljs-number">1</span>][y + <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;.&#x27;</span> || a[x][y + <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;.&#x27;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(x, y)) &#123;<br>        a[x][y] = <span class="hljs-string">&#x27;O&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a[x + <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>        <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, y);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[x + <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (a[x + <span class="hljs-number">1</span>][y - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; a[x][y - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>            <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用这种方法，可以获得 $60 \rm pts$ 的好成绩。</p><h4 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h4><p>很显然，$60 \rm pts$ 是无法使我们满意的，我们需要考虑如何优化。通过观察暴力做法，我们会发现，实际上对于同一列的路径，基本不会有太大的变化，只有末端会产生一点点的变动。因此我们可以考虑如何利用这种非常不错的性质。</p><p>考虑预处理每一列放置的路径，记录路径及其深度。每次放球的时候，从路径的最下方开始，判断路径是否仍合法，如果不合法，就回退，直到找到一个合法的点。从这个合法的点开始，更新路径、放球。这样就可以大幅度的优化程序的运行速度，成功 AC。</p><p>分析一下可得，这种方法的时间复杂度是 $\mathcal{O}(nm^2) \leq 8 \times 10^8$ ，极限情况卡一卡能过，但是实际基本不可能跑满，故可以通过。</p><h4 id="奇怪的思路"><a href="#奇怪的思路" class="headerlink" title="奇怪的思路"></a>奇怪的思路</h4><p>由于这一题是一道原题，所以可以找到一些牛鬼蛇神做法，就比如 lys 的分块做法。类似于正解，我们可以将路径分成若干段，然后每次更新已经错误的块。这种做法从复杂度上来说肯定是没有正解快的，但是仍然能正常通过原题。在这一题中，可能一些较小的块大小可以 AC，但是很遗憾 lys 的代码只能获得 $60 \rm pts$ 的成绩。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h4 id="分块打法"><a href="#分块打法" class="headerlink" title="分块打法"></a>分块打法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">int</span>&gt;<br>T <span class="hljs-built_in">read</span>() &#123;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-keyword">while</span> (c = <span class="hljs-built_in">getchar</span>(), c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>);<br>    T x = c ^ <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">while</span> (c = <span class="hljs-built_in">getchar</span>(), c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>        x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">30000</span>, M = <span class="hljs-number">30</span>, MS = M + <span class="hljs-number">2</span>, L = <span class="hljs-number">50</span>;<br><span class="hljs-type">int</span> n, m, bSum;<br><span class="hljs-type">int</span> bId[N + <span class="hljs-number">2</span>], bPos[N + <span class="hljs-number">2</span>], p[N + <span class="hljs-number">2</span>][MS];<br><span class="hljs-type">char</span> mp[N + <span class="hljs-number">2</span>][MS];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (*(mp[<span class="hljs-number">0</span>] + pos + MS) == <span class="hljs-string">&#x27;.&#x27;</span>)<br>        <span class="hljs-keyword">return</span> *(p[<span class="hljs-number">0</span>] + pos + MS);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(mp[<span class="hljs-number">0</span>] + pos + MS) == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (*(mp[<span class="hljs-number">0</span>] + pos - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; *(mp[<span class="hljs-number">0</span>] + pos + MS - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>)<br>            <span class="hljs-keyword">return</span> *(p[<span class="hljs-number">0</span>] + pos + MS - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*(mp[<span class="hljs-number">0</span>] + pos + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; *(mp[<span class="hljs-number">0</span>] + pos + MS + <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>)<br>            <span class="hljs-keyword">return</span> *(p[<span class="hljs-number">0</span>] + pos + MS + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> pos;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i, <span class="hljs-type">const</span> <span class="hljs-type">int</span> xx)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> le = bPos[i] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (xx == bPos[i + <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)<br>            p[xx][i] = xx * MS + i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = xx - <span class="hljs-number">1</span>; i &gt;= le; --i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j)<br>            <span class="hljs-keyword">if</span> (mp[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>)<br>                p[i][j] = <span class="hljs-built_in">get</span>(i * MS + j);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bInit</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        bId[i] = (i - <span class="hljs-number">1</span>) / L;<br>    bSum = bId[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= bSum; ++i)<br>        bPos[i] = i * L;<br>    bPos[bSum + <span class="hljs-number">1</span>] = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = bSum; i &gt;= <span class="hljs-number">0</span>; --i)<br>        <span class="hljs-built_in">build</span>(i, bPos[i + <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;puzzle.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;puzzle.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    n = <span class="hljs-built_in">read</span>(), m = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, mp[i] + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">bInit</span>();<br>    <span class="hljs-type">int</span> q = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> pos = *(p[<span class="hljs-number">0</span>] + MS + <span class="hljs-built_in">read</span>()), pp;<br>        <span class="hljs-keyword">while</span> ((pp = <span class="hljs-built_in">get</span>(pos)) != pos)<br>            pos = pp;<br>        mp[pos / MS][pos % MS] = <span class="hljs-string">&#x27;O&#x27;</span>;<br>        <span class="hljs-built_in">build</span>(bId[pos / MS], pos / MS);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, mp[i] + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="记忆化打法"><a href="#记忆化打法" class="headerlink" title="记忆化打法"></a>记忆化打法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">char</span> a[<span class="hljs-number">80009</span>][<span class="hljs-number">109</span>];<br><span class="hljs-type">int</span> r, c, n, x, path[<span class="hljs-number">109</span>][<span class="hljs-number">80009</span>], depth[<span class="hljs-number">109</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> from)</span> </span>&#123;<br>    path[from][x] = y;<br>    depth[from] = x;<br>    <span class="hljs-keyword">if</span> (a[x + <span class="hljs-number">1</span>][y] != <span class="hljs-string">&#x27;O&#x27;</span> &amp;&amp; a[x + <span class="hljs-number">1</span>][y] != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a[x + <span class="hljs-number">1</span>][y] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>        <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, y, from);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a[x + <span class="hljs-number">1</span>][y - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; a[x][y - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>        <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>, from);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a[x + <span class="hljs-number">1</span>][y + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; a[x][y + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>        <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>, from);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (a[depth[x]][path[x][depth[x]]] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; depth[x] &gt; <span class="hljs-number">0</span>) &#123;<br>        depth[x] -= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(depth[x], path[x][depth[x]], x);<br>    a[depth[x]][path[x][depth[x]]] = <span class="hljs-string">&#x27;O&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;puzzle.in&quot;</span>, <span class="hljs-string">&quot;rt&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;puzzle.out&quot;</span>, <span class="hljs-string">&quot;wt&quot;</span>, stdout);<br>    cin &gt;&gt; r &gt;&gt; c &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= r; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= c; j++) &#123;<br>            cin &gt;&gt; a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= c; i++) &#123;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, i, i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; x;<br>        <span class="hljs-built_in">work</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= r; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= c; j++) &#123;<br>            cout &lt;&lt; a[i][j];<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="遥遥领先-chase"><a href="#遥遥领先-chase" class="headerlink" title="遥遥领先 (chase)"></a>遥遥领先 (chase)</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>看一眼题目，我们可以很容易的发现，这题似乎很像一道搜索题。没错，这题可以搜索，但是没法<br>AC。很容易发现，这个路线的答案会非常大，而搜索必须搜出每一种可能，这就会导致严重的时间超限。</p><p>但是良心的出题人为 DFS 准备了 $20$ 分部分分，也为 BFS 的选手准备了 $60$<br>分部分分。</p><p>即使部分分很多，我们还是要考虑正解的写法。很显然，直接枚举是不可能的，因此我们可以考虑使用动态规划的方式统计路径的数量。为了方便，我们定义状态<br>$f_{i,, j,, k,, t}$ 为走到点 $(i,,j)$，转向 $k$ 次，从 $t$<br>方向走来的路径数量（其中 $t &#x3D; 1$ 表示纵向、$t &#x3D; 2$<br>表示横向）。设定完了状态，我们就需要考虑如何转移状态。很容易发现，我们需要分类讨论一下：</p><ul><li><p><strong>不转向</strong>。此时<br>$f_{i,,j,,k,,1}&#x3D;f_{i,,j,,k,,1} + f_{i-1,,j,,k,,1}$，$f_{i,,j,,k,,2}&#x3D;f_{i,,j,,k,,2} + f_{i,,j-1,,k,,1}$。</p></li><li><p><strong>转向</strong>。在这种情况下，我们也是直接转移即可，但是要注意转向次数要<br>$+1$：<br>$f_{i,,j,,k,,1} &#x3D; f_{i,,j,,k,,1}+f_{i,,j - 1,,k - 1,,2}$，$f_{i,,j,,k,,2} &#x3D; f_{i,,j,,k,,2} + f_{i - 1,,j,,k -1,,1}$。但是，对于最后一个状态，不应统计转向的情况。</p></li></ul><p>需要注意的是初始值的安排：对于<br>$f_{i,,j,,0,,1}$，在第一个纵向不能走的位置之前，这个状态的值为<br>$1$，此后为 $0$，横向的亦是如此。</p><p>至此，大事已成，简单实现即可。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mod 1000000007</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">char</span> a[<span class="hljs-number">250</span>][<span class="hljs-number">250</span>];<br><span class="hljs-type">int</span> t, n, m, f[<span class="hljs-number">250</span>][<span class="hljs-number">250</span>][<span class="hljs-number">250</span>][<span class="hljs-number">3</span>];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;chase.in&quot;</span>, <span class="hljs-string">&quot;rt&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;chase.out&quot;</span>, <span class="hljs-string">&quot;wt&quot;</span>, stdout);<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            cin &gt;&gt; a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">bool</span> p1 = <span class="hljs-literal">true</span>, p2 = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        p1 &amp;= a[i][<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (p1) &#123;<br>            f[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        p2 &amp;= a[<span class="hljs-number">1</span>][i] != <span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (p2) &#123;<br>            f[<span class="hljs-number">1</span>][i][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= t; k++) &#123;<br>                f[i][j][k][<span class="hljs-number">1</span>] += f[i - <span class="hljs-number">1</span>][j][k][<span class="hljs-number">1</span>];<br>                f[i][j][k][<span class="hljs-number">2</span>] += f[i][j - <span class="hljs-number">1</span>][k][<span class="hljs-number">2</span>];<br>                f[i][j][k][<span class="hljs-number">1</span>] %= mod;<br>                f[i][j][k][<span class="hljs-number">2</span>] %= mod;<br>                <span class="hljs-keyword">if</span> ((i != n || j != m)) &#123;<br>                    f[i][j][k][<span class="hljs-number">1</span>] += f[i][j - <span class="hljs-number">1</span>][k - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>                    f[i][j][k][<span class="hljs-number">2</span>] += f[i - <span class="hljs-number">1</span>][j][k - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>                    f[i][j][k][<span class="hljs-number">1</span>] %= mod;<br>                    f[i][j][k][<span class="hljs-number">2</span>] %= mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= t; i++) &#123;<br>        ans += f[n][m][i][<span class="hljs-number">1</span>] + f[n][m][i][<span class="hljs-number">2</span>];<br>        ans %= mod;<br>    &#125;<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="积积积-int"><a href="#积积积-int" class="headerlink" title="积积积 (int)"></a>积积积 (int)</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><del>这道题作为附加题，还是十分优秀的。</del></p><p>我们可以看道题目中给出的式子：<br>$$<br>\int^R_L f(x), \textrm{d}x<br>$$<br>究竟是什么意思呢？其实就是求函数 $f(x)$ 在 $L$ 到 $R$<br>之间的定值积分。在讲求值之前，要先讲一下映射、函数和积分。</p><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>再讲函数之前，先要讲一讲映射。首先我们考虑有两个非空集合 $X$ 和 $Y$，如果存在一种法则 $f$，使得  $X$ 中的每一个元素 $x$，按法则 $f$，在集合 $Y$ 中有唯一确定的元素 $y$  与之对应。那么此时我们称 $f$ 为 $X$ 到 $Y$ 的映射，形式化的记作：<br>$$<br>f:X\to Y<br>$$</p><p>在这之中，我们把  $y$ 称为元素 $x$ 在映射 $f$ 下的像，记作：</p><p>$$<br>y&#x3D;f(x)<br>$$</p><p>而元素  $x$ 称为元素 $y$ 在映射 $f$ 中的一个原像。</p><p>映射有两个必须知道的基本概念，<strong>值域</strong>和<strong>定义域</strong>。其中：</p><ul><li><p><strong>值域</strong>：即映射的所有像组成的集合。</p></li><li><p><strong>定义域</strong>：即映射的所有原像组成的集合。</p></li></ul><p>对于这道题，关于映射，这些就已经足够了，想了解更多，可以去翻看一下《高等数学第7版-上册》。</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>或许接触过函数的人看到映射中那些名词会感觉有一些熟悉，这是应该的，因为从高等数学的角度上看，函数就是实数集（或它的子集）到实数集的一个映射。形式化的说：我们设数集 $D\subset\mathbf{R}$，则称映射 $f:D\to \mathbf{R}$ 为定义在 $D$ 上的函数，简记为：<br>$$<br>y&#x3D;f(x),,x\in D<br>$$<br>其中 $x$ 称为<strong>自变量</strong>，$y$ 为<strong>因变量</strong>，$D$ 称为函数的<strong>定义域</strong>，记作 $D_f$ 即 $D_f&#x3D;D$。</p><p>常见的函数有一次函数、二次函数、三角函数、对数函数等等，它们的函数图像如图。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0.png" srcset="/img/loading.gif" lazyload alt="图1-左：一次函数"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0.png" srcset="/img/loading.gif" lazyload alt="图1-右：二次函数"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0.png" srcset="/img/loading.gif" lazyload alt="图2-左：对数函数"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0.png" srcset="/img/loading.gif" lazyload alt="图2-右：三角函数"></p><p>你还需要会知道一些函数的特性：</p><ul><li><p><strong>函数的有界性</strong>：由于函数的定义域是一定的，这可能会导致函数的值域并不是整个实数域。</p></li><li><p><strong>函数的周期性</strong>：如果存在一个正数 $l$，使得 $f(x)&#x3D;f(x + l)$ 恒成立，那么我们称这个函数为<strong>周期函数</strong>，且我们称 $l$ 是函数 $f$ 的周期，一般地，我们称周期为函数的。正弦函数（$\sin$）就是常见的周期函数。</p></li></ul><h4 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h4><p>积分问题通常被分为两类：<strong>不定积分</strong>和<strong>定积分</strong>。对于这道题，你只需要理解定积分。一般定积分以下属方式表达：</p><p>$$<br>\int_a^b f(x),\textrm{d}x<br>$$<br>其中 $b$ 为<strong>积分上限</strong>、$a$ 为 <strong>积分下限</strong>，二者组成了一个<strong>积分区间</strong> $[a,,b]$、$f(x)$ 被称为<strong>被积函数</strong>，而 $f(x),\textrm{d}x$ 称为<strong>被积表达式</strong>。</p><p>当然，聪明的你可定发现了，有些函数是不可以积分的，简称不可积。那么那些函数是可积的呢？《高等数学》告诉了我们答案：</p><ul><li><p>设 $f(x)$ 在区间 $[a,,b]$ 上连续，则 $f(x)$ 在 $[a,,b]$ 上可积。</p></li><li><p>设 $f(x)$ 在区间 $[a,,b]$ 上有界，且只有有限个间断点，则 $f(x)$ 在 $[a,,b]$ 上可积。</p></li></ul><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E5%AE%9A%E7%A7%AF%E5%88%86.png" srcset="/img/loading.gif" lazyload alt="图3：定积分例1 - 普通函数"></p><p>好的，那么积分是什么呢？实际上对于定积分，你可以认为他是在一段区间内函数值的和，但是这个求和是连续的，看到图3。图 3 中棕色的部分面积就是图中黑色函数在积分区间 $[-2,,20]$ 的积分值。这就是积分的几何意义。</p><p>但是你可能会发现一个问题，就是如果函数在积分区间内有负值，那么怎么办呢？我么可以通过一个例子来理解这个问题。我们可以构造一个周期函数，然后尝试求他的积分值。图4就是一个正弦函数的图像。图像中棕色部分就是函数值为正的部分，区间为 $[0,,\pi]$，蓝色部分是函数值为负的部分，区间 $[\pi,,2\pi]$ 我们可以大胆猜测一下，函数 $\sin (x)$ 在区间 $[0, 2\pi]$ 的积分值是棕色部分减去蓝色部分，也就是 $0$。拿出计算器计算一下就会发现，结论正确。定积分值实际上就是函数位于$x$ 轴上方部分的面积减去 $x$ 轴下方的面积！</p><p>到这里，你已经基本掌握了做题所需的知识，让我们<del>出发吧，旅行者！</del></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0.png" srcset="/img/loading.gif" lazyload alt="图4：定积分例2 - 周期函数"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><h4 id="积分值计算"><a href="#积分值计算" class="headerlink" title="积分值计算"></a>积分值计算</h4><p>首先解决积分求值的问题，我们从最简单的矩形逼近开始。我们尝试把函数下的图形用矩形逼近，或者说常使用一些矩形把函数下的部分填满，如图5（左）。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E7%9F%A9%E5%BD%A2%E9%80%BC%E8%BF%91.png" srcset="/img/loading.gif" lazyload alt="图5-左：矩形逼近"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E6%A2%AF%E5%BD%A2%E9%80%BC%E8%BF%91.png" srcset="/img/loading.gif" lazyload alt="图5-右：梯形逼近"></p><p>很容易发现即使我们把面积分成这么多块，精度还是十分的低。我们考虑把矩形换成梯形，就像图 5（右）。这样看起来精度似乎提升了，但是效率似乎很低，我们亟需一种高效且精度高的定积分求值方式。</p><p>如果你翻看一篇内容杂糅的<a href="https://dl.acm.org/doi/epdf/10.1145/367766.368179">论文</a>，你就会找到一种神奇的算法：辛普森法。这种算法使用一些二次函数来逼近我们要积的函数。</p><p>原论文中对算法数学推倒的过程非常少，因此下面给出一种 Simpson 公式的非原著推导过程，我们设 $g(x) &#x3D; ax^2+bx+c$ 为拟合后的函数，则推导过程如下： </p><p>$$<br>\begin{align*}<br>\int_L^R f(x),\textrm{d}x &amp;\approx \frac{1}{3}a\left(R^3-L^3\right)+\frac{1}{2}b\left(R^2-L^2\right)+c\left(R-L\right)\<br>        &amp;&#x3D; \frac{R-L}{6}\left(2a\left(L^2+LR+R^2\right)+3b\left(L+R\right)+6c\right)\<br>        &amp;&#x3D; \frac{R-L}{6}\left( aL^2+bL+c+aR^2+bR+c+4a\left(\frac{L+R}{2}\right)^2+4b\left(\frac{L+R}{2}\right) + 4c\right)\<br>        &amp;&#x3D; \frac{R-L}{6}\left(f(L)+4f\left(\frac{L+R}{2}\right)+f(R)\right)<br>\end{align*}<br>$$<br>这就是大名鼎鼎的辛普森公式：</p><p>$$<br>\int_L^R f(x),\textrm{d}x \approx \frac{R-L}{6}\left(f(L)+4f\left(\frac{L+R}{2}\right)+f(R)\right)<br>$$</p><p>获得了辛普森公式，正当你计算时，你就会发现精度根本不足！因为一个二次函数很显然是不足以逼近一个复杂函数的。</p><p>为了解决精度问题，我们可以考虑将函数分段，我们可以将积分区间砍半，分为两次计算。每次都将区间砍半，直到精度达标。在估算精度的过程中，还存在着一个技巧。这个技巧在《数值分析》一书中有提到。</p><p>这个技巧来源于推广中值定理[^2]。根据这个定理，我们可以发现当辛普森法算出来的积分值误差 $\leq 15eps$ （$eps$ 为给定的容差值（TOL）），那么这个值加上误差的 $\frac{1}{15}$ 就是我们需要得到的足够精度的值了。具体证明参考原书 P240。</p><h4 id="字符串解析"><a href="#字符串解析" class="headerlink" title="字符串解析"></a>字符串解析</h4><p><del>由于出题人非常毒瘤</del>，给定的函数并不是固定的，他是由一个字符串表示的。这个字符串的格式是计算机难以识别的中缀表达式<a href="%E6%AD%A3%E5%B8%B8%E4%BA%BA%E7%B1%BB%E8%AE%A1%E7%AE%97%E6%89%80%E7%94%A8%E7%9A%84%E7%AE%97%E5%BC%8F">^3</a>。为了计算函数值，我们需要解析这个恶心的中缀表达式。</p><p>常见的解析中缀表达式的方式就是用栈来解析，具体过程如下：</p><ol><li><p><strong>转换为后缀表达式（逆波兰表达式）</strong></p><ul><li><p>创建一个空栈和一个空输出列表。</p></li><li><p>从左到右扫描中缀表达式：</p></li><li><p>如果遇到操作数，添加到输出列表。</p></li><li><p>如果遇到运算符，将其推入栈。</p></li><li><p>如果遇到左括号，将其推入栈。</p></li><li><p>如果遇到右括号，则弹出栈顶元素并添加到输出列表，直到遇到左括号。弹出左括号但不添加到输出列表。</p></li><li><p>如果栈不为空，弹出所有剩余的运算符并添加到输出列表。</p></li></ul></li><li><p><strong>计算后缀表达式</strong></p><ul><li><p>创建一个空栈。</p></li><li><p>从左到右扫描后缀表达式：</p></li><li><p>如果遇到操作数，将其推入栈。</p></li><li><p>如果遇到运算符，弹出栈顶的两个操作数，进行计算，然后将结果推回栈。</p></li><li><p>当后缀表达式被完全扫描后，栈顶的元素就是最终结果。</p></li></ul></li></ol><p>至此我们完成了题目的所有步骤，只需要将计算函数值和计算积分值两个部分结合一下即可。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">double</span> db;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">opl</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (ch) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">opv</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (ch) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;^&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">oper</span> &#123;<br>    <span class="hljs-type">int</span> op, l, r;<br>&#125; ope[<span class="hljs-number">114514</span>];<br>db mem[<span class="hljs-number">114514</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">char</span> op, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    ope[++c] = oper&#123;<span class="hljs-built_in">opv</span>(op), l, r&#125;;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; v;<br>    stack&lt;<span class="hljs-type">char</span>&gt; op;<br>    <span class="hljs-keyword">auto</span> cc = [&amp;]() &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        b = v.<span class="hljs-built_in">top</span>();<br>        v.<span class="hljs-built_in">pop</span>();<br>        a = v.<span class="hljs-built_in">top</span>();<br>        v.<span class="hljs-built_in">top</span>() = <span class="hljs-built_in">push</span>(op.<span class="hljs-built_in">top</span>(), a, b);<br>        op.<span class="hljs-built_in">pop</span>();<br>    &#125;;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cin.<span class="hljs-built_in">peek</span>() == <span class="hljs-string">&#x27;)&#x27;</span> || <span class="hljs-built_in">isspace</span>(cin.<span class="hljs-built_in">peek</span>())) &#123;<br>            cin.<span class="hljs-built_in">get</span>();<br>            <span class="hljs-keyword">while</span> (!op.<span class="hljs-built_in">empty</span>())<span class="hljs-built_in">cc</span>();<br>            <span class="hljs-keyword">return</span> v.<span class="hljs-built_in">top</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cin.<span class="hljs-built_in">peek</span>() == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>            cin.<span class="hljs-built_in">get</span>();<br>            v.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pre</span>());<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">opl</span>(cin.<span class="hljs-built_in">peek</span>()) != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-type">char</span> ch = cin.<span class="hljs-built_in">get</span>();<br>            <span class="hljs-keyword">while</span> (!op.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">opl</span>(op.<span class="hljs-built_in">top</span>()) &gt;= <span class="hljs-built_in">opl</span>(ch))<span class="hljs-built_in">cc</span>();<br>            op.<span class="hljs-built_in">push</span>(ch);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(cin.<span class="hljs-built_in">peek</span>())) &#123;<br>            ++c;<br>            cin &gt;&gt; mem[c];<br>            v.<span class="hljs-built_in">push</span>(c);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cin.<span class="hljs-built_in">peek</span>() == <span class="hljs-string">&#x27;x&#x27;</span>) &#123;<br>            cin.<span class="hljs-built_in">get</span>();<br>            v.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">db <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>    mem[<span class="hljs-number">0</span>] = x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= c; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (ope[i].op)<br>            <span class="hljs-keyword">switch</span> (ope[i].op) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    mem[i] = mem[ope[i].l] + mem[ope[i].r];<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    mem[i] = mem[ope[i].l] - mem[ope[i].r];<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    mem[i] = mem[ope[i].l] * mem[ope[i].r];<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                    mem[i] = mem[ope[i].l] / mem[ope[i].r];<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                    mem[i] = <span class="hljs-built_in">pow</span>(mem[ope[i].l], mem[ope[i].r]);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mem[c];<br>&#125;<br><br>db l, r;<br><br><span class="hljs-function">db <span class="hljs-title">sps</span><span class="hljs-params">(db a, db b, db c, db l)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> l / <span class="hljs-number">6.0</span> * (a + b + <span class="hljs-number">4</span> * c);<br>&#125;<br><br><span class="hljs-type">const</span> db eps = <span class="hljs-number">1e-10</span>;<br><br><span class="hljs-function">db <span class="hljs-title">calc</span><span class="hljs-params">(db l, db r, db mid, db t, db fl, db fr, db fm)</span> </span>&#123;<br>    db m1 = (l + mid) / <span class="hljs-number">2.0</span>, m2 = (mid + r) / <span class="hljs-number">2.0</span>;<br>    db fm1 = <span class="hljs-built_in">f</span>(m1), fm2 = <span class="hljs-built_in">f</span>(m2);<br>    db<br>            t1 = <span class="hljs-built_in">sps</span>(fl, fm, fm1, mid - l),<br>            t2 = <span class="hljs-built_in">sps</span>(fm, fr, fm2, r - mid);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(t1 + t2 - t) &lt;= <span class="hljs-number">15</span> * eps) <span class="hljs-keyword">return</span> t1 + t2 + (t1 + t2 - t) / <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">calc</span>(l, mid, m1, t1, fl, fm, fm1) + <span class="hljs-built_in">calc</span>(mid, r, m2, t2, fm, fr, fm2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> db <span class="hljs-title">g</span><span class="hljs-params">(db l, db r)</span> </span>&#123;<br>    db mid = (l + r) / <span class="hljs-number">2</span>;<br>    db a = <span class="hljs-built_in">f</span>(l), b = <span class="hljs-built_in">f</span>(r), c = <span class="hljs-built_in">f</span>(mid);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">calc</span>(l, r, mid, <span class="hljs-built_in">sps</span>(a, b, c, r - l), a, b, c);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;int.in&quot;</span>, <span class="hljs-string">&quot;rt&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;int.out&quot;</span>, <span class="hljs-string">&quot;wt&quot;</span>, stdout);<br>    cout &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">6</span>) &lt;&lt; fixed;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>), cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">pre</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= c; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (ope[i].op &amp;&amp;<br>            ope[i].l &amp;&amp;<br>            ope[i].r &amp;&amp;<br>            !ope[ope[i].l].op &amp;&amp;<br>            !ope[ope[i].r].op) &#123;<br>            <span class="hljs-keyword">switch</span> (ope[i].op) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    mem[i] = mem[ope[i].l] + mem[ope[i].r];<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    mem[i] = mem[ope[i].l] - mem[ope[i].r];<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    mem[i] = mem[ope[i].l] * mem[ope[i].r];<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                    mem[i] = mem[ope[i].l] / mem[ope[i].r];<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                    mem[i] = <span class="hljs-built_in">pow</span>(mem[ope[i].l], mem[ope[i].r]);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            ope[i].op = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    cin &gt;&gt; l &gt;&gt; r;<br>    cout &lt;&lt; <span class="hljs-built_in">g</span>(l, r);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>首先我要向举办本场比赛的陈旭龙老师以及 TYOI 全体教练表示感谢，他们让我由于有了这次出题、讲题的机会。这次机会也为我本人带来了很大的水平提升。认识到做一个出题人有多么痛苦，背锅的压力有多么大。</p><p>其次要感谢在出题和学习过程中帮助过所有同学，包括但不限于带我入坑数学的<strong>曾奂霖</strong>、帮助写STD还在验题期间爆踩 STD 的<strong>苏昱霖</strong>、帮助我排除大坑的<strong>陈韦澔</strong>和<strong>沈歆迪</strong>……没有这些同学的帮助，这场如此优质的比赛一定不会诞生。</p><p>一定要感谢的是我的家人和学校为我带来了如此优质的学习环境，为我的 OI 生涯添砖加瓦。</p><p>最后感谢为本次比赛出题提供过帮助的所有人，包括但不限于 Lemon Lime 的开发者、Hydro 的开发者、VSCode 的开发者、GeoGebra的开发者、Desmos<br>的开发者、Mathworks 团队、Wolfram 团队、TexLive 以及 TexStudio 软件的开发者、《数值分析》的作者及译者、《高等数学》的作者、《算法导论》的作者及译者、CodeForces 运营团队、COCI 出题团队、辛普森本人，以及记不清的无数为出题提供过帮助的人。</p><p>[^2]: 见《数值分析》[@数值分析] P218</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
      <tag>公益赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>THUWC 2024 游记</title>
    <link href="/posts/44036.html"/>
    <url>/posts/44036.html</url>
    
    <content type="html"><![CDATA[<h2 id="Day-INF"><a href="#Day-INF" class="headerlink" title="Day -INF"></a>Day -INF</h2><p>大喜，第一年打比赛就直通 THUWC 了，开心到飞起。</p><h2 id="Day-7"><a href="#Day-7" class="headerlink" title="Day -7"></a>Day -7</h2><p>开始寒假集训前一天，发现重庆天气很冷，极限跑去优衣库不看价格买了一件羽绒服。付款的时候 699 真的蚌埠住了，还好 Mate 60 Pro 专属卡返现了几十块，小回了一波血。</p><h2 id="Day-6-sim-1"><a href="#Day-6-sim-1" class="headerlink" title="Day -6 $\sim$ -1"></a>Day -6 $\sim$ -1</h2><p>在番禺校区集训，学了一堆树上的算法，感觉很懵。集训还没结束就走了。</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><h3 id="启程"><a href="#启程" class="headerlink" title="启程"></a>启程</h3><p>由于住番禺郊区，离白云机场特别远，6 点多就开车出发了。到了机场，感觉航站楼相当壮观（之前没来过），但是廊桥真的很螂桥。一进航站楼就看见了桌子，我不敢叫他。办了值机，龙让在安检口等。我打电话给 ZL，他说打错了，绷不住。后来龙一家迟到，让我们先过安检，666。</p><p>大家在登机口拍合照，有些混乱，但是这是 TY 人数最多的一次。第一次见到龙的两个女儿和龙夫人，有点惊讶龙女儿那么小。</p><p>到了重庆，感觉重庆地铁 10 号线照抄广州，所以没有扶任何东西，毕竟广州地铁是很温柔的。谁知道从江北启动那一下差点把我掀翻在地。总之重庆地铁舒适度很差。</p><p>中午在巴蜀校门口吃了一个饺子，感觉辣度还能接受。</p><p>进巴蜀签到、试机，巴蜀的学校很狭长，中间一条种满梧桐的校道看起来很有冬日的气息，光得像我两天后的 VSCode。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0423(20240125-224526).PNG" srcset="/img/loading.gif" lazyload alt="IMG_0423(20240125-224526)"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0425(20240129-204446).PNG" srcset="/img/loading.gif" lazyload alt="IMG_0425(20240129-204446)"></p><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>签到的时候要买饭票，我一开始以为要买两天的午饭和晚饭，差点就付钱了。突然想起来要问一下其他人，才知道计划是只买两张，还好。吐槽一句饭堂很贵，一顿 25 还没有我们 TY 15 的好吃。</p><p>按照惯例，送了一些东西：一个鼠标、一本马少平教授写的书、一支笔。很不错，听说隔壁北大营并没有如此丰厚的礼物。而且我还发现书上马教授的签名是手写的，几千本，手写真的有点强！</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0426.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0426"></p><h3 id="试机"><a href="#试机" class="headerlink" title="试机"></a>试机</h3><p>比我们先行一步的 LJY 已经在机房，打电话问我们终端怎么开。我一开始以为考场是正常的 NOI Linux，告诉她打开 Dock。她说没有 Dock，最后让她打开一个文件夹，然后右键，解决。</p><p>我自己进了考场才知道机子根本不是正常的 NOI Linux，桌面环境是 Rat，shit 一般的不好用。好在机子很新，12 代的 i3 不再挤牙膏，用起来很流畅。试机赛一共 3 题，T1 A+B，秒了；T2 是一道交互，打了个性质；T3 忘了，反正打了一个暴力。试机的时候可以用手机所以拍了一些照片，但是找不到了，悲。喷一下机房键盘和鼠标的灰厚得跟__一样，擦了好久才擦干净。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0428.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0428"></p><p>试机完出来，龙和一群教练在三楼平台聊天，我们在旁边腐朽，但是只有 ZL 被龙警告了，喜。</p><h3 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h3><p>回到酒店，先是水了一会帖子，然后去点外卖，感觉抄手和云吞没有任何区别，不如云吞好吃。</p><p>晚上女队提议出去走走，我们四个就走到洪崖洞（离我们酒店不到 200 米），人山人海，玩不了一点。于是桌子就带我们坐地铁绕了几圈，拍了一些照片，很便宜，才 2 元。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/C87E83EF6CDE737F2F4AAD2BFCE3DCC3.png" srcset="/img/loading.gif" lazyload alt="C87E83EF6CDE737F2F4AAD2BFCE3DCC3"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/90C2282C909841A280DBCBABDA296614.png" srcset="/img/loading.gif" lazyload alt="90C2282C909841A280DBCBABDA296614"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/29B43C0F05F1F9860BD3264A7E890E0F.png" srcset="/img/loading.gif" lazyload alt="29B43C0F05F1F9860BD3264A7E890E0F"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/9AC5C01BEC8C3B4D569CD4A80B4C91E3.png" srcset="/img/loading.gif" lazyload alt="9AC5C01BEC8C3B4D569CD4A80B4C91E3"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/A657C96AB3A9BA2A2223D61E289A16E4.png" srcset="/img/loading.gif" lazyload alt="A657C96AB3A9BA2A2223D61E289A16E4"></p><p>回到酒店腐了一会，睡了。</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><h3 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h3><p>Day 1 题目很难评价，虽说是近乎 IOI 赛制，但是题目又提交次数限制，而且评测的特别满。由于太菜了，比赛只打了几十分，ZL很强，据说有 300+；女队 150+；剑神 200+。Mod 大佬。</p><h3 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h3><h4 id="开幕式"><a href="#开幕式" class="headerlink" title="开幕式"></a>开幕式</h4><p>开幕式先是播了巴蜀中学的宣传片，这个我在 B 站已经看过了，想看的也可以去搜一下。然后有舞蹈和合唱，合唱是假唱，服了。然后是领导讲话，并不是很好听。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0649(20240127-235130).JPG" srcset="/img/loading.gif" lazyload alt="IMG_0649(20240127-235130)"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/5FA11BA64210292F43F4A89B3F98A0A7.png" srcset="/img/loading.gif" lazyload alt="5FA11BA64210292F43F4A89B3F98A0A7"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0565(20240127-235130).JPG" srcset="/img/loading.gif" lazyload alt="IMG_0565(20240127-235130)"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0598(20240126-225337).JPG" srcset="/img/loading.gif" lazyload alt="IMG_0598(20240126-225337)"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0613(20240126-225714).JPG" srcset="/img/loading.gif" lazyload alt="IMG_0613(20240126-225714)"></p><h4 id="学术报告"><a href="#学术报告" class="headerlink" title="学术报告"></a>学术报告</h4><p>开幕式后马教授做了一个学术报告。主要是有关人工智能历史的。提问环节由一个龟孙问了一个问题：“明天的工程题是不是要手搓人工智能？”教授说他不参与命题，但是 tnnd 被猜中了。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0516(20240129-204446).JPG" srcset="/img/loading.gif" lazyload alt="IMG_0516(20240129-204446)"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0510(20240129-204446).JPG" srcset="/img/loading.gif" lazyload alt="IMG_0510(20240129-204446)"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0515(20240127-235130).JPG" srcset="/img/loading.gif" lazyload alt="IMG_0515(20240127-235130)"></p><h3 id="晚上-1"><a href="#晚上-1" class="headerlink" title="晚上"></a>晚上</h3><p>我们五个一起去吃了火锅，然后其他人都出去玩了，我和 ZL 不想出去，苟在酒店。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0659.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0659"></p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><h3 id="比赛-1"><a href="#比赛-1" class="headerlink" title="比赛"></a>比赛</h3><p>很不幸，Day 2 的比赛就是手搓人工智能。题目要求写一个下重力四子棋的算法。给了一份 124 页的 PPT，从爆搜到 $\alpha-\beta$ 剪枝再到蒙特卡洛搜索树，然后随后讲了 NNUE 和强化学习。我看完之后感觉如看，还是爆搜。连最水样例都打不过，特判了一下死局，就能打赢了。但是样例二又把我的算法狠狠拿捏了。</p><p>打完 emo，但是剑神 490，mod mod mod。</p><h3 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h3><h4 id="学术报告-1"><a href="#学术报告-1" class="headerlink" title="学术报告"></a>学术报告</h4><p>下午是一位大神的学术报告，不如说是闲聊。这位清华的助理教授是 Facebook 初创、OpenAI 核心员工、字节 AI 初创，（估计是钱赚够了）后来回到清华任教。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0668.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0668"></p><p>他做了很多有意思的项目，总之讲的很有意思，所有人都听得津津有味。</p><p>提问的时候我其实想问为什么 ChatGLM 4 不再开源，但是等我做完心理建设，提问环节就结束了，悲。</p><h4 id="颁奖"><a href="#颁奖" class="headerlink" title="颁奖"></a>颁奖</h4><p>没什么好说的，参与奖，┭┮﹏┭┮</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0671.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0671"></p><h3 id="晚上-2"><a href="#晚上-2" class="headerlink" title="晚上"></a>晚上</h3><p>晚上我们清华营跑去北大那边聚餐，龙请的。龙点菜比我要大方一些，吃的很不错。不过两天吃的火锅我个人认为都不辣（我是广东人）。</p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><h3 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h3><p>上午大家一起去了三峡博物馆，很大，但是 gcd 含量拉满，一点都不好看。买了几张明信片，很便宜，一张 3 块。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0703.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0703"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0704.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0704"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0695.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0695"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0696.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0696"></p><h3 id="中午"><a href="#中午" class="headerlink" title="中午"></a>中午</h3><p>中午说分头吃饭，但是大家都不约而同的去了汉堡王，6。然后我们就出发去机场。</p><h3 id="回程"><a href="#回程" class="headerlink" title="回程"></a>回程</h3><p>桌子说想坐 3 号线然后转回 10 号线，我算了一下时间还有大概 2.5 小时，但是考虑到内地的效率可能没有我们广东高。我还是觉得应该坐十号线直接去机场。</p><p>去到机场才发现 LJY 一家没有选座，而且很慢很慢，搞得我们等了他们一家 1 个小时！！！绷不住了！</p><p>拿到行李离登机还有 1.5 个小时，我感觉不妙，冲去安检。很不妙，只有 20 个人左右，安检了 1.25 个小时，fuck 江北机场。最后冲到登机口，差点翻车，sb 江北机场，效率不到广州的 $1,%$。</p><p>787-9 很舒服，爆杀来的时候那架 737。不过吐槽一点，说了延误半小时起飞，为什么 15 分钟就机长广播起飞了！我那会刚要睡着，然后咚一声就把我喊醒，人还没清醒就全开加力，直接旱地拔葱，推背感拉满，搞得我有点懵逼。</p><p>回到广州，还得佩服一下白云机场的设计，比江北高效多了，6。</p><p>最后放几张飞机上的黄昏。</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0729.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0729"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0736.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0736"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0741.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0741"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/IMG_0745.JPG" srcset="/img/loading.gif" lazyload alt="IMG_0745"></p>]]></content>
    
    
    
    <tags>
      
      <tag>游记</tag>
      
      <tag>THU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OiClass 公益赛宣传</title>
    <link href="/posts/54641.html"/>
    <url>/posts/54641.html</url>
    
    <content type="html"><![CDATA[<h2 id="OiClass-公益赛宣传"><a href="#OiClass-公益赛宣传" class="headerlink" title="OiClass 公益赛宣传"></a>OiClass 公益赛宣传</h2><p><img src="https://chxulong.oss-cn-shenzhen.aliyuncs.com/oiclass_pic/gongyisai.jpg" srcset="/img/loading.gif" lazyload></p><h2 id="活动意义"><a href="#活动意义" class="headerlink" title="活动意义"></a>活动意义</h2><ol><li>为了增强 oiClass 社区活跃度，提升 oiClass 用户的 oi 水平，促进 oier 之间的联结互动，特别开展本公益活动，希望大家踊跃参加。</li><li>oier 水平的提升，不仅在学，更在练，多打比赛无疑是提升水平的有效渠道。</li><li>本次活动由 TYOI 高水平选手进行命题和验题，由 chxulong 把控题目质量，题目难度控制在 CSP-J 水平，对于冲刺本年度 CSP-J 的同学值得参与。</li></ol><h2 id="参赛要求"><a href="#参赛要求" class="headerlink" title="参赛要求"></a>参赛要求</h2><ol><li>所有oiClass用户均可参赛，比赛完全公益，不设门槛，但需要获取一个 oiClass 账号。</li><li>建议具有一定算法基础的同学参赛，比赛对初学者可能不够友好。</li></ol><h2 id="比赛安排"><a href="#比赛安排" class="headerlink" title="比赛安排"></a>比赛安排</h2><p>比赛时间为每周五晚19：00——22：00，具体安排如下，如有更改则在本页面直接更正</p><table><thead><tr><th>周次</th><th>时间</th><th>负责人</th></tr></thead><tbody><tr><td>1</td><td>2月23日</td><td>赵哲宇</td></tr><tr><td>2</td><td>3月1日</td><td>倪穗霆</td></tr><tr><td>3</td><td>3月8日</td><td>曾奂霖</td></tr><tr><td>4</td><td>3月15日</td><td>李轩楠</td></tr><tr><td>5</td><td>3月22日</td><td>杨瀚钧</td></tr><tr><td>6</td><td>3月29日</td><td>施启浩</td></tr><tr><td>7</td><td>4月5日</td><td>韩璨东</td></tr><tr><td>8</td><td>4月12日</td><td>于善恩</td></tr><tr><td>9</td><td>4月19日</td><td>李沂铮</td></tr><tr><td>10</td><td>4月26日</td><td>周乐</td></tr><tr><td>11</td><td>5月3日</td><td>郑轼</td></tr><tr><td>12</td><td>5月10日</td><td>马明轩</td></tr><tr><td>13</td><td>5月17日</td><td>张宇轩</td></tr><tr><td>14</td><td>5月24日</td><td>徐静雨</td></tr><tr><td>15</td><td>5月31日</td><td>熊君恺</td></tr><tr><td>16</td><td>6月7日</td><td>苏昱霖</td></tr><tr><td>17</td><td>6月14日</td><td>何致远</td></tr><tr><td>18</td><td>6月21日</td><td>王梓傲</td></tr><tr><td>19</td><td>6月28日</td><td>赵子瑜</td></tr><tr><td>20</td><td>7月5日</td><td>代浦圆</td></tr></tbody></table><h2 id="如何获取-oiClass-账号"><a href="#如何获取-oiClass-账号" class="headerlink" title="如何获取 oiClass 账号"></a>如何获取 oiClass 账号</h2><p>本OJ因为成本问题，采取付费注册机制。有意注册请扫描以下二维码了解注册信息。 </p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/vzvmYv84WHzzIex-jYKP8.png" srcset="/img/loading.gif" lazyload></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>本OJ采用实名制，所有账号需备注个人真实信息（含学校和个人真实姓名），否则将会被拉入账号黑名单！如果您的账号被拉入了黑名单，请发邮件至oiclass@qq.com联系。</li><li>使用本网站，请更新您的邮件地址。邮件地址可用于忘记密码时更改密码</li></ul><h3 id="修改自己的真实姓名"><a href="#修改自己的真实姓名" class="headerlink" title="修改自己的真实姓名"></a>修改自己的真实姓名</h3><ol><li>请点击右上角用户下拉列表，点击“@oiclass”按钮 <img src="https://cdn.jsdmirror.com/gh/lixuannan/img/lF7By18t500oa-icYvgEA.png" srcset="/img/loading.gif" lazyload></li><li>在“显示名”栏填写自己的真实姓名 <img src="https://cdn.jsdmirror.com/gh/lixuannan/img/sT5Es3qYPUHdRjuHeb27p.png" srcset="/img/loading.gif" lazyload></li></ol><h3 id="修改自己的学校信息"><a href="#修改自己的学校信息" class="headerlink" title="修改自己的学校信息"></a>修改自己的学校信息</h3><ol><li>请点击右上角用户下拉列表，点击“账户设置” <img src="https://cdn.jsdmirror.com/gh/lixuannan/img/b_C1-lAsh26lXE-tnEhQI.png" srcset="/img/loading.gif" lazyload></li><li>在个人信息页面 “school”栏填写个人真实学校名称 <img src="https://cdn.jsdmirror.com/gh/lixuannan/img/iUHGe1WDLSE1ORee6wxxu.png" srcset="/img/loading.gif" lazyload></li></ol><p>邮箱地址用户忘记密码时重置密码使用，请及时更改您的邮箱地址</p><ol><li>请点击右上角用户下拉列表，点击“安全设置” <img src="https://cdn.jsdmirror.com/gh/lixuannan/img/mi3sKGajXXbqTp1Aj4fhs.png" srcset="/img/loading.gif" lazyload></li><li>在安全设置页面根据提示更新邮箱。注意，下图新邮箱中的”oiclass@qq.com”只是示例，请填写你自己的真实邮箱。如果不能成功接收到邮箱链接，那一定是邮箱地址没有正确填写。 <img src="https://cdn.jsdmirror.com/gh/lixuannan/img/pBqKj9l-tSbPW9SLlW9Dt.png" srcset="/img/loading.gif" lazyload></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>OiClass</tag>
      
      <tag>宣传</tag>
      
      <tag>公益赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>洛谷 P10170 [DTCPC 2024] 小方和小立方 题解</title>
    <link href="/posts/14032.html"/>
    <url>/posts/14032.html</url>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一眼看上去，这题非常非常的难，对吧？？？好吧，我的第一反应就是 DP，但是 DP 似乎并不能非常优雅的解决问题。然后我就想到了马拉车，但是马拉车+特判实现起来实在是有些繁琐。</p><p>突然，我猛地发现，如果每个字母的出现次数不超过 $2$ 次的话，回文串的长度最多就是 $52$。也就是说，暴力的时间大约是 $O(52n)$，很显然，这是可以非常轻松通过的。那么我们只需要枚举回文串的中心，然后逐步向两边扩展，直到不能扩展为止。对于这种暴力的思路都能通过的题目，我只能说文字游戏一点都不好完（赛时浪费了接近 $1.5h$）。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现实际上也没有什么难度，按照思路简单的写一下即可。不过需要注意的是下表的处理，注意不要越界和重复即可。判重的话，我个人用的是 <code>map</code>，可以轻松的通过，不过闲着没事干的也可以手写哈希，应该能快很多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string s;<br><span class="hljs-type">char</span> ch;<br><span class="hljs-type">int</span> a[<span class="hljs-number">30</span>];<br>map&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, <span class="hljs-type">bool</span>&gt; mp;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">check</span><span class="hljs-params">(string ss)</span> </span>&#123;<br>    <span class="hljs-comment">// cout &lt;&lt; ss &lt;&lt; endl;</span><br>    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> a);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> i: ss) &#123;<br>        a[i - <span class="hljs-string">&#x27;a&#x27;</span>] += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (a[i - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    string sp = ss;<br>    <span class="hljs-built_in">reverse</span>(sp.<span class="hljs-built_in">begin</span>(), sp.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> ss == sp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">int</span> l = i, r = i;<br>        ans += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> p = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span> (r != s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>                r += <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (!mp[&#123;l, r&#125;]) &#123;<br>                    p = <span class="hljs-built_in">check</span>(s.<span class="hljs-built_in">substr</span>(l, r - l + <span class="hljs-number">1</span>));<br>                    <span class="hljs-keyword">if</span> (p == <span class="hljs-number">1</span>) &#123;<br>                        mp[&#123;l, r&#125;] = <span class="hljs-literal">true</span>;<br>                        ans += <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (l != <span class="hljs-number">0</span>) &#123;<br>                l -= <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (!mp[&#123;l, r&#125;]) &#123;<br>                    p = <span class="hljs-built_in">check</span>(s.<span class="hljs-built_in">substr</span>(l, r - l + <span class="hljs-number">1</span>));<br>                    <span class="hljs-keyword">if</span> (p == <span class="hljs-number">1</span>) &#123;<br>                        mp[&#123;l, r&#125;] = <span class="hljs-literal">true</span>;<br>                        ans += <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <br>            <span class="hljs-keyword">if</span> (r != s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; l != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!mp[&#123;l, r&#125;]) &#123;<br>                    p = <span class="hljs-built_in">check</span>(s.<span class="hljs-built_in">substr</span>(l, r - l + <span class="hljs-number">1</span>));<br>                    <span class="hljs-keyword">if</span> (p == <span class="hljs-number">1</span>) &#123;<br>                        mp[&#123;l, r&#125;] = <span class="hljs-literal">true</span>;<br>                        ans += <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>洛谷 P10160 [DTCPC 2024] Ultra 题解</title>
    <link href="/posts/52460.html"/>
    <url>/posts/52460.html</url>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个01串，可以将串中的 <code>1010101...010101</code> 替换为 <code>0101010...101010</code> 反之亦然。求可能的最小的 <code>1</code> 的数量。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们可以发现，如果有连续的多个（$\geq2$）$0$，那么我们不可能将连续 $0$ 左侧或右侧的一起处理。因此，为了方便，我们可以将左右两侧分开处理。当我们将左右两侧分到无法再分的程度时，我们再次观察。</p><p>容易发现，去除两侧的前导零和后缀零之后，如果剩下的部分中仍有 $0$，那么这个部分一定可以被化简为只有 $1$ 个 $1$ 的串；如果没有 $0$，那么这个部分不能再被任何方式化简，故该部分的 $1$ 的数量为剩余的部分的长度。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这道题的实现有一个巨大的坑。我们考虑使用 DFS 来处理。一开始，我将待处理的字符串作为参数传递进去，但是很显然这样会占用大量的内存，我赛时就是没有注意到这一点导致了 MLE 遗憾离场。为了解决这样的问题，我们可以只传递起始和结尾的下标，然后共用全局的字符串。这样就可以非常有效的避免 MLE 的问题，轻松又愉快的 AC。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, a, b, cnt, ccnt, ans;<br>string s;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = L; i &lt; R; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">dfs</span>(L, i - cnt);<br>                <span class="hljs-built_in">dfs</span>(i, R);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            cnt = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cnt += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> l = L, r = R - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; l &lt; R &amp;&amp; s[l] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        l += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; r &gt;= L &amp;&amp; s[r] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        r -= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            ans += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    ans += r - l + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; s;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>());<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass PU2TI P3791 棋子题解</title>
    <link href="/posts/53556.html"/>
    <url>/posts/53556.html</url>
    
    <content type="html"><![CDATA[<h1 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h1><p>我们可以优先考虑以下的三情况：</p><ul><li><code>1 2 3</code> 此时我们会发现 <code>1</code> 和 <code>2</code>  挡住了 <code>3</code> ，那么此时 <code>1</code> 和 <code>2</code> 必然将先死一个。</li><li><code>1 3 5</code> 此时我们会发现所有棋子都可以先死，因此方案数为棋子数的全排列数，即其阶乘。</li><li><code>1 2 4</code> 此时 <code>1</code> 和 <code>2</code> 挡住了 <code>4</code> ，只要 <code>1</code> 或 <code>2</code> 先死一个，那么后面的就可以按照方案二的情况来计算。</li></ul><p>因此我们可以考虑维护一个像方案二一样的 <code>1 3 5 7 9 ...</code> 的序列，然后统计答案。</p><p>我们可以将答案分为两种情况统计：</p><ul><li>$a_i &#x3D; 2i$ ，此时我们要让前一个先挂掉，然后序列不变</li><li>$a_i \ne 2i$ ，此时统计方案数</li></ul><h3 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC Code :"></a>AC Code :</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, ans = <span class="hljs-number">1</span>, a[<span class="hljs-number">100009</span>];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> last = <span class="hljs-number">1</span>, cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] != last + <span class="hljs-number">1</span>) &#123;<br>            last += <span class="hljs-number">2</span>;<br>            cnt += <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans = ans * (cnt + <span class="hljs-number">1</span>) % <span class="hljs-number">1000000007</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cnt; i++) &#123;<br>        ans = ans * i %  <span class="hljs-number">1000000007</span>;<br>    &#125;<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF985C 题解</title>
    <link href="/posts/14038.html"/>
    <url>/posts/14038.html</url>
    
    <content type="html"><![CDATA[<h1 id="建议升绿"><a href="#建议升绿" class="headerlink" title="建议升绿"></a>建议升绿</h1><p>这道题是一道贪心。很容易想到，我们你需要先进行一次排序，然后再进行一些操作。</p><p>首先我们可以排除无解的情况，当<strong>第 $n$ 短的木板的长度</strong>与<strong>最短的木板的长度之差</strong> $&gt; l$ 时，不可能有任何一种符合题意的方案。这个很好证，有兴趣的朋友可以自己证一下。</p><p>然后我们考虑如何制定一个合理的贪心计划。首先我们可以尝试确定一个最大的桶大小，这对后面的操作有很大的帮助。很显然，最大的桶大小就是与最短木板长度的差 $\leq l$ 的最大的一块木板。然后我们可以优先构造大小为最大大小的木桶，设此时找到的代表着最大溶剂的木板的下表为 $p$ ，我们应该尝试让长度 $\geq a_p$ （$a$ 数组为木板长度的数组）的木板 $p$ 进行配对，同时更新最大长度的下标（即 <code>p -= 1</code>）。 </p><p>然后我们可以简单的统计一下剩下的桶的大小，求和即可。</p><h3 id="AC-Code-："><a href="#AC-Code-：" class="headerlink" title="AC Code ："></a>AC Code ：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, k, t, ans, a[<span class="hljs-number">100009</span>];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n &gt;&gt; k &gt;&gt; t;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n * k; i++) &#123;<br>cin &gt;&gt; a[i];<br>&#125;<br><span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n * k + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (a[n] - a[<span class="hljs-number">1</span>] &gt; t) &#123;<br>cout &lt;&lt; <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> p = n * k, cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (a[p] - a[<span class="hljs-number">1</span>] &gt; t) &#123;<br>p -= <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n * k, j = p; i &gt;= p + k; i -= (k - <span class="hljs-number">1</span>), j -= <span class="hljs-number">1</span>, cnt += <span class="hljs-number">1</span>) &#123;<br>ans += a[j];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= p - cnt; i += k) &#123;<br>ans += a[i];<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass PU2TI P3846 杨辉三角题解</title>
    <link href="/posts/9065.html"/>
    <url>/posts/9065.html</url>
    
    <content type="html"><![CDATA[<h1 id="打表-卡常题"><a href="#打表-卡常题" class="headerlink" title="打表+卡常题"></a>打表+卡常题</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不难发现，最短路径不外乎以下两种可能：</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img//image-20231216150315312.png" srcset="/img/loading.gif" lazyload alt="image-20231216150315312"></p><p>一种是先一直向下，再一直向右下；而另一种是先一直右下再一直向下。对于 $k \leq \frac{n}{2}$ 的请况，很显然是选择第一种路线，否则是第二种路线。</p><p>我们可以通过一个简单的技巧来将两种路线合一，我们可以发现，其实第二种情况相当于第一种情况中将 $k$ 改为 $n - k + 1$ 的情况（像抬杠的可以自己去算一下，这个是真的，怎么证的还在想）。那么我们可以只考虑第一种情况。</p><p>首先是值为 $1$ 的那一段路径，很容易发现，由于他是走到 $n - k$ 层的，因此这段路径的数字之和为 $1 \times (n - k)&#x3D;n - k$ 。接下来考虑如何计算剩下部分的数字和。没有头绪？那就打表吧！于是我们对于从 $(1,, n - k)$ 到 $(n, k)$ 的路径和记为 $f_{n,, k}$ ，我们可以计算出这样的一个 $f$ 数组：</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img//image-20231216152605743.png" srcset="/img/loading.gif" lazyload alt="image-20231216152605743"></p><p> 有眼睛就能看出来，$f_{i,,j} &#x3D; {i \choose j-1}$ 。那么这就好办了啊，直接计算即可！</p><p>但是怎么算呢？我们如果直接计算组合数，很明显复杂度（含逆元的计算）是 $\mathcal{O}(k\log p)$ 的。在题目 $1 \leq n, k, p \leq 10^9$ 的数据范围下，你不超时谁超时（除非评测机单核性能起飞）！那么我们此时可以考虑使用 <strong><a href="https://oi.wiki/math/number-theory/lucas/">Lucas 定理</a></strong> ，下面简述一下 Lucas 定理的内容（$p$ 为质数）：<br>$$<br>{\rm Lucas}(n,, m,,p) &#x3D; {n \choose m}, {\rm mod},p &#x3D; \left{ \begin{array}{l}1,,,,,m&#x3D;0<br>\newline<br>{n, {\rm mod} ,p \choose m,{\rm mod, p}} \times {\rm Lucas}(n \div p,, m \div p,, p),{\rm mod} , p \end{array}<br>\right.<br>$$<br>通过这个定理，我们可以在 $\mathcal{O}(\log ^2 p)$ 左右的时间求出组合数取模的值（含逆元）。</p><p>下面我们再来讲一下其中的组合数又要怎么求？</p><p>我们可以将正常的组合数程序加上取模，就像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> p)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (n &lt; m) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (m &gt; n - m) &#123;<br>m = n - m;<br>&#125;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>; <span class="hljs-comment">// a 为分子、b 为分母</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>a = (a * (n - i)) % p;<br>b = (b * (i + <span class="hljs-number">1</span>)) % p;<br>&#125;<br><span class="hljs-keyword">return</span> ((a % p) / (b % p)) % p;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后尝试带入某一个数，然后……错啦啊啊啊！原因也非常的简单，我们考虑此时有两个数：$a&#x3D;4$，$b&#x3D;2$，计算 $a \div b , {\rm mod} , 2$ 的值，如果先将分子分母取模，那么直接就无意义了，但是很显然这个式子的答案为 $0$ 。</p><p>为了解决这个问题，我们将引入一个东西，称为**<a href="https://oi.wiki/math/number-theory/inverse/">逆元</a><strong>。我们可以这样理解，根据小学的知识，除以一个数等于乘以它的倒数，也就是说 $a \div b &#x3D; a \times \frac{1}{b}$ 。而我们假设 $x$ 的倒数为 $\frac{1}{x}$ ，很容易发现 $x \times \frac{1}{x} &#x3D; 1$ 。也就是说，我们可以这样定义：</strong>一个数和另一个数的乘积为 $1$ ，则成这两个数互为倒数**。那么我们可以尝试将这个概念往模运算推广，我们可以尝试定义一个模 $p$ 意义下的倒数，假定 $x$ 为 $a$ 的倒数，那么：<br>$$<br>ax \equiv 1, {\rm mod}, p<br>$$<br>此时我们称 $x$ 为 $a$ 的乘法逆元，记为 $a^{-1}$ 。</p><p>那么下一步我们考虑如何求解乘法逆元，根据 <strong><a href="https://oi.wiki/math/number-theory/fermat/#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86">费马小定理</a></strong> ，我们可以得知：<strong>若 $p$ 为质数且 $a$ 与 $p$ 互质（$\gcd(a,, p)&#x3D;1$），则 $a^{p-1} \equiv 1,{\rm mod} , p$</strong> 。又因为 $ax \equiv 1 ,{\rm mod} ,p$ ，所以 $ax \equiv a^{p-1},{\rm mod} , p$ 。又根据 <strong><a href="https://oi.wiki/math/number-theory/basic/#%E5%90%8C%E4%BD%99">同余的性质</a></strong> ，可知 $x \equiv a^{p-2} , {\rm mod }, p$ 。至此，我们可以再次化简以下，借助同余方程的一个特殊解，计算出 $a$ 在模 $p$ （$p$ 为质数）意义下的逆元，即 $a^{-1} &#x3D; a^{p - 2}$ 。</p><p>根据上面的式子，我们就可以在 $\mathcal{O} (\log p)$ 的时间复杂度内计算出逆元（借助**<a href="https://oi.wiki/math/binary-exponentiation/">快速幂</a>**）。那么我们就可以将组合数的代码改成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> p)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (n &lt; m) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (m &gt; n - m) &#123;<br>m = n - m;<br>&#125;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>a = (a * (n - i)) % p;<br>b = (b * (i + <span class="hljs-number">1</span>)) % p;<br>&#125;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(a * <span class="hljs-built_in">qpow</span>(b, p - <span class="hljs-number">2</span>, p)) % p;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们已经完成了题目的所有推导，实现即可。</p><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><p>看起来，我们只需要在模板的基础上，调用一下函数输出即可。但是，如果你提交一下就会发现，你获得了 $40 \rm pts$ 的好成绩！啊？！不是时间复杂度能过吗？是的，但是需要常数优化！</p><p>我们观察一下代码，发现其中包含大量的递归及除法（含取模）内容。对于 <code>long long</code> $64$ 位的大小来说，这些除法和内存寻址实在是太慢啦！因此，我们只需要关闭 <code>long long</code> 即可 <span style="color: green">AC</span> </p><h3 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC Code :"></a>AC Code :</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">//#define int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span> </span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>a %= p;<br><span class="hljs-keyword">while</span> (b) &#123;<br><span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) &#123;<br>ans = (ans * a) % p;<br>&#125;<br>b &gt;&gt;= <span class="hljs-number">1</span>;<br>a = (a * a) % p;<br>&#125;<br><span class="hljs-keyword">return</span> ans % p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> p)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (n &lt; m) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (m &gt; n - m) &#123;<br>m = n - m;<br>&#125;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>a = (a * (n - i)) % p;<br>b = (b * (i + <span class="hljs-number">1</span>)) % p;<br>&#125;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(a * <span class="hljs-built_in">qpow</span>(b, p - <span class="hljs-number">2</span>, p)) % p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Lucas</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> p)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">C</span>(n % p, m % p, p) * <span class="hljs-built_in">Lucas</span>(n / p, m / p, p)) % p;<br>&#125;<br><br><span class="hljs-type">int</span> t, n, m, p;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin &gt;&gt; t;<br><span class="hljs-keyword">while</span> (t--) &#123;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;<br>n += <span class="hljs-number">1</span>;<br>m += <span class="hljs-number">1</span>;<br>m = <span class="hljs-built_in">min</span>(m, n - m + <span class="hljs-number">1</span>);<br>cout &lt;&lt; (n - m + <span class="hljs-built_in">Lucas</span>(n, m - <span class="hljs-number">1</span>, p)) % p &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSP 2023 游记</title>
    <link href="/posts/13733.html"/>
    <url>/posts/13733.html</url>
    
    <content type="html"><![CDATA[<h1 id="终于想起来"><a href="#终于想起来" class="headerlink" title="终于想起来"></a>终于想起来</h1><p>好吧，鸽了怎么久，还是要来写一下的</p><h2 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h2><h3 id="赛时"><a href="#赛时" class="headerlink" title="赛时"></a>赛时</h3><p>初赛那天上午，我很早就到了广大附。走进去之后，发现一个 TYOIer 都没有，然后就在门口等队友。吹着上午凛冽的秋风，等啊等，发现他们怎么一直不来啊啊啊啊啊。等到离可以进考场还有 $5$ 分钟的时候，我就自己走进去了，孤独，又无助。</p><p>后来等到考试快要开始，我们的其他队员才陆陆续续地到，听说是因为堵车了（笑死）。</p><p>对于早上入门组的初赛，我个人感觉是很好的（但是后来并不这么认为），除了哈夫曼编码的那道选择题和最后一道二分码风很不习惯之外。感觉轻松过线。心情好的一批 。</p><p>中午去广工食堂吃饭，感觉比铁一的要好吃太多！顺便买了一杯蜜雪冰城，甚至他还帮我打多了一杯，后来退钱了。</p><p>下午的提高组比赛，感觉难度略有提升，但是程序填空题终于有正经算法啦啦啦啦啦！做起来也是相当舒服。</p><h3 id="赛后"><a href="#赛后" class="headerlink" title="赛后"></a>赛后</h3><p>赛后发现自己成为最大 joker ，入门组 $63 \rm pts$ ，提高组 $68 \rm pts$ 。笑死，入门组差点全班最低，提高组全班最高。被嘲讽只会打提高（他们开玩笑说我打到 AKIOI 都拿不到入门组一等奖）</p><p>不过理性分析一下，还是因为程序填空那个二分奇特的书写风格，真的对我误导很大啊啊啊！</p><h2 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h2><p>由于我是一个<del>人才</del>，所以无缘了入门组，只能打提高了。</p><p>那天下午天气不是很好，刚下完雨，路上很湿滑。我们到广大附门口集中，老师给每个人都派了一个红包，感觉是送死前的最后一丝安慰（尽管我直到比赛结束都没有打开它）。</p><p>进去先签了一份 CCF 的协议书，然后开赛！</p><h3 id="赛时-1"><a href="#赛时-1" class="headerlink" title="赛时"></a>赛时</h3><h4 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h4><p>感觉 T1 是一个一眼题，一眼 Mid in the middle。想了大约 5 分钟，意识到好像这题随便搞一下多重循环加超级特判就可以在有 $8$ 倍常数的 $O(10^n)$ 下通过了。事实也确实如此。轻松拿下 T1，感觉去年的题目水很多，信心拉满。</p><p>顺便附上我丑陋的赛时代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br>string a[<span class="hljs-number">10</span>];<br>set&lt;string&gt; s;<br>map&lt;string, <span class="hljs-type">bool</span>&gt; mp[<span class="hljs-number">10</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">while</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>x += <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">9</span>) &#123;<br>x -= <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> x;<br>&#125; <br><br><span class="hljs-function">string <span class="hljs-title">work</span><span class="hljs-params">(string ori, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> turn, <span class="hljs-type">int</span> len)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;<br>ori[pos] = <span class="hljs-built_in">calc</span>(ori[pos] - <span class="hljs-string">&#x27;0&#x27;</span> + turn) + <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">2</span>) &#123;<br>ori[pos] = <span class="hljs-built_in">calc</span>(ori[pos] - <span class="hljs-string">&#x27;0&#x27;</span> + turn) + <span class="hljs-string">&#x27;0&#x27;</span>;<br>ori[pos + <span class="hljs-number">1</span>] = <span class="hljs-built_in">calc</span>(ori[pos + <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span> + turn) + <span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ori;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> p, string s)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">9</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">4</span>) &#123;<br><span class="hljs-comment">//if (s[i] + j &lt;= &#x27;9&#x27; &amp;&amp; s[i + 1] + j &lt;= &#x27;9&#x27;) &#123;</span><br>string sp = <span class="hljs-built_in">work</span>(s, i, j, <span class="hljs-number">2</span>);<br>mp[p][sp] = <span class="hljs-literal">true</span>;<br>::s.<span class="hljs-built_in">insert</span>(sp);<br><span class="hljs-comment">//cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; sp &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//if (s[i] - j &gt;= &#x27;0&#x27; &amp;&amp; s[i + 1] - j &gt;= &#x27;0&#x27;) &#123;</span><br>sp = <span class="hljs-built_in">work</span>(s, i, -j, <span class="hljs-number">2</span>);<br>mp[p][sp] = <span class="hljs-literal">true</span>;<br>::s.<span class="hljs-built_in">insert</span>(sp);<br><span class="hljs-comment">//cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; sp &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br>&#125;<br><span class="hljs-comment">//if (s[i] + j &lt;= &#x27;9&#x27;) &#123;</span><br>string sp = <span class="hljs-built_in">work</span>(s, i, j, <span class="hljs-number">1</span>);<br>mp[p][sp] = <span class="hljs-literal">true</span>;<br>::s.<span class="hljs-built_in">insert</span>(sp);<br><span class="hljs-comment">//cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; sp &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//if (s[i] - j &gt;= &#x27;0&#x27;) &#123;</span><br>sp = <span class="hljs-built_in">work</span>(s, i, -j, <span class="hljs-number">1</span>);<br>mp[p][sp] = <span class="hljs-literal">true</span>;<br>::s.<span class="hljs-built_in">insert</span>(sp);<br><span class="hljs-comment">//cout &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; sp &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// freopen(&quot;lock.in&quot;, &quot;rt&quot;, stdin);</span><br><span class="hljs-comment">// freopen(&quot;lock.out&quot;, &quot;wt&quot;, stdout);</span><br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>cin &gt;&gt; ch;<br>a[i] += ch;<br>&#125;<br><span class="hljs-built_in">search</span>(i, a[i]);<br>&#125;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (string i: s) &#123;<br><span class="hljs-comment">//cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; mp[i] &lt;&lt; endl;</span><br><span class="hljs-type">bool</span> p = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>p &amp;= mp[j][i];<br><span class="hljs-comment">//cout &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; (mp[j][i] ? &quot;yes&quot; : &quot;no&quot;) &lt;&lt; endl;</span><br>&#125;<br>ans += p;<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h4><p>看起来像是 DP，但是不知道怎么搞。写了一个暴力+特殊性质拿下 $35\rm pts$。</p><h4 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h4><p>感觉就是一个大模拟（尽管后来我知道需要一定的优化），直接开打！打了半个小时，发现理解错题意_(¦3」∠)_。没办法，Ctrl-a + Backspace。重新打，还是遇到了一些问题，好在都很容易发现，简单调了 $20$ 分钟的样子，过了几乎所有样例（最后一个 TLE+MLE，直接让电脑死机半个小时）。很不幸的是，我的电脑在运行最后一个样例的时候爆内存了，直接死机半个小时。而且我 T4 题面一点没看，大寄特寄。最终估分 $0$。</p><h4 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h4><p>开 T4 的时候比赛还剩下 $45$ 分钟，感觉有点慌。看了一眼题目，感觉暴力的难度和码量应该不低于正解，由于太菜，根本不想写。看了一眼特殊性质，感觉也很难入手。不过，转念一想，就 CCF 的数据强度，随便乱搞说不定能一点点分数。于是我首先假设所有的数从第一天开始就一直在长，然后依题意一直模拟，直到出现答案。但是还有一个特判，就是如果计算的次数过多（即将 TLE），直接输出当前答案加上一个随机数。预估 $0 \rm pts$。</p><h3 id="赛后-1"><a href="#赛后-1" class="headerlink" title="赛后"></a>赛后</h3><p>不出所料，CCF 的高质量数据成功的让我的 T4 乱搞代码拿到了 $10 \rm pts$ 的好成绩。T3 也出人意料的通过了所有的特殊性指点，以 TLE $65\rm pts$ 的震惊成绩让我十分佩服今年 CCF 的出题人。T1、T2 发挥的十分异常，居然一分都没有周，最终超常发挥总分 $210$ 拿下一等。</p><p>总结一下，<del>我爱 CCF</del>这场比赛数据还是水了点，然后就是 T3 的大模拟我很满意，十分符合我的胃口。一年就拿下提高一等还是很爽的，顺带附赠了 NOIP 的入场券，大喜！</p>]]></content>
    
    
    
    <tags>
      
      <tag>游记</tag>
      
      <tag>CSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AT_zone2021_e 题解</title>
    <link href="/posts/41815.html"/>
    <url>/posts/41815.html</url>
    
    <content type="html"><![CDATA[<h1 id="AT-zone2021-e"><a href="#AT-zone2021-e" class="headerlink" title="AT_zone2021_e"></a>AT_zone2021_e</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>由于洛谷的题意太不好理解了，我是看了英文题面才理解的。下面简述一下题意：</p><blockquote><p>首先题目给定两个数 $R$ 和 $C$ ，同时给定两个数组 $A$ 和 $B$，$A$ 的大小是 $R \times C - 1$ ，$B$ 的大小是 $R - 1 \times C$ 。然后计算点 $(1,, 1)$ 到点 $(R,, C)$ 的最短路径。</p><p>其中，假定当前的点为 $(i, , j)$ ，那么有几种移动的方式：</p><ul><li><p>移动到 $(i,, j+1)$，花费为 $A_{i,,j}$。需要保证 $j&lt;C$。</p></li><li><p>移动到 $(i,, j-1)$，花费为 $A_{i,,j-1}$。需要保证 $j\ge 2$。</p></li><li><p>移动到 $(i+1,, j)$，花费为 $B_{i,,j}$。需要保证 $i&lt;R$。</p></li><li><p>选择一个整数 $k$ 满足 $1\le k&lt;i$，移动到 $(i-k,,j)$，花费为 $(1+k)$。</p></li></ul></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><p>我的第一版思路较为简单。首先我们看一下题目，会发现与 Dijkstra 最短路算法很相似我们直接尝试使用类似 Dijkstra 的算法。我们使用广搜，加上优先队列优化，可以写出时间复杂度较为优秀的算法。</p><h4 id="具体实现方法"><a href="#具体实现方法" class="headerlink" title="具体实现方法"></a>具体实现方法</h4><p>初始化一个数组 $dis$ 为极大值，用于保存点 $(1, , 1)$ 到其余点的最短路径长度。初始化一个优先队列，用于存储节点，注意让长度短的节点处于堆顶。然后进入循环，截止条件为优先队列为空。对于每次循环，取出堆顶，然后按照题目给定的四种移动方式进行松弛操作，逐步的使 $dis$ 数组收敛到最小值，返回即可。</p><p>但是当你打出来的时候，你会发现似乎第四种移动方法会运行的比较慢。不管了，直接交！交完了你会发现实际上这个算法还是比较优秀的，只 TLE 了一个点。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-comment">//#define int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">bool</span> vis[<span class="hljs-number">509</span>][<span class="hljs-number">509</span>];<br><span class="hljs-type">int</span> r, c, a[<span class="hljs-number">509</span>][<span class="hljs-number">509</span>], b[<span class="hljs-number">509</span>][<span class="hljs-number">509</span>], dis[<span class="hljs-number">509</span>][<span class="hljs-number">509</span>];<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; &gt; pq;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">63</span>, <span class="hljs-keyword">sizeof</span> dis);<br>pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, &#123;x, y&#125;&#125;);<br>dis[x][y] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> fx = pq.<span class="hljs-built_in">top</span>().second.first, fy = pq.<span class="hljs-built_in">top</span>().second.second;<br><span class="hljs-comment">//cout &lt;&lt; fx &lt;&lt; &quot; &quot; &lt;&lt; fy &lt;&lt; endl;</span><br>pq.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (vis[fx][fy]) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>vis[fx][fy] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (fy &lt; c &amp;&amp; dis[fx][fy + <span class="hljs-number">1</span>] &gt; dis[fx][fy] + a[fx][fy]) &#123;<br>dis[fx][fy + <span class="hljs-number">1</span>] = dis[fx][fy] + a[fx][fy];<br>pq.<span class="hljs-built_in">push</span>(&#123;-dis[fx][fy + <span class="hljs-number">1</span>], &#123;fx, fy + <span class="hljs-number">1</span>&#125;&#125;);<br>&#125;<br><span class="hljs-keyword">if</span> (fy &gt; <span class="hljs-number">1</span> &amp;&amp; dis[fx][fy - <span class="hljs-number">1</span>] &gt; dis[fx][fy] + a[fx][fy - <span class="hljs-number">1</span>]) &#123;<br>dis[fx][fy - <span class="hljs-number">1</span>] = dis[fx][fy] + a[fx][fy - <span class="hljs-number">1</span>];<br>pq.<span class="hljs-built_in">push</span>(&#123;-dis[fx][fy - <span class="hljs-number">1</span>], &#123;fx, fy - <span class="hljs-number">1</span>&#125;&#125;);<br>&#125;<br><span class="hljs-keyword">if</span> (fx &lt; r &amp;&amp; dis[fx + <span class="hljs-number">1</span>][fy] &gt; dis[fx][fy] + b[fx][fy]) &#123;<br>dis[fx + <span class="hljs-number">1</span>][fy] = dis[fx][fy] + b[fx][fy];<br>pq.<span class="hljs-built_in">push</span>(&#123;-dis[fx + <span class="hljs-number">1</span>][fy], &#123;fx + <span class="hljs-number">1</span>, fy&#125;&#125;);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; fx; i++) &#123;<br><span class="hljs-keyword">if</span> (dis[fx - i][fy] &gt; dis[fx][fy] + <span class="hljs-number">1</span> + i) &#123;<br>dis[fx - i][fy] = dis[fx][fy] + <span class="hljs-number">1</span> + i;<br>pq.<span class="hljs-built_in">push</span>(&#123;-dis[fx - i][fy], &#123;fx - i, fy&#125;&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>cin &gt;&gt; r &gt;&gt; c;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= r; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; c; j++) &#123;<br>cin &gt;&gt; a[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; r; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= c; j++) &#123;<br>cin &gt;&gt; b[i][j];<br>&#125;<br>&#125;<br><span class="hljs-built_in">bfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cout &lt;&lt; dis[r][c];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h3><p>考虑如何优化第一版的算法。我们考虑一下，第一版的时间复杂度是 $O(|E|\log|E|)$ ，而 $|E|$ 可以达到 $3 \times R^2 \times C$ 的级别，又因为 $2 \leq R,, C \leq 500$ ，所以总时间复杂度可以达到 $10^{10}$ 的级别，这是绝对无法通过的。但是由于算法本身已经足够优秀了。我们只需要考虑做一些简单的优化。</p><p>此时我们可以考虑剪枝，由于图中的边权较为固定（除了第四种操作），因此可以考虑计算出答案就返回。这种剪枝方法可以在保证答案无误的情况下，大幅度的调程序运行的效率。</p><p>尝试加入剪枝后，你就可以较为轻松的 <span style="color: #2D2">AC</span> 。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-comment">//#define int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">bool</span> vis[<span class="hljs-number">509</span>][<span class="hljs-number">509</span>];<br><span class="hljs-type">int</span> r, c, a[<span class="hljs-number">509</span>][<span class="hljs-number">509</span>], b[<span class="hljs-number">509</span>][<span class="hljs-number">509</span>], dis[<span class="hljs-number">509</span>][<span class="hljs-number">509</span>];<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; &gt; pq;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">63</span>, <span class="hljs-keyword">sizeof</span> dis);<br>pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, &#123;x, y&#125;&#125;);<br>dis[x][y] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> fx = pq.<span class="hljs-built_in">top</span>().second.first, fy = pq.<span class="hljs-built_in">top</span>().second.second;<br><span class="hljs-comment">//cout &lt;&lt; fx &lt;&lt; &quot; &quot; &lt;&lt; fy &lt;&lt; endl;</span><br>pq.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (fx == r &amp;&amp; fy == c) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (vis[fx][fy]) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>vis[fx][fy] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (fy &lt; c &amp;&amp; dis[fx][fy + <span class="hljs-number">1</span>] &gt; dis[fx][fy] + a[fx][fy]) &#123;<br>dis[fx][fy + <span class="hljs-number">1</span>] = dis[fx][fy] + a[fx][fy];<br>pq.<span class="hljs-built_in">push</span>(&#123;-dis[fx][fy + <span class="hljs-number">1</span>], &#123;fx, fy + <span class="hljs-number">1</span>&#125;&#125;);<br>&#125;<br><span class="hljs-keyword">if</span> (fy &gt; <span class="hljs-number">1</span> &amp;&amp; dis[fx][fy - <span class="hljs-number">1</span>] &gt; dis[fx][fy] + a[fx][fy - <span class="hljs-number">1</span>]) &#123;<br>dis[fx][fy - <span class="hljs-number">1</span>] = dis[fx][fy] + a[fx][fy - <span class="hljs-number">1</span>];<br>pq.<span class="hljs-built_in">push</span>(&#123;-dis[fx][fy - <span class="hljs-number">1</span>], &#123;fx, fy - <span class="hljs-number">1</span>&#125;&#125;);<br>&#125;<br><span class="hljs-keyword">if</span> (fx &lt; r &amp;&amp; dis[fx + <span class="hljs-number">1</span>][fy] &gt; dis[fx][fy] + b[fx][fy]) &#123;<br>dis[fx + <span class="hljs-number">1</span>][fy] = dis[fx][fy] + b[fx][fy];<br>pq.<span class="hljs-built_in">push</span>(&#123;-dis[fx + <span class="hljs-number">1</span>][fy], &#123;fx + <span class="hljs-number">1</span>, fy&#125;&#125;);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; fx; i++) &#123;<br><span class="hljs-keyword">if</span> (dis[fx - i][fy] &gt; dis[fx][fy] + <span class="hljs-number">1</span> + i) &#123;<br>dis[fx - i][fy] = dis[fx][fy] + <span class="hljs-number">1</span> + i;<br>pq.<span class="hljs-built_in">push</span>(&#123;-dis[fx - i][fy], &#123;fx - i, fy&#125;&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>cin &gt;&gt; r &gt;&gt; c;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= r; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; c; j++) &#123;<br>cin &gt;&gt; a[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; r; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= c; j++) &#123;<br>cin &gt;&gt; b[i][j];<br>&#125;<br>&#125;<br><span class="hljs-built_in">bfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cout &lt;&lt; dis[r][c];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题总体来说还是比较水的，是一个<strong>优先队列优化 BFS</strong> + <strong>剪枝</strong>的还不错的练习题。可以锻炼一下自己的代码能力，毕竟 BFS 写挂的可能性还是非常高的。注意细节和特殊优化即可通过。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>AtCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass PUJI 1353 题解</title>
    <link href="/posts/26966.html"/>
    <url>/posts/26966.html</url>
    
    <content type="html"><![CDATA[<h1 id="贪心-大模拟"><a href="#贪心-大模拟" class="headerlink" title="贪心 + 大模拟"></a>贪心 + 大模拟</h1><h2 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h2><p>你是一名医生，是这家医院有且只有的一个医生。现在有 $n$ 个患者要来手术，每个患者有四个属性：$t$ 指患者到达医院的时间、$a$ 指患者手术后会支付给你的钱、$b$ 指患者所需的手术时间、$p$ 是患者的严重程度，$p$ 越小，患者就越严重。现在如果一个患者看到一个 $p$ 值比他更大的患者正在手术，那么他就会很生气，你就会一分钱也得不到，因此你不希望这种情况发生。现在你需要在 $k$ 的时间内处理一些患者，并使得你所得到的钱最多。注意，如果一个患者的手术还没有完成，你并不能处理其他患者。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先对患者按照严重程度排序，越严重的越靠前。然后在 $1 \sim k$ 的空闲时间中取出一段给这个患者。并将 $1 \sim k$ 的时间分割成另外两端空闲时间（注意要剔除这位患者的治疗时间）。依此类推，使用一个平衡的红黑树维护这样的一个保存空闲时间的数据结构即可。注意细节非常多。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里使用 STL 容器 <code>set</code> 类维护空闲时间（<code>set</code> 就是一个十分平衡的红黑树）。先对病人排序，然后依次处理。注意一个细节，如果删除一个迭代器（<code>set&lt;T&gt;::iterator</code>）所指向的元素，那么这个迭代器将失效，无论你做什么操作，这个迭代器都将指向一个无效的内存。如果把这个迭代器比作指针的话，那么他现在就是一个野指针，我们需要尽可能的避免野指针的出现。毕竟谁也不想 <code>segmentation fault</code> 。其次就是加入元素，当你往 <code>set</code> 中插入元素时，这个迭代器将指向错误的元素，虽然不会 <span style="color: #Ffcc00">RE</span> ，但是你也会喜提 <span style="color: #F00">WA</span> 。这一点我是调了非常久的。然后就是可以用 <code>set</code> 自带的 <code>lower_bound</code> 函数实现元素的快速二分查找，进一步优化代码。</p><p>坑点讲完了之后，<strong>一点都不简单</strong>的实现一下就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">patient</span> &#123;<br><span class="hljs-type">int</span> p, t, a, b;<br>&#125; a[<span class="hljs-number">100009</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(patient a, patient b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a.p &lt; b.p;<br>&#125;<br><br><span class="hljs-type">int</span> n, k, ans;<br>set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; s;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;op.in&quot;</span>, <span class="hljs-string">&quot;rt&quot;</span>, stdin);<br><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;op.out&quot;</span>, <span class="hljs-string">&quot;wt&quot;</span>, stdout);<br>cin &gt;&gt; n &gt;&gt; k;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cin &gt;&gt; a[i].p;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cin &gt;&gt; a[i].t;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cin &gt;&gt; a[i].a;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cin &gt;&gt; a[i].b;<br>&#125;<br><span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>, cmp);<br>s.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">1</span>, k);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt;::iterator it = s.<span class="hljs-built_in">lower_bound</span>(&#123;a[i].t, <span class="hljs-number">0</span>&#125;);<br>set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt;::iterator it2 = it;<br><span class="hljs-keyword">if</span> (it != s.<span class="hljs-built_in">begin</span>()) &#123;<br>it2--;<br>&#125;<br><span class="hljs-keyword">if</span> (it2 -&gt; first &lt;= a[i].t &amp;&amp; a[i].t &lt;= it2 -&gt; second) &#123;<br>it = it2;<br>&#125; <br><span class="hljs-keyword">if</span> (it != s.<span class="hljs-built_in">end</span>()) &#123;<br>a[i].t = <span class="hljs-built_in">max</span>(a[i].t, it -&gt; first);<br><span class="hljs-keyword">if</span> (a[i].t &lt;= it -&gt; second) &#123;<br><span class="hljs-keyword">if</span> (a[i].t &gt;= it -&gt; first) &#123;<br><span class="hljs-type">int</span> l = it -&gt; first, r = it -&gt; second;<br>s.<span class="hljs-built_in">erase</span>(it);<br>s.<span class="hljs-built_in">emplace</span>(l, a[i].t - <span class="hljs-number">1</span>);<br>s.<span class="hljs-built_in">emplace</span>(a[i].t, r);<br>it = s.<span class="hljs-built_in">lower_bound</span>(&#123;a[i].t, <span class="hljs-number">0</span>&#125;);<br>&#125;<br>vector&lt;set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt;::iterator&gt; v;<br><span class="hljs-keyword">while</span> (it != s.<span class="hljs-built_in">end</span>()) &#123;<br><span class="hljs-type">int</span> l = it -&gt; first, r = it -&gt; second;<br><span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &gt;= a[i].b) &#123;<br>ans += a[i].a;<br>s.<span class="hljs-built_in">erase</span>(it);<br><span class="hljs-keyword">if</span> (r - l + <span class="hljs-number">1</span> &gt; a[i].b) &#123;<br>s.<span class="hljs-built_in">emplace</span>(l + a[i].b, r);<br>&#125;<br> <span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>v.<span class="hljs-built_in">push_back</span>(it);<br>it++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt;::iterator j : v) &#123;<br>s.<span class="hljs-built_in">erase</span>(j);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSP 2023 考场注意事项</title>
    <link href="/posts/54120.html"/>
    <url>/posts/54120.html</url>
    
    <content type="html"><![CDATA[<h1 id="考场注意事项"><a href="#考场注意事项" class="headerlink" title="考场注意事项"></a>考场注意事项</h1><h2 id="入场问题"><a href="#入场问题" class="headerlink" title="入场问题"></a>入场问题</h2><p>首先此次 CSP 是从 5 号门（侧门，也就是更靠近广工西区的那个）进。时间：</p><ul><li><strong>J 组</strong> ，早上 7:45 进场，8:10 截止进场，8:25 发卷，11:55 交卷。</li><li><strong>S 组</strong> ，13:30 进场，14:10 截止进场，14:25 发卷，18:25 交卷。</li></ul><h2 id="考试问题"><a href="#考试问题" class="headerlink" title="考试问题"></a>考试问题</h2><p>广附提供了 Noi Linux 2.0 的虚拟机，但是用不明白的还是建议不要用。考场不允许吃东西，但是你可以出去走廊吃（大喜）。考试的时候文件的规则如下。首先你需要建立一个以你的考号为名称的文件夹，注意考号是全大写，中间的分隔符是半角的减号，举个例子，如果你的考号是 GD-S00972，那么你需要建立一个名为 <code>GD-00972</code> 的文件夹。其次，你需要在这个名为 <code>GD-00972</code> 的文件夹之中建立一个文本文档（<code>.txt</code> 文件），在这个文本文档中写下你的个人信息（姓名、考号、考场、座位号、证件号、组别等等）。最后你需要根据题目的要求，建立四个以题目指定名称为名的文件夹，注意是英文小写，不要多加一些空格之类的神奇玩意。在这些文件夹中，你需要存储你的代码，举个例子，这个文件夹的名称为 <code>number</code>，那么你要存储的文件就应该是 <code>number.cpp</code> （对于 C++ 选手）、<code>number.c</code> （对于 C 选手）或 <code>number.pas</code> （对于 Pascal 选手）。</p><p>其次就是注意文件读写。</p><h2 id="奇奇怪怪的细节"><a href="#奇奇怪怪的细节" class="headerlink" title="奇奇怪怪的细节"></a>奇奇怪怪的细节</h2><ol><li>注意不要打错 <code>freopen</code>，真的，会去世的。</li><li>注意不要打错变量名，会挂大分的。</li><li>注意不要轻易下结论，一定要认真看题，注意特殊性质和数据范围。</li><li>造 Hack 的时候要细心一些，严格按照题目给定的数据范围和性质造，不要学 CYY 和 CC 乱造 Hack。</li><li>对于一些奇怪的容器（<code>__int128</code>、<code>ext/***.h</code>之类） 的，不要乱用，要记得<strong>张凯嗯</strong>所犯下的错误，要知道 CCF 的评测机是很菜的。</li><li>注意不要用比较逆天的优化，比如手动开 <code>O2</code> 、<code>O3</code>。包括自行强制开启 <code>avx512</code> 指令集加速浮点运算（有些 CPU 会直接报错）。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>祝大家     <span style="font-size: 120px">AK CSP</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass PUJI 1277 题解</title>
    <link href="/posts/16159.html"/>
    <url>/posts/16159.html</url>
    
    <content type="html"><![CDATA[<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><h2 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h2><p>有 $n$ 个硬币，两位玩家，每次去取 $l \sim r$ 个，取不到者负，都执行最优策略，哪一方必胜？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和显然，这个问题就是博弈论中十分经典的 <strong>Nim 取子问题</strong> 。首先我们发现，对于一种状态，如果后面的任何状态都是必败状态，那么我们可以发现，这个状态就是我们常说的必胜态，因为，无论下一步怎么走，都是无法获胜。而同时，如果一个状态后面有必胜态，那么这个状态就是必败态，因为我们下一步的人可以执行最优策略到达这个必胜态。</p><p>了解了这个思路之后，我们就可以开始写代码了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们可以很轻易的写出像这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t, n, l, r;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> || x &lt; left) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left &lt;= x &amp;&amp; x &lt;= right) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">bool</span> p = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; i++) &#123;<br>        <span class="hljs-keyword">if</span> (x - i &gt;= <span class="hljs-number">0</span>) &#123;<br>            p &amp;= <span class="hljs-built_in">dfs</span>(x - i, left, right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> !p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;<br>        cout &lt;&lt; (<span class="hljs-built_in">dfs</span>(n, l, r) ? <span class="hljs-string">&quot;yes\n&quot;</span> : <span class="hljs-string">&quot;no\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你尝试提交，那么恭喜你的代码拿到了 $0$ 分的好成绩。为什么？代码中的 DFS 实在太垃圾了，导致了严重的时间超限和内存超限。</p><p>我们考虑如何优化。对r于参与游戏的两人，在可取的情况下，他们肯定是拼尽全力的多取的，因此，我们会发现，当 $n \geq l + r$ 时，两人的胜率始终维持在 $50 %$ 。因此，我们会发现只有当 $n \leq l + r$ ，二者的胜率才会有所改变，因此，我们只需要考虑胜率不同的一部分即可。故我们可以将 $n$ 取模 $l + r$ 再进行计算。这样的做法大大缩减了 DFS 函数的时间和空间需求优化了我们程序的性能。同时也能保证答案正确。</p><h3 id="AC-Code："><a href="#AC-Code：" class="headerlink" title="AC Code："></a>AC Code：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t, n, l, r;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> || x &lt; left) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left &lt;= x &amp;&amp; x &lt;= right) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">bool</span> p = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; i++) &#123;<br>        <span class="hljs-keyword">if</span> (x - i &gt;= <span class="hljs-number">0</span>) &#123;<br>            p &amp;= <span class="hljs-built_in">dfs</span>(x - i, left, right);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> !p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;<br>        n %= (l + r);<br>        cout &lt;&lt; (<span class="hljs-built_in">dfs</span>(n, l, r) ? <span class="hljs-string">&quot;yes\n&quot;</span> : <span class="hljs-string">&quot;no\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TYOI 暑假集训游记</title>
    <link href="/posts/8408.html"/>
    <url>/posts/8408.html</url>
    
    <content type="html"><![CDATA[<h1 id="TYOI-暑假集训游记"><a href="#TYOI-暑假集训游记" class="headerlink" title="TYOI 暑假集训游记"></a>TYOI 暑假集训游记</h1><h2 id="比赛复盘"><a href="#比赛复盘" class="headerlink" title="比赛复盘"></a>比赛复盘</h2><h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><table><thead><tr><th align="center">比赛</th><th align="center">排名</th><th align="center">分数</th><th align="center">是否意外</th></tr></thead><tbody><tr><td align="center">2023 tyoi 普及模拟训练 01</td><td align="center">$21$</td><td align="center">$150$</td><td align="center">是</td></tr><tr><td align="center">2023 tyoi 普及模拟训练 02</td><td align="center">$30$</td><td align="center">$220$</td><td align="center">是</td></tr><tr><td align="center">2023 tyoi 普及模拟训练 03</td><td align="center">$13$</td><td align="center">$260$</td><td align="center">否</td></tr><tr><td align="center">2023 tyoi 普及模拟训练（B –&gt; C）</td><td align="center">$5$</td><td align="center">$180$</td><td align="center">是</td></tr><tr><td align="center">2023 tyoi 普及模拟训练 04</td><td align="center">$17$</td><td align="center">$196$</td><td align="center">是</td></tr><tr><td align="center">2023 tyoi 普及模拟训练 05</td><td align="center">$8$</td><td align="center">$420$</td><td align="center">否</td></tr><tr><td align="center">2023 tyoi 普及模拟训练 06</td><td align="center">$15$</td><td align="center">$123$</td><td align="center">否</td></tr><tr><td align="center">2023 tyoi 普及模拟训练 07</td><td align="center">$20$</td><td align="center">$160$</td><td align="center">是</td></tr><tr><td align="center">2023 tyoi 普及模拟训练（B –&gt; C）（LJY）</td><td align="center">$8$</td><td align="center">$310$</td><td align="center">否</td></tr><tr><td align="center">2023 tyoi 普及模拟训练 08</td><td align="center">$21$</td><td align="center">$110$</td><td align="center">是</td></tr><tr><td align="center">2023 tyoi 普及模拟训练 09</td><td align="center">$7$</td><td align="center">$220$</td><td align="center">否</td></tr><tr><td align="center"><strong>平均</strong></td><td align="center">-</td><td align="center">$213.54$</td><td align="center"></td></tr><tr><td align="center"><strong>总和</strong></td><td align="center">-</td><td align="center">$2349$</td><td align="center"></td></tr></tbody></table><h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><p>对于前两场比赛，由于太久没有参加比赛，对比赛的节奏和手感各方面掌握的不是很好。有一些非常简单的解法并没有想到，分数和排名还算是比较意外。但是有一题让我印象很深刻，<strong>2023 tyoi 普及模拟训练 02</strong> T2，这道题很有意思，比赛结束后我发现了我的解法和其余所有人的解法几乎都不相同，但竟然也是对的（$\Huge 大喜$）</p><p>从第三场比赛开始，打比赛的时候就比较有感觉，对于题目的理解就越发深刻，对于自己的成绩，我个人还是认为还算合格。但是这几场比赛下来有一些小问题，还是需要总结一下：</p><ul><li>对于算法的选择：在最短路算法中，如果有负权环，应当选用在数据量大时效率更高的 SPFA 算法（比较见图一），而在没有负权环的图中，对于较为稀疏的图，应使用 Bellman-Ford 算法（比较见图二），而稠密图中 Dijkstra 是更优的选择（没图了） <img src="https://cdn.jsdmirror.com/gh/lixuannan/img//Figure_1.png" srcset="/img/loading.gif" lazyload alt="图一"><img src="https://cdn.jsdmirror.com/gh/lixuannan/img//Figure_2.png" srcset="/img/loading.gif" lazyload alt="图2"></li><li>还有就是输入输出的问题，在 <strong>2023 tyoi 普及模拟训练 05</strong> 中，T3 由于使用了 <code>endl</code> 作为换行，但疏忽了 <code>endl</code> 在换行的同时会刷新缓冲区，从而导致时间超限。后来通过 <code>#define endl &#39;\n&#39;</code> 重载了 <code>endl</code> 的内容，使得 <code>endl</code> 不再刷新缓冲区，解决时间超限的问题</li></ul><p>在最后一周的比赛中，有两场比赛让我感到有些意外，也有些可惜。在 <strong>2023 tyoi 普及模拟训练 08</strong> 中，T3 是很让我遗憾的一道题。在赛时我看到题的第一反应就是分层图最短路，火速打完之后发现却连样例都过不了。查看调试信息后发现最短路计算中所选取的路径存在复用关系的情况，因此会导致答案偏小。在答案错误后，我曾有想过使用题目的正解$\rightarrow$最小生成树，但是我很快否决了这个想法（$\tiny 我是扇贝$），后又想到了贪心，但由于打不出来，最终交上去了分层图最短路的代码，$0\ pts$ $\Huge 寄$ 。 还有一场比赛就是 <strong>2023 tyoi 普及模拟训练 07</strong> ，在这场比赛里，我成功的把<strong>前缀和 + 枚举</strong>的入门红打成了调得半死的<strong>一维 DP</strong>，还爆零啦，再次 $\tiny 我是扇贝$ </p><p>总而言之，这三个星期的模拟赛还是给了我不小的提升的，让我学到了很多新知识，也给我的未来学习指引了一些方向，是我受益匪浅。</p><h2 id="新知识"><a href="#新知识" class="headerlink" title="新知识"></a>新知识</h2><p>这次集训所学习的新知识并不多，主要都与图论相关。就我自身而言，我认为难度最高的是割点与桥的应用，毕竟你很难看出那道题是割点与桥的应用（好像说了跟说了一样）。最为简单的应该是差分约束系统，这也是一个很巧妙的系统。下面简单概括一下各个知识点。</p><ol><li><strong>差分约束系统。</strong>差分约束系统是一个很巧妙的东西。在数学中，这个东西被表示为一个不等式集，就像这样 $\left{\begin{array}{lc}x_1 - x_2 \le c_1 \cr x_2 - x_3 \le c_2 \cr \vdots \ \ \ \ \ \ \ \ \ \vdots \ \ \ \ \ \ \ \ \vdots \cr x_{n - 2} - x_{n - 1} \le c_{n - 1} \cr x_{n - 1} - x_{n} \le c_n\end{array}\right.$ 而这个不等式组稍微移项一下又可以变成这样 $\left{\begin{array}{lc}x_1 \le c_1 + x_2  \cr x_2 \le c_2 + x_3 \cr \vdots \ \ \ \ \ \ \ \ \ \vdots \ \ \ \ \ \ \ \ \vdots \cr x_{n - 2}  \le c_{n - 1} + x_{n - 1} \cr x_{n - 1} \le c_n + x_{n}\end{array}\right.$ ，这就和最短路算法中的<strong>松弛</strong>过程的条件很相似，那么我们是否可以使用常见的最短路算法（Dijkstra、SPFA）来解决这个问题呢？答案是肯定的，只需要根据约束条件建图，再跑一遍最短路算法，你就可以求得一组可能的解（无解情况除外），我想说，这真的 $\Huge 泰裤辣$ 。</li><li><strong>强联通分量。</strong>强联通分量是一个图论中的概念，他的定义是<strong>有向图中的极大强联通子图</strong>，而<strong>强联通</strong>意为图中任意两点都互相可达。 对于求强联通分量的算法主要是有美国计算机科学家 <em>Robert E. Tarjan</em> （罗伯特·塔扬，1948 ~ 今）提出的 <strong>Trajan 算法</strong>，这个算法基于<strong>深度优先搜索（DFS）</strong>，在深度优先搜索的同时记录两个数组 $dfn$ 以及 $low$ ，这两个数组的定义分别是 DFS 时间戳以及该节点的多有子节点以及该节点的 $dfn$ 的<strong>最小值</strong>。而当一个节点的 $dfn$ 值和 $low$ 值相同时，该节点与该节点的所有子节点构成了一个<strong>极大的强联通子图</strong>即<strong>强联通分量</strong>。强联通分量还有一个很著名的应用 $\rightarrow$ <strong>缩点</strong>。在有的时候，你往往需要计算一个图的连通性相关的内容，而此时由于强联通分量内部任意两点都互相可达，我们可以直接将一个强联通分量看做一个节点，并进行所需要的计算，这个过程被称为<strong>缩点</strong>。</li><li><strong>割点与桥。</strong>割点与桥是无向图中关于连通性的两个概念，<strong>割点</strong>的定义是<strong>如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点</strong>，而<strong>桥</strong>的定义是<strong>对于一个无向图，如果删掉一条边后图中的连通分量数增加了，则称这条边为桥或者割边</strong>。求割点与桥的算法也是由美国计算机科学家 <em>Robert E. Tarjan</em> （罗伯特·塔扬，1948 ~ 今）提出的（Orz 大奆）。与求强联通分量基本一致，不详细展开。</li><li><strong>并查集。</strong>并查集是一种很高级的数据结构。本质上并查集是一堆集合的集合，这个集合的集合支持两个操作：<strong>合并（Union）</strong>、<strong>查询（Find）</strong>。所以这个集合的集合的名字就是并查集（好草率）。并查集的时间复杂度是极其优秀的，查询的时间复杂度为 $\Theta\left(\alpha\left(n\right)\right)$ （其中 $n$ 为集合中的元素数量），而合并的复杂度是 $\Theta\left(1\right)$ （已知祖先的情况下）。实现这样的复杂度还要仰赖于路径压缩，即在搜索的同时将一个子集内所有元素的祖先设为该集合的公共祖先。而该算法的时间复杂度分析是由 <strong>Tarjan</strong> 大奆提出的 （$\Huge %$ 他真的我哭死，图论创始人是吧，欧拉的墓都让他刨了）基于并查集，我们可以实现一些很不错的功能，比如判断图的连通性或者记录图中连通块的数量等等。</li><li><strong>最小生成树。</strong>最小生成树（MST, Minimum Spanning Tree） 是一种比较特殊的树，他的<strong>定义</strong>是<strong>边权和最小的生成树</strong>。这种树在电路板布线、路由设计等领域很有用处。常见的 MST 算法有 <strong>Kruskal</strong> 和 <strong>Prim</strong> 。其中 <strong>Kruskal</strong> 算法是一种基于贪心策略的算法，算法会对所有边按边权升序排序，然后对于不与最小生成树联通的边，将其加入最小生成树，当加入的节点构成了一棵树时，这棵树就是我们希望求得的最小生成树。</li></ol><h2 id="学习状态"><a href="#学习状态" class="headerlink" title="学习状态"></a>学习状态</h2><p>这三个星期的学习状态我个人认为还是不错的，态度较为认真。在这三个星期的集训中学到了不少知识，同时在比赛中锻炼了自己的比赛状态和应对题目的能力。和同学在一起生活、交流，也让我受益匪浅，在了解同学趣事的同时，也互相进行了很多技术和能力上的交流，大家都无比换了的度过了难得的集训时光。</p><h2 id="课余"><a href="#课余" class="headerlink" title="课余"></a>课余</h2><p>每天下午下课，我们总会结伴来到操场，或足球，或篮球。一切的体育运动在我们的眼中都是充满趣味和激情的。</p><p>集训结束前最后一天，我们 ABC 三个班的同学加上一位隔壁物理队的同学共 $22$ 人在绿茵场上挥洒汗水。慷慨淋漓的打了离开越秀校区前的最后一场球赛。在这场球赛中我们虽败由乐，赛后大家都欢声笑语的走回科技楼，在笑声中结束了为期三周的集训。</p><p>在这为期三周的集训中，出现了不少<strong>好 van</strong> 的东西：</p><ul><li>DLT 计数法：一两二三四，五六拐八九</li><li>想成功，先发疯，不顾一切向前冲，今天睡地板，明天<del>睡老板</del>，加油！！！加油！！！加油！！！。 </li><li><strong>真正的小丑：</strong>玩家：“游戏结束，小丑胜利”；法官：“游戏继续，天黑请闭眼”（小丑被盗宝偷了，哈哈哈哈我能笑两年半）</li><li>CYY 的 Hack 数据</li></ul><h2 id="对老师"><a href="#对老师" class="headerlink" title="对老师"></a>对老师</h2><p>感觉没什么好说的，都挺好的，O(∩_∩)O 哈哈~</p>]]></content>
    
    
    
    <tags>
      
      <tag>游记</tag>
      
      <tag>TYOI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MCOI 2023年6月月赛题解</title>
    <link href="/posts/5946.html"/>
    <url>/posts/5946.html</url>
    
    <content type="html"><![CDATA[<h1 id="MCOI-2023-年-6-月月赛题解"><a href="#MCOI-2023-年-6-月月赛题解" class="headerlink" title="MCOI 2023 年 6 月月赛题解"></a>MCOI 2023 年 6 月月赛题解</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这是一场个人认为难度 $\approx$ J- 级的比赛，除了最后一题是一道非常怪的题以外其他的题目都是比较简单的，但是会有一些坑。由于出题人写 TJ 的时候你们的比赛还没有结束，因此没法评价本场比赛。个人估计应该不会有人 AK，但是这场比赛应该 $300$ pts 的巨佬不少。下面是各题的题解，写的不好，请多多关照。</p><h2 id="T1-WTX-的文采"><a href="#T1-WTX-的文采" class="headerlink" title="T1 - WTX 的文采"></a>T1 - WTX 的文采</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先要理解一下题意，出题人保守估计大部分做不出此题的选手是因为看不懂题目里面的式子。所以让我们来看一下这个式子：</p><p>$$<br>y_i&#x3D;\left(\displaystyle\sum_{j&#x3D;l_i}^{r_i}\ [z_j\ge w]\ 1\right)\times\left(\displaystyle\sum_{j&#x3D;l_i}^{r_i}\ [z_j\ge w]\ p_j\right)<br>$$</p><p>首先我们可以将这个式子按照乘号分成两个部分，我们先行理解左边的部分 $\sum_{j&#x3D;l_i} ^ {r_i}\ [z_j \ge w]\  1$ 首先我们理解一下这个符号 $\sum$ （西格玛，念做：sigma [‘sigma] ）。实际上就是一个求和，或者理解为一个 <code>for</code> 循环，$\sum$ 符号下面的是循环变量的起始值，然后上面的那个数是循环变量的最大值，循环变量每次加一，然后右边的 $[]$ 里面的内容是后面算式是否累加的条件，也就是说，这个西格玛可以变成下面的一段伪代码（伪代码格式参考《算法导论》（英文名 _Intrudution to Algorithms_））：</p><p>$$<br>\begin{array}{l}<br>ans &#x3D; 0\<br>for\ j\ &#x3D; l_i\ to\ r_i\<br>\ \ \ \ if\ z_j \ge w\<br>\ \ \ \ \ \ \ \ ans +&#x3D; 1\<br>\end{array}<br>$$</p><p>同理，我们可以理解第二块式子的意思，那么就很简单了。</p><p>为了优化多次查询，我们可以写两个前缀和数组，分别是第一块和第二块式子的结果，然后进行查询，计算出结果并输出。</p><p>如果不理解前缀和，可以查看 <a href="https://oi.wiki/basic/prefix-sum/">oi-wiki 的讲解</a></p><h3 id="标程"><a href="#标程" class="headerlink" title="标程"></a>标程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> n, m, w, x, z[<span class="hljs-number">10000009</span>], p[<span class="hljs-number">10000009</span>], l, r, y;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; w;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cin &gt;&gt; x &gt;&gt; p[i];<br><span class="hljs-keyword">if</span> (x &gt;= w) &#123;<br>p[i] += p[i - <span class="hljs-number">1</span>];<br>z[i] = z[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>p[i] = p[i - <span class="hljs-number">1</span>];<br>z[i] = z[i - <span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>cin &gt;&gt; l &gt;&gt; r;<br><span class="hljs-keyword">if</span> (l &gt; r) &#123;<br><span class="hljs-built_in">swap</span>(l, r);<br>&#125;<br>cout &lt;&lt; (z[r] - z[l - <span class="hljs-number">1</span>]) * (p[r] - p[l - <span class="hljs-number">1</span>]) &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T2-WTX-的蛋糕"><a href="#T2-WTX-的蛋糕" class="headerlink" title="T2 - WTX 的蛋糕"></a>T2 - WTX 的蛋糕</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先我们抽象一下题目，在一个三维空间内，有一个无穷大的物体，同时有一条直线，用这条将这个物体切成若干份，求切 $n$ 刀后这个三维空间内的物体的块数。由于题目中并没有说明物体是否可移动，所以我们假定物体是可以移动的，因为这样可以使物体的块数最大化。</p><p>我们考虑对一块完整的物体的情况，很显然，一刀最多把它切成两块。不能再多了，因为<del>再多一点就快爆炸</del>。那么我们如果在每次切完之后将物体摆放好，使得每一小块都可以被这条直线切到，那么我们就实现的小块的数量最大化。由于我们只能切 $n$ 刀，所以我们可以发现，物体的最多数量是 $2 ^ n$ ，那么这就很简单了，对吧？</p><p>不对！！！我们观察一下题目的数据范围，达到了惊人的 $10 ^ {18}$ 。要知道，c++ 语言内置的最大的整数数据结构 <code>__int128</code> 也只能存储 $2 ^ {128}$ 啊，这 $2 ^ {1e18}$ 要怎么存呢？</p><p>再多看一眼<del>就快爆炸</del>题目就可以发现题目<strong>非常良心</strong>的让我们将最终结果对一个很大的质数 $1e9 + 7$ 取模，也就是说不会产生数据溢出的情况，但是因为这个模数的存在，我们无法调用 STL 函数 <code>pow(int n, int m)</code> 所以我们需要自己写一个幂函数。</p><p>但是话又说回来，这个幂函数采用通常的写法时间是肯定会超限的，因为常规的幂函数写法时间复杂度是线性的 $O(n)$ ，很显然，对于 $10 ^ {18}$ 来说，这个运算至少需要 $2000\ ms$ 才能完成，但是题目的时间限制只有 $250\ ms$ ，是当前算法的 $4$ 倍有余。那这该怎么办呢？</p><p>这时候我们需要引入一个算法：快速幂（ quick power )</p><p>首先我们看一个例子：$2 ^ {10}$ ，我们按照算式展开应该是这样的 $\underbrace {2 \times 2 \times…\times2\times2} _{10\ 个\ 2}$ 那么有没有一种方法可以减少一下运算呢，我们会发现，$2 ^ {10}$ 应该是等于 $2 ^ {5} \times 2 ^ {5}$ 的，折这一点上过小学二年级应该都知道，那么我们只需要计算 $2 ^ 5$ 就可以了，以此类推，我们就会发现，实际上我们只需要进行最多 $\lfloor\log_2n\rfloor + 1$ 次运算就可以计算出来 $2 ^ n$ 的精确数值，这种思路在算法导论中被称为<strong>分治</strong>。下面介绍两种快速幂的实现思路</p><h4 id="快速幂思路-1"><a href="#快速幂思路-1" class="headerlink" title="快速幂思路 1"></a>快速幂思路 1</h4><p>使用递归实现分治算法，伪代码如下：</p><p>$$<br>\begin{array}{l}<br>QUICK_POW(a, b, m)\<br>\ \ \ \ if\ b\ &#x3D;&#x3D; 0\<br>\ \ \ \ \ \ \ \ return\ 1\<br>\ \ \ \ if\ b\ &#x3D;&#x3D;\ 1\<br>\ \ \ \ \ \ \ \ return\ a\ %\ m\<br>\ \ \ \ temp &#x3D; QUICK_POW(a, \lfloor b\ ÷\ 2 \rfloor, m)\ %\ m\<br>\ \ \ \ if\ b\ %\ 2&#x3D;&#x3D;1\<br>\ \ \ \ \ \ \ \ return\ (temp \times temp \times a)\ %\ m\<br>\ \ \ \ return\ (temp \times temp)\ %\ m<br>\end{array}<br>$$</p><p>这种方法实现思路较为简单，直接模拟即可，但是这种算法由于递归的存在，时间上不如递推算法，同时对空间的要求比较高，如果遇见特别大的指数，有可能爆栈</p><h4 id="快速幂思路-2"><a href="#快速幂思路-2" class="headerlink" title="快速幂思路 2"></a>快速幂思路 2</h4><p>使用递推的方式实现分治算法，伪代码如下：</p><p>$$<br>\begin{array}{l}<br>QUICK_POW(a, b, m)\<br>\ \ \ \ ans &#x3D; 1\<br>\ \ \ \ while\ b&gt;0\<br>\ \ \ \ \ \ \ \ if\ b\ %\ 2\ &#x3D;&#x3D;\ 1\<br>\ \ \ \ \ \ \ \ \ \ \ \ ans&#x3D;(ans \times a)\ %\ m\<br>\ \ \ \ \ \ \ \ a &#x3D; (a \times a)\ %\ m\<br>\ \ \ \ \ \ \ \ b &#x3D; \lfloor b\ ÷\ 2\rfloor\<br>\ \ \ \ return\ ans\ %\ m<br>\end{array}<br>$$</p><p>这种代码书写方法在内存占用上较为优秀，同时时间上用于没有调用栈的操作，更快一些。</p><p>根据上面的思路，只需要将其用你熟练的语言实现一下即可</p><h3 id="标程-1"><a href="#标程-1" class="headerlink" title="标程"></a>标程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> m)</span> </span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-keyword">if</span> (p &amp; <span class="hljs-number">1</span>) &#123;<br>            ans = (ans * x) % m;<br>        &#125;<br>        x = (x * x) % m;<br>        p &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans % m;<br>&#125;<br><br><span class="hljs-type">int</span> n, ans;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    ans = <span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>, n, <span class="hljs-number">1000000007</span>);<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T3-WTX-的追逐"><a href="#T3-WTX-的追逐" class="headerlink" title="T3 - WTX 的追逐"></a>T3 - WTX 的追逐</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这道题显然很简单，是一个单源最短路问题，但是终点的选的有点奇怪，如果是 <code>t</code> 或者 <code>c</code> 就是终点，也就是说这道题没有办法使用<strong>双向广搜</strong>或者<strong>A*<strong>算法之类极其高效的算法，由于又存在障碍物，所以我们也不能使用</strong>贪心优先搜索（ GBFS ）</strong>这种虽然快但是有可能不准确的算法，我们剩下两种寻路算法：<strong>广度优先搜索（ BFS ）</strong>和<strong>深度优先搜索（ DFS ）</strong>。下面我们分析这两种算法的可行性和性能。</p><h4 id="对深度优先搜索分析"><a href="#对深度优先搜索分析" class="headerlink" title="对深度优先搜索分析"></a>对深度优先搜索分析</h4><p>首先我们观察一下深度优先搜索的特性，这里引用我们 TYOI 一位老队员的比喻：<em>深搜就像一头牛，不撞南墙不回头</em> 。根据这句话，我们可以发现深度优先搜索似乎在找到最短路径之前有可能花费很多时间进行其他路线的寻找，这将浪费很多时间。同时因为深度优先搜索通常是使用递归实现的，这种算法在矩阵很大很大的情况下可能会出现内存超限或者爆栈的情况。不过 DFS 也不是完全没有优点，对于这道题或者其他需要输出路径的情况，递归的调用方式对输出路径来说更加的方便。综上所述，深度优先搜索并不适合此题，不过，<strong>良心</strong>的出题人为使用 DFS 的选手准备了 $25\ pts$ 的部分分，感动吧。┭┮﹏┭┮</p><h4 id="对广度优先搜索分析"><a href="#对广度优先搜索分析" class="headerlink" title="对广度优先搜索分析"></a>对广度优先搜索分析</h4><p>我们首先再次观察一下广度优先搜索的特性，我们会发现，广度优先搜索有点像洪水（ flood ），会匀速的蔓延到四周的节点。根据这个特性，我们会发现，BFS 找到的第一条路径一定是最短的路径之一，所以我们在找到第一条路径的时候就可以退出搜索，然后输出路径。但是这种算法对于记录路径来说会有一些困难。不过如果你学过<strong>树结构</strong>的存储的话，你会发现我们可以借鉴树的存储方法，使用一个二维数组 <code>father[][] </code> 来记录每一个节点的前驱。用这种方法来记录一条可行的路径，但是你需要注意的是起点的前驱应当设置为一个奇怪的值，比如一个不可能出现的点的坐标，如：$(-1, -1)$ 。</p><p>接下来是实现的方法，下面给出两个关键的函数的伪代码，首先是广搜函数：</p><p>$$<br>\begin{array}{l}<br>a[n][m] &#x3D; map\<br>vis[n][m] &#x3D; a\ array\ mark\ which\ point\ has\ been\ walked\ and\ which\ not\<br>s.x &#x3D; starting\ point’s\ x\ axis\<br>s.y &#x3D; starting\ point’s\ y\ axis\<br>x_axis_ofset&#x3D;[0, 0, -1, 1]\<br>y_axis_ofset&#x3D;[-1, 1 , 0, 0]\<br>BFS()\<br>\ \ \ \ q.push(s.x, s.y)\<br>\ \ \ \ father[s.x][s.y] &#x3D; {-1, -1}\<br>\ \ \ \ while\ not\ q.empty()\<br>\ \ \ \ \ \ \ \ front&#x3D;q.front()\<br>\ \ \ \ \ \ \ \ if\ a[front.x][front.y] &#x3D;&#x3D; ‘C’\ or\ a[front.x][front.y] &#x3D;&#x3D; ‘T’\<br>\ \ \ \ \ \ \ \ \ \ \ \ OUTPUT(front.x, front.y)\<br>\ \ \ \ \ \ \ \ \ \ \ \ return\<br>\ \ \ \ \ \ \ \ for\ i&#x3D;0\ to\ 3\<br>\ \ \ \ \ \ \ \ \ \ \ \ x_next&#x3D;front.x+x_axis_ofset[i]\<br>\ \ \ \ \ \ \ \ \ \ \ \ y_next&#x3D;front.y+y_axis_ofset[i]\<br>\ \ \ \ \ \ \ \ \ \ \ \ if\ not\ (a[x_next][y_next]&#x3D;&#x3D;’#‘\ or\ vis[x_next][y_next])\<br>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ q.push({x_next,y_next})\<br>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ vis[x_next][y_next]&#x3D;true\<br>\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ father[x_next][y_next] &#x3D; front\<br>\end{array}<br>$$</p><p>其次是输出函数：</p><p>$$<br>\begin{array}{l}<br>father[n][m]&#x3D;a\ array\ storage\ the\ father\ of\ a\ point\<br>OUTPUT(x, y)\<br>\ \ \ \ if\ x&#x3D;&#x3D;-1\ and\ y&#x3D;&#x3D;-1\<br>\ \ \ \ \ \ \ \ return\<br>\ \ \ \ OUTPUT(father[x][y].x, father[x][y].y)\<br>\ \ \ \ if\ father[x][y].x &#x3D;&#x3D; -1\ and\ father[x][y].y&#x3D;&#x3D;-1\<br>\ \ \ \ \ \ \ \ PRINT(“(%d,\ %d)”,\ x,\ y)\<br>\ \ \ \ else\<br>\ \ \ \ \ \ \ \ PRINT(“(%d,\ %d)\ -&gt;\ “,\ x,\ y)\<br>\end{array}<br>$$</p><p>剩下的部分就是输入和一些简单的处理了，大家可以用自己喜欢的语言实现一下</p><h3 id="标程-2"><a href="#标程-2" class="headerlink" title="标程"></a>标程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">point</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br><br>    <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> point a) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> a.x == x &amp;&amp; a.y == y;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> r, c, l, xx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, yy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br>point s, t, father[<span class="hljs-number">109</span>][<span class="hljs-number">109</span>];<br><span class="hljs-type">char</span> a[<span class="hljs-number">109</span>][<span class="hljs-number">109</span>];<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">109</span>][<span class="hljs-number">109</span>];<br>queue&lt;point&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (father[x][y] == (point) &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d, %d) -&gt; &quot;</span>, x, y);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">out</span>(father[x][y].x, father[x][y].y);<br>    <span class="hljs-keyword">if</span> (x == t.x &amp;&amp; y == t.y) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d, %d)&quot;</span>, x, y);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d, %d) -&gt; &quot;</span>, x, y);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    vis[s.x][s.y] = <span class="hljs-literal">true</span>;<br>    father[s.x][s.y] = (point) &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        point front = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (a[front.x][front.y] == <span class="hljs-string">&#x27;T&#x27;</span> || a[front.x][front.y] == <span class="hljs-string">&#x27;C&#x27;</span>) &#123;<br>            t.x = front.x, t.y = front.y;<br>            <span class="hljs-built_in">out</span>(front.x, front.y);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> x = front.x + xx[i], y = front.y + yy[i];<br>            <span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">0</span> || y &lt;= <span class="hljs-number">0</span> || x &gt; r || y &gt; c || vis[x][y] || a[x][y] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            father[x][y] = front;<br>            vis[x][y] = <span class="hljs-literal">true</span>;<br>            q.<span class="hljs-built_in">push</span>((point) &#123;x, y&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; r &gt;&gt; c;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= r; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= c; j++) &#123;<br>            cin &gt;&gt; a[i][j];<br>            <span class="hljs-keyword">if</span> (a[i][j] == <span class="hljs-string">&#x27;W&#x27;</span>) &#123;<br>                s.x = i, s.y = j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">bfs</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T4-WTX-的小车车"><a href="#T4-WTX-的小车车" class="headerlink" title="T4 - WTX 的小车车"></a>T4 - WTX 的小车车</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这道题是解析几何的一个问题，首先我们看一下题，注意提示里面说了 WTX 的图纸只有一种可能。那么我们分析一下，一个三角形的重心与这个三角形的外接圆的圆心或者说外心相同，那么这个三角形是什么三角形呢？</p><p>首先我们了解一下三角形的重心是什么？根据百度百科的说法，三角形的重心是三角形三条中线的交点，我们可以举一个例子，如<strong>图-1</strong>，我们在平面直角坐标系 $xOy$ 中作任意 $\triangle ABC$ ，作 $\triangle ABC$ 的三条中线 $AD$ ，$BE$，$CF$，得到一个交点 $G$ ，这个点就是我们的三角形的重心</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20230527205159077.png" srcset="/img/loading.gif" lazyload alt="图-1"></p><p>那么三角形的外接圆的圆心要怎么求呢，我们查阅教科书可以发现，三角形的外心就是三角形三条中垂线的交点，如<strong>图-2</strong>，图中的点 $D$ 就是三角形的外心</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20230527205719705.png" srcset="/img/loading.gif" lazyload alt="图-2"></p><p>那么我们考虑在什么情况下中线的交点会和中垂线的交点重合？我们会发现，为了使中垂线与中线重合，三角形的中线必须要是三角形形的高线，也就是一边到对应点的垂线，那么符合这个标准的是什么三角形呢？我们想一想就会发现，只有正三角形可以满足这个要求。在正三角形中，三角形的三条中线是完全与中垂线重合的，那么这个时候三角形的重心就和外心就重合了，如<strong>图-3</strong>，点 $G$ 就是三角形的重心兼外心</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20230527210623903.png" srcset="/img/loading.gif" lazyload alt="图-3"></p><p>那么现在我们已经知道了 WTX 的图纸上面的框架是正三角形，那么我们要怎么统计这个正三角形的数量呢？讲到这里，不知道你有没有想起来一道经典的哈希表（散列表）题目 <strong><em>四轮车</em></strong> 呢？我们可以用一个哈希表来保存一些点，然后爆搜两个点，计算另一个点，然后统计数量，时间复杂度为 $O(n ^ 2)$ 。是我力所能及的最优时间复杂度了，希望赛时能有巨佬写出更优秀的代码。</p><p>话说回来已知正三角形的两个顶点，怎么计算第三个顶点的坐标呢？</p><p>如<strong>图-4</strong>，首先作任意两点 $A$ ，$B$ 。连接 $A$，$B$，并分别以 $A$，$B$ 为圆心，$AB$ 为半径做两个圆，我们就会发现，两个圆相交的两个点 $C$ 和 $D$ 就是以 $A$ 和 $B$ 为两顶点可能的两个正三角形的顶点了</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20230527211936465.png" srcset="/img/loading.gif" lazyload alt="图-4"></p><p>但是，我们要怎么求这两个圆的交点呢？我们首先复习一下<a href="https://book.pep.com.cn/1421001127202/mobile/#p=114">高中数学选择性必修第一册 B 版第 103 页起的关于圆及其方程的内容</a>。我们会发现，圆的方程是 $(x-a) ^ 2 + (y-b) ^ 2&#x3D;r ^ 2$ ，那么我们可以尝试联立两个圆的方程，尝试求出这个二元二次方程组的两个根，但是我们稍微查阅一下相关资料就可以发现，对于这个二元二次方程组，我们通常会把他化简为一些更高次的方程，但是这些高次的方程由于没有通用的求根公式，所以求起来会十分的难受。综上所述，这个方法是很复杂的，我们需要寻求一个更加简便的方法。不过，我们也可以尝试用这种方法，看看究竟行不行。</p><p>下面提供几种思路，各位也可以使用其他高级的方法解决这个问题。</p><h4 id="求坐标思路一"><a href="#求坐标思路一" class="headerlink" title="求坐标思路一"></a>求坐标思路一</h4><p>我们会发现，正三角形的顶点是其对边的垂线（或者中垂线）上的一点。那么这一点到他对边的距离是多少呢，我们做一个图就可以看出来，如<strong>图-5</strong>，已知图中的 线段 $AB$，如何求线段 $CD$ 的长度呢？很显然，由于图中的 $\angle \alpha &#x3D; 90\degree$ 或者说 $CD \bot AB$ 我们可以很方便的使用勾股定理来解决这个问题，我们首先根据勾股定理列出一条方程 $|AD| ^ 2 + |CD|  ^  2&#x3D;|AC| ^ 2$ ，由于 $AC&#x3D;AB&#x3D;BC$ 且 $D$ 是 $AB$ 的二等分点（终点） 所以我们可以将方程化简为这种形式 $\left(\frac{1}{2}|AB|\right) ^ 2 + |CD|  ^  2&#x3D; |AB|  ^  2$ 那么现在我们将方程稍加化简整理，得到 $|CD| &#x3D; \sqrt{\frac{5}{4} \cdot |AB|  ^  2}$ 。好的，现在我们已经获得了线段 $CD$ 的长度了，那么我们要怎么得到 直线 $CD$ 的方程（解析式）呢？</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/image-20230528084233129.png" srcset="/img/loading.gif" lazyload alt="图-5"></p><p>首先我们复习一下<a href="https://book.pep.com.cn/1421001127202/mobile/#p=82">高中数学选择性必修第一册 B 版第 79 页起关于直线及其方程的内容</a>。我们可以得知，表达一条直线有很多种方式，比如点斜式方程（$y - y_0 &#x3D; k\cdot(x - x_0)$）、斜截式方程（$y &#x3D; kx + b$）、两点式方程（$\frac{y - y_1}{y_2 - y_1} &#x3D; \frac{x - x_1}{x_2 - x_1}$）等等…… 很显然，在我们的这道题目中，需要使用点斜式方程，因为直线 $CD$ 的斜率以及点 $D$ 的坐标是极其好求的，所以这种方法会比较简便。</p><p>首先我们解决一个比较简单的问题，点 $D$ 的坐标要怎么求？由于点 $D$ 是线段 $AB$ 的中点，所以我们可以很方便的使用中点公式 $(\frac{x_2 - x_1}{2}, \frac{y_2 - y_1}{2})$ ，那么这里我们假设 $A:(x_1, y_1)$， $B:(x_2, y_2)$，带入公式可得 $D:(\frac{x_2 - x_1}{2}, \frac{y_2-y_1}{2})$ 。</p><p>然后是斜率的问题，我们根据垂线的性质可以得到假设现在有两条直线，他们的斜率分别是 $k_1$ 和 $k_2$ ，如果两直线垂直，那么 $k_1 \cdot k_2&#x3D;-1$ ，或者说 $k_1 &#x3D; -\frac{1}{k_2}$ ，也就是说两直线垂直，斜率互为负倒数。既然如此，那么 $CD$ 的斜率是否可求了呢？没错，首先我们假设 $AB$ 的斜率为 $k$，且 $A:(x_1, y_1)$， $B:(x_2, y_2)$，由于 $A$ 和 $B$ 两点的坐标已知，那么我们很容易通过直线的斜截式方程得到 $k &#x3D; \frac{y_2 - y_1}{x_2 - x_1}$，那么 $CD$ 的斜率 $k_1$ 就应当等于 $\frac{y2-y_1}{x_2 - x_1}$ 的负倒数 $-\frac{x_2 - x_1}{y_2 - y_1}$ 。</p><p>既然两个问题都解决了，那么我们假设 $D:(x_3, y_3)$ ，将计算出来的结果带入直线的点斜式方程 $y - y_0 &#x3D; k \cdot (x - x_0)$ 中，我们可以得到 $y - y_3 &#x3D; -\frac{x_2 - x_1}{y_2 - y_1}\cdot (x - x_3)$ ，将点 $D$ 的坐标代入方程可得 $y - \frac{y_2 - y_1}{2} &#x3D; -\frac{x_2 - x_1}{y_2 - y_1}\cdot (x - \frac{x_2 - x_1}{2})$ 。那么，是时候公布正确答案了，这条方程就是大名鼎鼎的<strong>中垂线方程</strong>！！！</p><p>现在一个问题又出现了，已知一条直线和一个点和一个距离，如何求直线上的另一点的坐标？</p><p>我这边的思路是这样子的，如<strong>图-6</strong>，我们会发现，如果我们以这个距离为半径，已知点为圆心，可以做出一个圆，而这个圆与我们的直线的交点就是我们想要求的两个点。</p><p>那么怎么求一个圆与直线的交点呢？下面介绍两种方法，方程法和向量法</p><h5 id="方程法"><a href="#方程法" class="headerlink" title="方程法"></a>方程法</h5><p>方程法顾名思义，就是通过解方程来得到结果，首先我们要知道我们使用什么方程来计算，那么我们首先确认圆的方程，这里为了方便使用圆标准方程 $(x - a) ^ 2 + (y - b)  ^  2 &#x3D; r  ^  2$ 。然后是较难确定的直线的方程，难确定的原因主要是直线的方程实在是太多种多样了，就课本里面的就有整整五种！我们这里选的直线的一般式方程 $ax + by + c &#x3D; 0$ ，需要注意的是，圆的方程中的常数 $a$ 和 $b$ 与直线方程内的常数 $a$ 和 $b$ 在大多数情况下是不会相等的，因此为了方便，我们将其加上下标后联立，得到一个这样的方程组：</p><p>$$<br>\left{<br>\begin{array}{l}<br>a_1x+b_1y+c &#x3D; 0\ \<br>(x - a_2)^2 + (y - b_2) ^ 2 &#x3D; r ^ 2<br>\end{array}<br>\right.<br>$$</p><p>解得</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">x =<br><br>- c - (b1*(b2 - a2<span class="hljs-number">*b1</span> - b1<span class="hljs-number">*c</span> + (- a2 ^ 2 - 2<span class="hljs-number">*a2</span><span class="hljs-number">*b1</span><span class="hljs-number">*b2</span> - 2<span class="hljs-number">*a2</span><span class="hljs-number">*c</span> - b1 ^ 2<span class="hljs-number">*b2</span> ^ 2 + b1 ^ 2*r ^ 2 - 2<span class="hljs-number">*b1</span><span class="hljs-number">*b2</span><span class="hljs-number">*c</span> - c ^ 2 + r ^ 2) ^ (1/2)))/(b1 ^ 2 + 1)<br><br>  (b1*(a2<span class="hljs-number">*b1</span> - b2 + b1<span class="hljs-number">*c</span> + (- a2 ^ 2 - 2<span class="hljs-number">*a2</span><span class="hljs-number">*b1</span><span class="hljs-number">*b2</span> - 2<span class="hljs-number">*a2</span><span class="hljs-number">*c</span> - b1 ^ 2<span class="hljs-number">*b2</span> ^ 2 + b1 ^ 2*r ^ 2 - 2<span class="hljs-number">*b1</span><span class="hljs-number">*b2</span><span class="hljs-number">*c</span> - c ^ 2 + r ^ 2) ^ (1/2)))/(b1 ^ 2 + 1) - c<br><br><br>y =<br><br> (b2 - a2<span class="hljs-number">*b1</span> - b1<span class="hljs-number">*c</span> + (- a2 ^ 2 - 2<span class="hljs-number">*a2</span><span class="hljs-number">*b1</span><span class="hljs-number">*b2</span> - 2<span class="hljs-number">*a2</span><span class="hljs-number">*c</span> - b1 ^ 2<span class="hljs-number">*b2</span> ^ 2 + b1 ^ 2*r ^ 2 - 2<span class="hljs-number">*b1</span><span class="hljs-number">*b2</span><span class="hljs-number">*c</span> - c ^ 2 + r ^ 2) ^ (1/2))/(b1 ^ 2 + 1)<br><br>-(a2<span class="hljs-number">*b1</span> - b2 + b1<span class="hljs-number">*c</span> + (- a2 ^ 2 - 2<span class="hljs-number">*a2</span><span class="hljs-number">*b1</span><span class="hljs-number">*b2</span> - 2<span class="hljs-number">*a2</span><span class="hljs-number">*c</span> - b1 ^ 2<span class="hljs-number">*b2</span> ^ 2 + b1 ^ 2*r ^ 2 - 2<span class="hljs-number">*b1</span><span class="hljs-number">*b2</span><span class="hljs-number">*c</span> - c ^ 2 + r ^ 2) ^ (1/2))/(b1 ^ 2 + 1)<br></code></pre></td></tr></table></figure><p>稍微整理一下得</p><p>$$<br>\left{<br>\begin{array}{l}<br>x&#x3D;\left(\begin {array} { c } -c-\frac { b _ { 1 }  \left(b _ { 2 } - a _ { 2 }  b_{1} -b _ { 1 } c + \sqrt{ -{ a_{ 2 } } ^ 2-2a_{ 2 } b_{ 1 } b_{ 2 } -2a_{2} c- { b_{ 1 } }  ^ 2 { b _ { 2 } }  ^  2+{b_{1 } } ^ 2r ^ 2-2b_{ 1 } b_{ 2 } c-c ^ 2+r  ^  2} \right) }{ {b_{1} } ^ 2+1}\ \frac{b_{1}\left(a_{2}b_{1}-b_{2}+b_{1}c+\sqrt{-{a_{2}} ^ 2-2a_{2} b_{1} b_{2} -2a_{2} c-{b_{1}} ^ 2{b_{2}} ^ 2+{b_{1}} ^ 2r ^ 2-2b_{1} b_{2} c-c ^ 2+r ^ 2} \right) }{ {b_{1} } ^ 2+1} -c \end{array} \right )\<br>y &#x3D; \left(\begin{array}{c} \frac{b_{2} -a_{2} b_{1} -b_{1}c+\sqrt{-{a_{2}} ^ 2-2a_{2}b_{1}b_{2}-2a_{2}c-{b_{1}} ^ 2{b_{2}} ^ 2+{b_{1}} ^ 2r ^ 2-2b_{1}b_{2}c-c ^ 2+r ^ 2}}{ {b_{1} } ^ 2+1}\ -\frac{a_{2}b_{1}-b_{2}+b_{1}c+\sqrt{-{a_{2}} ^ 2-2a_{2}b_{1}b_{2}-2a_{2}c-{b_{1}} ^ 2{b_{2}} ^ 2+{b_{1}} ^ 2r ^ 2-2b_{1}b_{2}c-c ^ 2+r ^ 2}}{ {b_{1} } ^ 2+1} \end{array}\right)<br>\end{array}<br>\right.<br>$$</p><p>至于我是怎么解出来的吧，肯定不是手解的，毕竟这么长的式子，我的草稿纸都写不下，你说要怎么算出来这样的式子。这里需要借用一个工具：<a href="https://matlab.mathworks.com/">MatLab</a> 打开网站后，你需要注册一个账户，然后就会有每个星期 $20$ 个小时时间在线使用 MatLab 软件，软件的使用方法类似 Python Shell。</p><p>打开后，你会见到一个控制台，我们首先定义变量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms a1 b1 a2 b2 c r x y<br></code></pre></td></tr></table></figure><p>接着输入我们的方程组</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f = [a1 * x + b1 * y + c == <span class="hljs-number">0</span>, (x - a2)  ^  <span class="hljs-number">2</span> + (y - b2)  ^  <span class="hljs-number">2</span> == r  ^  <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>然后求解</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">solve(f, [x, y])<br></code></pre></td></tr></table></figure><p>之后你会得到一个变量 <code>ans</code> ，你需要从这个结构体中获得 $x$ 和 $y$ 的解，注意不能输入 <code>ans.x</code> 直接输出，这样会把 $y$ 的解覆盖掉，我也不知道为什么。</p><p>你需要使用两个变量，比如 <code>xans</code> 和 <code>yans</code> 来转存结构体里面的数据，代码如下</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">xans = <span class="hljs-built_in">ans</span>.x<br>yans = <span class="hljs-built_in">ans</span>.y<br></code></pre></td></tr></table></figure><p>然后你可以输入 <code>xans</code> 或者 <code>yans</code> 查看 $x$ 的解或者 $y$ 的解，或者你也可以输入 <code>latex(xans)</code> 或者 <code>latex(yans)</code> 将 $x$ 的解或者 $y$ 的解转化为优雅的 $\LaTeX$ 代码</p><h5 id="向量法"><a href="#向量法" class="headerlink" title="向量法"></a>向量法</h5><p>向量法比较巧妙，但是我看不懂，想学习的同学可以去看一下这一篇<a href="https://blog.csdn.net/qq_40998706/article/details/87521165">文章</a></p><h4 id="求坐标思路二"><a href="#求坐标思路二" class="headerlink" title="求坐标思路二"></a>求坐标思路二</h4><p>我们写出两个圆的标准方程，并将其联立，尝试使用 MatLab 对其求根</p><p>$$<br>\left{<br>\begin{array}{l}<br>(x - a_1) ^ 2 + (y - b_1) ^ 2 &#x3D; r ^ 2\<br>(x - a_2) ^ 2 + (y - b_2) ^ 2 &#x3D; r ^ 2<br>\end{array}<br>\right.<br>$$</p><p>我们求得的根如下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">xans</span> =<br><br>-(<span class="hljs-number">2</span>*b1*(b1/<span class="hljs-number">2</span> + b2/<span class="hljs-number">2</span> - (a1*(-(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">4</span>*r<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>)/(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>))<span class="hljs-regexp"> ^</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))/<span class="hljs-number">2</span> + (a2*(-(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">4</span>*r<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>)/(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>))<span class="hljs-regexp"> ^</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))/<span class="hljs-number">2</span>) - <span class="hljs-number">2</span>*b2*(b1/<span class="hljs-number">2</span> + b2/<span class="hljs-number">2</span> - (a1*(-(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">4</span>*r<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>)/(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>))<span class="hljs-regexp"> ^</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))/<span class="hljs-number">2</span> + (a2*(-(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">4</span>*r<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>)/(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>))<span class="hljs-regexp"> ^</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))/<span class="hljs-number">2</span>) - a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*a1 - <span class="hljs-number">2</span>*a2)<br><br>-(<span class="hljs-number">2</span>*b1*(b1/<span class="hljs-number">2</span> + b2/<span class="hljs-number">2</span> + (a1*(-(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">4</span>*r<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>)/(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>))<span class="hljs-regexp"> ^</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))/<span class="hljs-number">2</span> - (a2*(-(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">4</span>*r<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>)/(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>))<span class="hljs-regexp"> ^</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))/<span class="hljs-number">2</span>) - <span class="hljs-number">2</span>*b2*(b1/<span class="hljs-number">2</span> + b2/<span class="hljs-number">2</span> + (a1*(-(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">4</span>*r<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>)/(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>))<span class="hljs-regexp"> ^</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))/<span class="hljs-number">2</span> - (a2*(-(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">4</span>*r<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>)/(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>))<span class="hljs-regexp"> ^</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))/<span class="hljs-number">2</span>) - a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>)/(<span class="hljs-number">2</span>*a1 - <span class="hljs-number">2</span>*a2)<br><br><br>yans =<br><br>b1/<span class="hljs-number">2</span> + b2/<span class="hljs-number">2</span> - (a1*(-(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">4</span>*r<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>)/(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>))<span class="hljs-regexp"> ^</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))/<span class="hljs-number">2</span> + (a2*(-(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">4</span>*r<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>)/(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>))<span class="hljs-regexp"> ^</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))/<span class="hljs-number">2</span><br><br>b1/<span class="hljs-number">2</span> + b2/<span class="hljs-number">2</span> + (a1*(-(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">4</span>*r<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>)/(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>))<span class="hljs-regexp"> ^</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))/<span class="hljs-number">2</span> - (a2*(-(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">4</span>*r<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>)/(a1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*a1*a2 + a2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> + b1<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span> - <span class="hljs-number">2</span>*b1*b2 + b2<span class="hljs-regexp"> ^</span> <span class="hljs-number">2</span>))<span class="hljs-regexp"> ^</span> (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))/<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>简单整理后如下</p><p>$$<br>\left{<br>\begin{array}{l}<br>x &#x3D; \left(\begin{array}{c} -\frac{2,b_{1},\left(\frac{b_{1}}{2}+\frac{b_{2}}{2}-\frac{a_{1},\sqrt{-\frac{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2-4,r^2}{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2}}}{2}+\frac{a_{2},\sqrt{-\frac{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2-4,r^2}{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2}}}{2}\right)-2,b_{2},\left(\frac{b_{1}}{2}+\frac{b_{2}}{2}-\frac{a_{1},\sqrt{-\frac{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2-4,r^2}{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2}}}{2}+\frac{a_{2},\sqrt{-\frac{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2-4,r^2}{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2}}}{2}\right)-{a_{1}}^2+{a_{2}}^2-{b_{1}}^2+{b_{2}}^2}{2,a_{1}-2,a_{2}}\ -\frac{2,b_{1},\left(\frac{b_{1}}{2}+\frac{b_{2}}{2}+\frac{a_{1},\sqrt{-\frac{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2-4,r^2}{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2}}}{2}-\frac{a_{2},\sqrt{-\frac{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2-4,r^2}{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2}}}{2}\right)-2,b_{2},\left(\frac{b_{1}}{2}+\frac{b_{2}}{2}+\frac{a_{1},\sqrt{-\frac{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2-4,r^2}{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2}}}{2}-\frac{a_{2},\sqrt{-\frac{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2-4,r^2}{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2}}}{2}\right)-{a_{1}}^2+{a_{2}}^2-{b_{1}}^2+{b_{2}}^2}{2,a_{1}-2,a_{2}} \end{array}\right)<br>\<br>y &#x3D; \left(\begin{array}{c} \frac{b_{1}}{2}+\frac{b_{2}}{2}-\frac{a_{1},\sqrt{-\frac{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2-4,r^2}{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2}}}{2}+\frac{a_{2},\sqrt{-\frac{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2-4,r^2}{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2}}}{2}\ \frac{b_{1}}{2}+\frac{b_{2}}{2}+\frac{a_{1},\sqrt{-\frac{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2-4,r^2}{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2}}}{2}-\frac{a_{2},\sqrt{-\frac{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2-4,r^2}{ {a_{1}}^2-2,a_{1},a_{2}+{a_{2}}^2+{b_{1}}^2-2,b_{1},b_{2}+{b_{2}}^2}}}{2} \end{array}\right)<br>\end{array}<br>\right.<br>$$</p><p>很显然，我们求出了结果，但，就这么长一条式子，着实有些头痛。</p><p>现在我们已经求得了坐标，我们就可以通过一个哈希表（散列表）来存储每一个节点，然后查询，累加，得到结果，最后输出注意答案需要除以 $3$ 因为三角形有 $3$ 个顶点，而我们的程序会重复的计算每个节点，因此会计算真实答案的三倍。</p><h3 id="标程-3"><a href="#标程-3" class="headerlink" title="标程"></a>标程</h3><p>我们的标程使用方法二进行计算，虽然式子很长，但是代码量稍微少一些，主要是出题人很懒，代码不长，就 $222$ 行，老天保佑赛时有人 $\color{green}{AC}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">point</span> &#123;<br>    <span class="hljs-type">double</span> x, y;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">double</span> x1, y1, x2, y2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hashx</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">int</span>(x + y) % <span class="hljs-number">1007</span>);<br>&#125;<br><br><span class="hljs-function">node <span class="hljs-title">calc</span><span class="hljs-params">(point a, point b)</span> </span>&#123;<br>    <span class="hljs-type">double</span> a1 = a.x, b1 = a.y, a2 = b.x, b2 = b.y, r = <span class="hljs-built_in">sqrt</span>((a1 - a2) * (a1 - a2) + (b1 - b2) * (b1 - b2));<br>    <span class="hljs-type">double</span> x1, y1, x2, y2;<br>    x1 = -(<span class="hljs-number">2</span> * b1 * (b1 / <span class="hljs-number">2</span> + b2 / <span class="hljs-number">2</span> - (a1 * <span class="hljs-built_in">sqrt</span>(-((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) + (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 +<br>                                                    (b2 * b2) - <span class="hljs-number">4</span> * (r * r)) /<br>                                                  ((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) + (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 +<br>                                                   (b2 * b2)))) / <span class="hljs-number">2</span> + (a2 * <span class="hljs-built_in">sqrt</span>(-((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) +<br>                                                                                   (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 + (b2 * b2) -<br>                                                                                   <span class="hljs-number">4</span> * (r * r)) /<br>                                                                                 ((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) +<br>                                                                                  (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 +<br>                                                                                  (b2 * b2)))) / <span class="hljs-number">2</span>) - <span class="hljs-number">2</span> * b2 *<br>                                                                                                      (b1 / <span class="hljs-number">2</span> + b2 / <span class="hljs-number">2</span> -<br>                                                                                                       (a1 *<br>                                                                                                        <span class="hljs-built_in">sqrt</span>(-((a1 *<br>                                                                                                                a1) -<br>                                                                                                               <span class="hljs-number">2</span> * a1 *<br>                                                                                                               a2 +<br>                                                                                                               (a2 *<br>                                                                                                                a2) +<br>                                                                                                               (b1 *<br>                                                                                                                b1) -<br>                                                                                                               <span class="hljs-number">2</span> * b1 *<br>                                                                                                               b2 +<br>                                                                                                               (b2 *<br>                                                                                                                b2) -<br>                                                                                                               <span class="hljs-number">4</span> * (r *<br>                                                                                                                    r)) /<br>                                                                                                             ((a1 *<br>                                                                                                               a1) -<br>                                                                                                              <span class="hljs-number">2</span> * a1 *<br>                                                                                                              a2 + (a2 *<br>                                                                                                                    a2) +<br>                                                                                                              (b1 *<br>                                                                                                               b1) -<br>                                                                                                              <span class="hljs-number">2</span> * b1 *<br>                                                                                                              b2 + (b2 *<br>                                                                                                                    b2)))) /<br>                                                                                                       <span class="hljs-number">2</span> + (a2 *<br>                                                                                                            <span class="hljs-built_in">sqrt</span>(-((a1 *<br>                                                                                                                    a1) -<br>                                                                                                                   <span class="hljs-number">2</span> *<br>                                                                                                                   a1 *<br>                                                                                                                   a2 +<br>                                                                                                                   (a2 *<br>                                                                                                                    a2) +<br>                                                                                                                   (b1 *<br>                                                                                                                    b1) -<br>                                                                                                                   <span class="hljs-number">2</span> *<br>                                                                                                                   b1 *<br>                                                                                                                   b2 +<br>                                                                                                                   (b2 *<br>                                                                                                                    b2) -<br>                                                                                                                   <span class="hljs-number">4</span> *<br>                                                                                                                   (r *<br>                                                                                                                    r)) /<br>                                                                                                                 ((a1 *<br>                                                                                                                   a1) -<br>                                                                                                                  <span class="hljs-number">2</span> *<br>                                                                                                                  a1 *<br>                                                                                                                  a2 +<br>                                                                                                                  (a2 *<br>                                                                                                                   a2) +<br>                                                                                                                  (b1 *<br>                                                                                                                   b1) -<br>                                                                                                                  <span class="hljs-number">2</span> *<br>                                                                                                                  b1 *<br>                                                                                                                  b2 +<br>                                                                                                                  (b2 *<br>                                                                                                                   b2)))) /<br>                                                                                                           <span class="hljs-number">2</span>) -<br>           (a1 * a1) + (a2 * a2) - (b1 * b1) + (b2 * b2)) / (<span class="hljs-number">2</span> * a1 - <span class="hljs-number">2</span> * a2);<br>    x2 = -(<span class="hljs-number">2</span> * b1 * (b1 / <span class="hljs-number">2</span> + b2 / <span class="hljs-number">2</span> + (a1 * <span class="hljs-built_in">sqrt</span>(-((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) + (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 +<br>                                                    (b2 * b2) - <span class="hljs-number">4</span> * (r * r)) /<br>                                                  ((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) + (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 +<br>                                                   (b2 * b2)))) / <span class="hljs-number">2</span> - (a2 * <span class="hljs-built_in">sqrt</span>(-((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) +<br>                                                                                   (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 + (b2 * b2) -<br>                                                                                   <span class="hljs-number">4</span> * (r * r)) /<br>                                                                                 ((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) +<br>                                                                                  (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 +<br>                                                                                  (b2 * b2)))) / <span class="hljs-number">2</span>) - <span class="hljs-number">2</span> * b2 *<br>                                                                                                      (b1 / <span class="hljs-number">2</span> + b2 / <span class="hljs-number">2</span> +<br>                                                                                                       (a1 *<br>                                                                                                        <span class="hljs-built_in">sqrt</span>(-((a1 *<br>                                                                                                                a1) -<br>                                                                                                               <span class="hljs-number">2</span> * a1 *<br>                                                                                                               a2 +<br>                                                                                                               (a2 *<br>                                                                                                                a2) +<br>                                                                                                               (b1 *<br>                                                                                                                b1) -<br>                                                                                                               <span class="hljs-number">2</span> * b1 *<br>                                                                                                               b2 +<br>                                                                                                               (b2 *<br>                                                                                                                b2) -<br>                                                                                                               <span class="hljs-number">4</span> * (r *<br>                                                                                                                    r)) /<br>                                                                                                             ((a1 *<br>                                                                                                               a1) -<br>                                                                                                              <span class="hljs-number">2</span> * a1 *<br>                                                                                                              a2 + (a2 *<br>                                                                                                                    a2) +<br>                                                                                                              (b1 *<br>                                                                                                               b1) -<br>                                                                                                              <span class="hljs-number">2</span> * b1 *<br>                                                                                                              b2 + (b2 *<br>                                                                                                                    b2)))) /<br>                                                                                                       <span class="hljs-number">2</span> - (a2 *<br>                                                                                                            <span class="hljs-built_in">sqrt</span>(-((a1 *<br>                                                                                                                    a1) -<br>                                                                                                                   <span class="hljs-number">2</span> *<br>                                                                                                                   a1 *<br>                                                                                                                   a2 +<br>                                                                                                                   (a2 *<br>                                                                                                                    a2) +<br>                                                                                                                   (b1 *<br>                                                                                                                    b1) -<br>                                                                                                                   <span class="hljs-number">2</span> *<br>                                                                                                                   b1 *<br>                                                                                                                   b2 +<br>                                                                                                                   (b2 *<br>                                                                                                                    b2) -<br>                                                                                                                   <span class="hljs-number">4</span> *<br>                                                                                                                   (r *<br>                                                                                                                    r)) /<br>                                                                                                                 ((a1 *<br>                                                                                                                   a1) -<br>                                                                                                                  <span class="hljs-number">2</span> *<br>                                                                                                                  a1 *<br>                                                                                                                  a2 +<br>                                                                                                                  (a2 *<br>                                                                                                                   a2) +<br>                                                                                                                  (b1 *<br>                                                                                                                   b1) -<br>                                                                                                                  <span class="hljs-number">2</span> *<br>                                                                                                                  b1 *<br>                                                                                                                  b2 +<br>                                                                                                                  (b2 *<br>                                                                                                                   b2)))) /<br>                                                                                                           <span class="hljs-number">2</span>) -<br>           (a1 * a1) + (a2 * a2) - (b1 * b1) + (b2 * b2)) / (<span class="hljs-number">2</span> * a1 - <span class="hljs-number">2</span> * a2);<br>    y1 = b1 / <span class="hljs-number">2</span> + b2 / <span class="hljs-number">2</span> - (a1 * <span class="hljs-built_in">sqrt</span>(-((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) + (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 + (b2 * b2) -<br>                                        <span class="hljs-number">4</span> * (r * r)) /<br>                                      ((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) + (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 + (b2 * b2)))) /<br>                           <span class="hljs-number">2</span> + (a2 * <span class="hljs-built_in">sqrt</span>(-((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) + (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 + (b2 * b2) -<br>                                            <span class="hljs-number">4</span> * (r * r)) /<br>                                          ((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) + (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 +<br>                                           (b2 * b2)))) / <span class="hljs-number">2</span>;<br>    y2 = b1 / <span class="hljs-number">2</span> + b2 / <span class="hljs-number">2</span> + (a1 * <span class="hljs-built_in">sqrt</span>(-((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) + (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 + (b2 * b2) -<br>                                        <span class="hljs-number">4</span> * (r * r)) /<br>                                      ((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) + (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 + (b2 * b2)))) /<br>                           <span class="hljs-number">2</span> - (a2 * <span class="hljs-built_in">sqrt</span>(-((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) + (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 + (b2 * b2) -<br>                                            <span class="hljs-number">4</span> * (r * r)) /<br>                                          ((a1 * a1) - <span class="hljs-number">2</span> * a1 * a2 + (a2 * a2) + (b1 * b1) - <span class="hljs-number">2</span> * b1 * b2 +<br>                                           (b2 * b2)))) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> (node) &#123;x1, y1, x2, y2&#125;;<br>&#125;<br><br><span class="hljs-type">int</span> n;<br>vector&lt;point&gt; a;<br>vector&lt;point&gt; v[<span class="hljs-number">1009</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> hx = <span class="hljs-built_in">hashx</span>(x, y);<br>    a.<span class="hljs-built_in">push_back</span>((point) &#123;x, y&#125;);<br>    v[hx].<span class="hljs-built_in">push_back</span>((point) &#123;x, y&#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> hx = <span class="hljs-built_in">hashx</span>(x, y);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v[hx].<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">abs</span>(v[hx][i].x) - <span class="hljs-built_in">abs</span>(x)) &lt;= <span class="hljs-number">0.03</span> &amp;&amp; <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">abs</span>(v[hx][i].y) - <span class="hljs-built_in">abs</span>(y)) &lt;= <span class="hljs-number">0.03</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">double</span> x, y;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-built_in">add</span>(x, y);<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; a.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">abs</span>(a[i].x) - <span class="hljs-built_in">abs</span>(a[j].x)) &lt;= <span class="hljs-number">0.03</span> &amp;&amp; <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">abs</span>(a[i].y) - <span class="hljs-built_in">abs</span>(a[j].y)) &lt;= <span class="hljs-number">0.03</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            node points = <span class="hljs-built_in">calc</span>(a[i], a[j]);<br>            <span class="hljs-type">double</span> x1 = points.x1, x2 = points.x2, y1 = points.y1, y2 = points.y2;<br>            ans += <span class="hljs-built_in">find</span>(x1, y1) + <span class="hljs-built_in">find</span>(x2, y2);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; (ans / <span class="hljs-number">6</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说这场比赛由于是我出的第一场公开赛，多少有一些瑕疵，不过我个人还是乐在其中的，不知各位看完题解感觉如何，反正我整篇题解写下来近万字还是非常流畅的。最后，感谢 MCOI 的全体工作人员以及站长对比赛的大力支持，$\huge{此致敬礼}$ 。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>MCOI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass PUJI Circle 题解</title>
    <link href="/posts/19144.html"/>
    <url>/posts/19144.html</url>
    
    <content type="html"><![CDATA[<h1 id="泰裤辣！解析几何"><a href="#泰裤辣！解析几何" class="headerlink" title="泰裤辣！解析几何"></a>泰裤辣！解析几何</h1><h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>首先我们看题，发现题目会给我们四个点，让我们判断这四个点是否共圆，那么如何判断这四个点是否共圆呢？我的思路是这样的：</p><ul><li>首先以这四个点为顶点随便画出两个不同的三角形，求这两个三角形的外心</li><li>然后判断这两个外心是否相同，如果是的话，那么我们可以判断这四个点事共圆的</li></ul><p>那么这种思路就会引起很多问题了，首先什么是外心？很巧，今天数学课数学老师留的思考题就是如何找到三角形的外心，也就是一个可以让三角形三个顶点都与圆相切的圆的圆心，或者你也可以理解为一个到三角形三个顶点距离都相等的点，那么究竟如何找到这个点呢？</p><p>思考了很久很久（一中午）突然恍然大悟，发现三角形三条边所对应的中垂线的交点就是三角形的外心！Ohhhhhh~ 那我们是不是解决问题了？不，不是，好戏才刚刚开始。</p><p>这种方法就引出了很多很多的问题：</p><ol><li>如何求得中垂线的解析式？</li><li>如何求三线的交点？</li></ol><p>首先我们来解决第一个</p><h2 id="如何求得中垂线的解析式？"><a href="#如何求得中垂线的解析式？" class="headerlink" title="如何求得中垂线的解析式？"></a><strong>如何求得中垂线的解析式？</strong></h2><p>我们首先要了解中垂线的定义，根据<a href="https://baike.baidu.com/item/%E5%9E%82%E7%9B%B4%E5%B9%B3%E5%88%86%E7%BA%BF#:~:text=%E5%9E%82%E7%9B%B4%E5%B9%B3%E5%88%86%E7%BA%BF%0A%E5%AE%9A%E4%B9%89.%20%E7%BB%8F%E8%BF%87%E6%9F%90%E4%B8%80%E6%9D%A1%E7%BA%BF%E6%AE%B5%E7%9A%84%E4%B8%AD%E7%82%B9%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%9E%82%E7%9B%B4%E4%BA%8E%E8%BF%99%E6%9D%A1%E7%BA%BF%E6%AE%B5%E7%9A%84%20%E7%9B%B4%E7%BA%BF%20%EF%BC%8C%E5%8F%AB%E5%81%9A%E8%BF%99%E6%9D%A1%E7%BA%BF%E6%AE%B5%E7%9A%84,%E5%9E%82%E7%9B%B4%E5%B9%B3%E5%88%86%E7%BA%BF%20%EF%BC%8C%E5%8F%88%E7%A7%B0%E2%80%9C%E4%B8%AD%E5%9E%82%E7%BA%BF%E2%80%9D%E3%80%82.%20%5B1%5D%20%E5%A6%82%E5%9B%BE1%EF%BC%8CN%E6%98%AFAB%E7%9A%84%E4%B8%AD%E7%82%B9%EF%BC%8C%E8%BF%87N%E7%82%B9%E4%BD%9CMN%E2%8A%A5AB%EF%BC%8C%E5%88%99%EF%BC%8CMN%E4%B8%BAAB%E7%9A%84%E5%9E%82%E7%9B%B4%E5%B9%B3%E5%88%86%E7%BA%BF%E3%80%82.">百度百科</a>的说法，中垂线，又称<strong>垂直平分线</strong>是指经过某一条线段的中点，并且垂直于这条线段的直线。垂直平分线可以看成到线段两个端点距离相等的点的集合，垂直平分线是线段的一条对称轴。好的，那么也就是说中垂线就是过一线段终点所作的平行于该线段的直线，查阅教科书可知，对于由 点 $A(x_1, y_1)$  和 点 $B(x_2, y_2)$ 构成的线段 $AB$ 的中垂线的方程，也称为中垂线方程为<br>$$<br>y - \frac{y_1 + y_2}{2}&#x3D;-\frac{x_1 - x_2}{y_1 - y_2}·\left(x - \frac{x_1 + x_2}{2}\right)<br>$$<br>那么这条方程是怎么得来的呢？</p><p>首先我们知道，线段$AB$ 的 中点$C$ 应该符合中点公式：$C\left(\frac{x_1 + x_2}{2}, \frac{y_1 + y_2}{2}\right)$ ，这是所有初中生都懂得一点。</p><p>然后我们会利用到解析几何中的一条关于两直线垂直的性质：已知两直线 $y &#x3D; k_1x + b_1$ 与 $y &#x3D; k_2x + b_2$ 相互垂直，那么 $k_1 \times k_2&#x3D;-1$ 或者你也可以理解为，两直线垂直，其斜率互为负倒数。</p><p>这时候又产生了一个问题，为什么存在这个性质呢？</p><p>为了解决这个问题，我们需要证明一个猜想：<strong>两直线垂直，斜率互为负倒数</strong> 。（注意，这里的部分证明过程参考知乎用户<a href="https://www.zhihu.com/people/tong-lin-ken-14">双木止月Tong</a> 的文章《<a href="https://zhuanlan.zhihu.com/p/72904288">中垂线</a>》）</p><p>证明过程：<br>$$<br>\begin{array}{l}<br>证明:\<br>取直线\ l_1\ 的方向向量\ (1, k_1)\ ,直线\ l_2 \ 的方向向量\ (1, k_2) \<br>\because l_1 \perp l_2\<br>\therefore (1, k_1) \cdot (1, k_2)&#x3D;1 \times 1 + k_1 \times k_2 &#x3D; 0\<br>\therefore k_1 \cdot k_2 &#x3D; -1\<br>结论得证<br>\end{array}<br>$$</p><p>好了，那么现在我们拥有了这一条公式和一条性质，那么要怎样写出这一条方程呢？</p><p>因为 线段$AB$ 的斜率为 $ k &#x3D; \frac{y_1 - y_2}{x_1 - x_2}$ ，所以中垂线的斜率应该为 $-\frac{1}k{} &#x3D; -\frac{x_1 - x_2}{y_1 - y_2}$ ，又因为 线段$AB$ 的中点坐标为 $ \left(\frac{x_1 + x_2}{2}, \frac{y_1 + y_2}{2}\right)$ 所以根据直线点斜式（$y - b &#x3D; k(x - a)$） 可得： $ y - \frac{y_1 + y_2}{2}&#x3D;-\frac{x_1 - x_2}{y_1 - y_2}·\left(x - \frac{x_1 + x_2}{2}\right)$ 。至此，我们成功的得到了方程，但是为了更方便程序的编写与 DEBUG 我们将方程改写为 $ax + by + c &#x3D; 0$ 的形式：<br>$$<br> \frac{x_1 - x_2}{y_1 - y_2} \cdot x + y - \frac{y_1 + y_2}{2} - \frac{x_1 + x_2}{2} \cdot \frac{x_1 - x_2}{y_1 - y_2} &#x3D; 0<br>$$</p><p>又根据平方差公式 $a^2 - b^2 &#x3D; (a + b) \cdot (a - b)$ ，我们可以将方程进一步化简为：<br>$$<br> \frac{x_1 - x_2}{y_1 - y_2} \cdot x + y - \frac{y_1 + y_2}{2} - \frac{(x_1)^2 - (x_2)^2}{2y_1 - 2y_2} &#x3D; 0<br>$$</p><p>好的，那么关于中垂线解析式的问题，我们已经完全解决了，next one ~</p><p>$$<br>ax + by + c &#x3D; 0<br>$$</p><h2 id="如何求三线的交点？"><a href="#如何求三线的交点？" class="headerlink" title="如何求三线的交点？"></a>如何求三线的交点？</h2><p>首先我们要明确交点的代数意义，对于两条直线 $a_1x + b_1y + c_1 &#x3D; 0$ 和 $a_2x + b_2y + c_2 &#x3D; 0$，如果你在坐标系 $xOy$ 中把他画出来，你就会发现，交点实际上就是同时符合两条方程的 $x$ 与 $y$ 所对应的坐标，也就是说，如果我们联立这两条线性方程（一次方程）得到一个线性方程组（一次方程组），交点的坐标就是该线性方程组的解所对应的点。</p><p>那么我们现在联立这两条方程得到这样一个方程组：<br>$$<br>\left{<br>\begin{array}{l}<br>a_1x + b_1y + c_1 &#x3D; 0\<br>a_2x + b_2y + c_2 &#x3D; 0<br>\end{array}<br>\right.<br>$$<br>然后十分艰难的解出来（用了10 张草稿纸，算了 5 遍 ┭┮﹏┭┮），就会得到：<br>$$<br>\left{<br>\begin{array}{l}<br>x &#x3D; \frac{b_2 \cdot c_1 - b_1 \cdot c_2} {a_2 \cdot b_1 - a_1 \cdot b_2}\<br>y &#x3D; -\frac{a_1x + c_1}{b_1}<br>\end{array}<br>\right.<br>$$</p><p>那么三条线的交点怎么求呢？实际上，我们根本不需要求三条线的交点，我们只需要求两条线的交点即可，因为我们两条中垂线是交于一点的，而三条中垂线依然是交于一点，所以我们可以发现，只需要两条中垂线就可以确定一个三角形的外心。</p><p>下班（才怪）！！！</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们现在已经掌握了理论知识，下面是实现的过程。</p><p>首先我们需要定义两个结构体，分别名为 <code>dot</code> 和 <code>line</code> 用于存储 <strong>点</strong> 和 <strong>线</strong>，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dot</span> &#123;<br>    <span class="hljs-comment">// x 坐标， y 坐标</span><br>    <span class="hljs-type">double</span> x, y;<br><br>    <span class="hljs-comment">// 计算与其他点的距离（勾股定理）</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">const</span> dot a)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((a.x - x) * (a.x - x) + (a.y - y) * (a.y - y));<br>    &#125;<br><br>    <span class="hljs-comment">// 判断点是否相等</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> dot a) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a.x - x) &lt;= <span class="hljs-number">0.3</span> || <span class="hljs-built_in">abs</span>(a.y - y) &lt;= <span class="hljs-number">0.3</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span> &#123;<br>    <span class="hljs-comment">// a, b, c 对应 ax + by + c = 0 中的 a, b, c</span><br>    <span class="hljs-type">double</span> a, b, c;<br>&#125;;<br></code></pre></td></tr></table></figure><p> 然后只要把各种公式实现以下即可，全部代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dot</span> &#123;<br>    <span class="hljs-comment">// x 坐标， y 坐标</span><br>    <span class="hljs-type">double</span> x, y;<br><br>    <span class="hljs-comment">// 计算与其他点的距离（勾股定理）</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">const</span> dot a)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((a.x - x) * (a.x - x) + (a.y - y) * (a.y - y));<br>    &#125;<br><br>    <span class="hljs-comment">// 判断点是否相等</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> dot a) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a.x - x) &lt;= <span class="hljs-number">0.3</span> || <span class="hljs-built_in">abs</span>(a.y - y) &lt;= <span class="hljs-number">0.3</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span> &#123;<br>    <span class="hljs-comment">// a, b, c 对应 ax + by + c = 0 中的 a, b, c</span><br>    <span class="hljs-type">double</span> a, b, c;<br>&#125;;<br><br><span class="hljs-comment">// 根据两个点获得中垂线</span><br><span class="hljs-function">line <span class="hljs-title">get_mid_perpendicular</span><span class="hljs-params">(dot a, dot b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (line) &#123;<br>            (a.x - b.x) / (a.y - b.y),<br>            <span class="hljs-number">1</span>,<br>            -(a.y + b.y) / <span class="hljs-number">2</span> - (a.x * a.x - b.x * b.x) / (<span class="hljs-number">2</span> * a.y - <span class="hljs-number">2</span> * b.y)<br>    &#125;;<br>&#125;<br><br><span class="hljs-comment">// 计算交点</span><br><span class="hljs-function">dot <span class="hljs-title">get_intersection</span><span class="hljs-params">(line a, line b)</span> </span>&#123;<br>    <span class="hljs-type">double</span> a1 = a.a, a2 = b.a, b1 = a.b, b2 = b.b, c1 = a.c, c2 = b.c;<br>    <span class="hljs-type">double</span> x = (b2 * c1 - b1 * c2) / (a2 * b1 - a1 * b2), y = -(a1 * x + c1) / b1;<br>    <span class="hljs-keyword">return</span> (dot) &#123;x, y&#125;;<br>&#125;<br><br><span class="hljs-comment">// 计算外心</span><br><span class="hljs-function">dot <span class="hljs-title">get_circumcenter</span><span class="hljs-params">(dot a, dot b, dot c)</span> </span>&#123;<br>    line mid_perpendicular1 = <span class="hljs-built_in">get_mid_perpendicular</span>(a, b), mid_perpendicular2 = <span class="hljs-built_in">get_mid_perpendicular</span>(b, c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_intersection</span>(mid_perpendicular1, mid_perpendicular2);<br>&#125;<br><br>dot a[<span class="hljs-number">5</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span>; i++) &#123;<br>        cin &gt;&gt; a[i].x &gt;&gt; a[i].y;<br>    &#125;<br>    dot circumcenter1 = <span class="hljs-built_in">get_circumcenter</span>(a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>]), circumcenter2 = <span class="hljs-built_in">get_circumcenter</span>(a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">4</span>]);<br>    <span class="hljs-keyword">if</span> (circumcenter1 == circumcenter2) &#123;<br>        cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6f %.6f %.6f&quot;</span>, (circumcenter<span class="hljs-number">1.</span>x), (circumcenter<span class="hljs-number">1.</span>y), (circumcenter<span class="hljs-number">1.</span><span class="hljs-built_in">dis</span>(a[<span class="hljs-number">1</span>])));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6f %.6f %.6f&quot;</span>, (circumcenter<span class="hljs-number">1.</span>x), (circumcenter<span class="hljs-number">1.</span>y), (circumcenter<span class="hljs-number">1.</span><span class="hljs-built_in">dis</span>(a[<span class="hljs-number">1</span>])));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass PUJI 971 题解</title>
    <link href="/posts/25ad433c.html"/>
    <url>/posts/25ad433c.html</url>
    
    <content type="html"><![CDATA[<h1 id="数学题！！！"><a href="#数学题！！！" class="headerlink" title="数学题！！！"></a>数学题！！！</h1><p>为了方便化简式子，我们首先简单的将</p><p>$$<br>d(x, y)&#x3D;y-x<br>$$</p><p>替代</p><p>$$<br>d(x, y)&#x3D;\left{<br>\begin{array}{l}<br>0\ \ (|x - y|\le1)\<br>y - x\ \ (|x - y| &gt; 1)<br>\end{array}<br>\right.<br>$$</p><p>那么就可以令 $n &#x3D; 4$ 将原式（</p><p>$$<br>\sum^{n}<em>{i &#x3D; 1}\sum</em>{j &#x3D; i +1}^n d(a_j, a_i)<br>$$</p><p>）转换为这样的一个表格：</p><table><thead><tr><th>$i &#x3D; 1$</th><th>$a_2 - a_1$</th><th>$a_3 - a_1$</th><th>$a_4 - a_1$</th></tr></thead><tbody><tr><td>$i &#x3D; 2$</td><td>$a_3 - a_2$</td><td>$a_4 - a_2$</td><td></td></tr><tr><td>$i &#x3D; 3$</td><td>$a_4 - a_3$</td><td></td><td></td></tr></tbody></table><p>如果我们把它加上一行，得到这样一个表格：</p><table><thead><tr><th></th><th>$j &#x3D; 3$</th><th>$j &#x3D; 2$</th><th>$j &#x3D; 1$</th></tr></thead><tbody><tr><td>$i &#x3D; 1$</td><td>$a_2 - a_1$</td><td>$a_3 - a_1$</td><td>$a_4 - a_1$</td></tr><tr><td>$i &#x3D; 2$</td><td>$a_3 - a_2$</td><td>$a_4 - a_2$</td><td></td></tr><tr><td>$i &#x3D; 3$</td><td>$a_4 - a_3$</td><td></td><td></td></tr></tbody></table><p>然后我们写出一条按列求和的算式：</p><p>$$<br>\sum_{j &#x3D; 1}^{n} (a_{j +1} - a_j) + (a_{j + 2} - a_j) + … + (a_{n - 1} - a_j) + (a_{n} - a_j)<br>$$</p><p>$$<br>令\ s_i &#x3D; \sum_{j &#x3D; 1}^{i} a_j\ \ (即\ s\ 是\ a\ 的前缀和)<br>$$</p><p>我们根据表中可以看出的规律将符号为正的 $a_j$ 项放到一起，我们会发现他们的和是 $s_n - s_{n - j} - s_j$</p><p>同理，我们把符号为负的项求和，得到 $s_j$</p><p>然后我们就会得到每一列的和就是</p><p>$$<br>s_{n} - s_{n - j} - s_j<br>$$</p><p>我们将每一列求和，得到式子：</p><p>$$<br>\sum_{j &#x3D; 1}^n s_{n} - s_{n - j} - s_j<br>$$</p><p>这时候，我们已经得到的一个部分解，现在让我们考虑题目中给出的情况，即：</p><p>$$<br>d(x, y)&#x3D;\left{<br>\begin{array}{l}<br>0\ \ (|x - y|\le1)\<br>y - x\ \ (|x - y| &gt; 1)<br>\end{array}<br>\right.<br>$$</p><p>我们就会发现，如果 $d(x, y)&#x3D;y - x$ ，那么 $d(x, x - 1) &#x3D; -1$ 对于我们题目中的函数 $d(x, y)$ 来说，这一个值很显然小了 $1$，所以我们需要统计这种情况，然后在答案中补偿进去，同理，当 $d(x, x +1) &#x3D; 1$ 时，我们多计算了 $1$ ，所以我们需要在最终的答案里面减去这个 $1$。</p><p>那么我们如何知道这个 $x +1$ 或者 $x - 1$ 的个数呢？很显然，我们可以使用一个桶数组 $ cnt $来解决，我们只需要在计算时减去 $cnt_{a_j - 1}$ 再加上 $cnt_{a_j + 1}$ 即可，注意要 $cnt_{a_i} +&#x3D; 1$</p><p>好了，那么我们的思路就是这样，下面时 ctjers 的最爱，代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, ans, a[<span class="hljs-number">100009</span>], s[<span class="hljs-number">100009</span>], cnt[<span class="hljs-number">100009</span>];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cin &gt;&gt; a[i];<br>s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>ans += s[n] - s[n - i] - s[i];<br>ans -= cnt[a[i] - <span class="hljs-number">1</span>];<br>ans += cnt[a[i] + <span class="hljs-number">1</span>];<br>cnt[a[i]] += <span class="hljs-number">1</span>;<br>&#125;<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass PUJI P1296 题解</title>
    <link href="/posts/372de39.html"/>
    <url>/posts/372de39.html</url>
    
    <content type="html"><![CDATA[<h1 id="这是一道几何题"><a href="#这是一道几何题" class="headerlink" title="这是一道几何题"></a>这是一道几何题</h1><p>看到题目，我们会发现，题目需要我们找到四个点，构成一些正方形（即四边等长的矩形，这个很重要，后面会用到），然后输出可以构成的正方形的个数</p><p>好的，那么作为一个暴力骗分的小能手，我的第一反应就是暴力，简单估一下，如果有 $n$ 个点，那么时间复杂度就是 $O(n^4)$ 很明显，这个时间复杂度直接原地起飞了，能 AC 我直接把题目吃下去好吧</p><p>那么我们现在就要来考虑如何尽可能的减少枚举的点的数量，由于正方形只有四个顶点，那么我们考虑以下几种可能：</p><ul><li>只有一个点，如图1，我们就可以看到，一个点可以确定无数个正方形，因此这种方法是不对滴！</li></ul><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E5%9B%BE1.png" srcset="/img/loading.gif" lazyload alt="图1"></p><ul><li>两个点，如图2，我们可以发现，只需要两个点，我们就可以完美的定位三个正方形，✌🏻</li></ul><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E5%9B%BE2.png" srcset="/img/loading.gif" lazyload alt="图2"></p><p>那我们要怎样通过已知的两个不重合的点获得另外两个点的坐标呢？首先我们需要一些前置的知识</p><ol><li><p>如何判断三角形全等：根据极其聪明的 New Bing 的回答，判断三角形全等有五种方法：1、SSS（边边边）：三边对应相等的三角形是全等三角形。2、SAS（边角边）：两边及其夹角对应相等的三角形是全等三角形。3、ASA（角边角）：两角及其夹边对应相等的三角形全等。4、AAS（角角边）：两个内角和一条外接边分别对应相等的两个三角形全等。5、HL（斜直直）：直角三角形中，斜边和一条直角边分别对应相等的两个三角形全等。我感觉还是比较准确的，OK，那么下一个</p></li><li><p>平面直角坐标系：从 New Bing 的口中可以得知：平面直角坐标系是一种用来表示平面内点的位置的方法。它由两条互相垂直且有公共原点的数轴组成，分别称为 $x$ 轴和 $y$ 轴。任何一个平面内的点都可以用一对有序数 $(x, y)$ 来表示，这就是它的坐标。此外，平面直角坐标系还有一些有用的性质：平面直角坐标系有一些基本的性质，例如：</p><ul><li>坐标平面内的点与有序实数对一一对应</li></ul><ul><li>两个点的中点的坐标是它们的坐标的算术平均数</li><li>两个点之间的距离等于它们的横纵坐标差的平方和的开方</li><li>平行线具有相同或相反的斜率</li></ul></li></ol><p>如图3，我们构建一个平面直角坐标系，在坐标系上确认两点，分别定义为 <strong>点 $A$</strong> 和 <strong>点 $B$</strong> ，这两个点的坐标分别是 $(x1, y1)$ 和 $(x2, y2)$ .</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E5%9B%BE3.png" srcset="/img/loading.gif" lazyload alt="图3"></p><p>这时候，我们应该如何求出图片中 **点 $C$ ** 与 <strong>点 $D$</strong> 的坐标呢，我们可以过 点 $A$ 做一条平行于 $y$ 轴的直线，在过 点 $C$ 做一条与 $x$ 轴平行的直线，将两条直线的交点记为 **点 $E$**，使得 $\angle AEC&#x3D;90 \degree$ ，同理，画出另外四面的角，如图4. </p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E5%9B%BE4.png" srcset="/img/loading.gif" lazyload alt="图4"></p><p>那么我们就可以发现，好像 $AE&#x3D;BH&#x3D;FG&#x3D;CD$ 且 $AH&#x3D;CE&#x3D;DF&#x3D;BG$ ，但是我们并没有证据，如果比赛的话我就直接打了，但是我们现在是正常做题，因此我们需要尝试证明一下这两条公式。观察可以发现，我们只需要证明 $\triangle AEC\cong \triangle CDF\cong\triangle BGF\cong\triangle AHB$ ，就可以证明以上的两个猜测，那么下面是严谨的证明步骤：<br>$$<br>\begin{array}{lr}<br>\because \angle HAB + \angle ABH&#x3D;180 \degree - \angle AGH &#x3D;180\degree - \angle BAC &#x3D; 90\degree \<br>又 \because \angle HAG + \angle EAC&#x3D;180\degree-\angle BAC&#x3D;90 \degree\<br>\therefore \angle HAB+\angle EAC&#x3D; \angle HAB+\angle ABH\<br>\therefore \angle EAC&#x3D;\angle ABH\<br>\because \angle AHB&#x3D;\angle AEC,\ \angle EAC&#x3D;\angle ABH,\ AB&#x3D;AC\<br>\therefore \triangle AEC \cong \��用 New Bing （不知道为什么我的比起 Chrome 好像没什么特殊的功能）。你只需要在<a href="https://www.microsoftedgeinsider.com/zh-cn/">这个连接</a>里面下载安装就可以了<br>2.   然后你需要安装一个浏览器插件：<a href="https://microsoftedge.microsoft.com/addons/detail/modheader-modify-http-h/opgbiafapkbbnbnjcdomjaghbckfkglc">ModHeader - Modify HTTP headers - Microsoft Edge Addons</a><br>3.   然后你需要把插件设置成这样：<img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E6%88%AA%E5%B1%8F2023-03-04%2014.52.11.png" srcset="/img/loading.gif" lazyload alt="截屏2023-03-04 14.52.11"></p><p>步骤的话实际上还好，首先把原本就有的 <em><strong>Request headers</strong></em> 栏里面填上”X-Forwarded-For” 和 “9.9.9.9”，然后点击 “+ mod” -&gt; “Redirect URL” 然后把 <em><strong>Redirect URL</strong></em> 栏里面填上 “.<em>:&#x2F;&#x2F;<a href="http://www.bing.com/">www.bing.com/</a>.</em>“ 和 “(空)” </p><ol start="4"><li>访问 <a href="https://www.bing.com/new">www.bing.com/new</a> 点击申请，直接加入候补名单，然后等待收到通过的邮件</li><li>收到邮件以后，打开 <a href="https://www.bing.com/">www.bing.com</a> 然后点击左上角的 “聊天” ，就可以和世界上最聪明的 AI 玩耍啦啦啦</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P2261 题解</title>
    <link href="/posts/c0f28fe.html"/>
    <url>/posts/c0f28fe.html</url>
    
    <content type="html"><![CDATA[<h1 id="这道题实际上很简单"><a href="#这道题实际上很简单" class="headerlink" title="这道题实际上很简单"></a>这道题实际上很简单</h1><p>先看题目，会发现，这道题似乎很想模拟题，但是又好像不是，因为用正常的方法没法模拟，或者说很难模拟。<del>看标签</del>仔细观察就可以知道，这是一道数据结构相关的模版题，具体会用到队列。</p><h3 id="思路如下："><a href="#思路如下：" class="headerlink" title="思路如下："></a>思路如下：</h3><ul><li>首先输入题目中提到的 $n$ 和 $c$ </li><li>在队列中压入 $1 \to n$ 的所有自然数，对于 $n &#x3D; 6$ 的情况，队列应该是这样的：$队头\ 1,2,3,4,5,6\ 队尾$ </li><li>进行一个 <code>while</code> 循环，循环的条件是 <code>!q.empty() //q 是一个队列</code> 在循环中，如果这个报数报到 $c$ 了，那么就输出当前的这个数（即队头），如果还没有报到，那么就将现在的队头扔到队尾（<code>q.push(q.front()); q.pop();</code>），方便后面输出。</li></ul><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><p>实现其实非常简单，只需要创建一个队列，按照思路的前两步做，对于第三步，我们需要创建一个临时变量 $p$ ，如果 $p&#x3D;c$ 那么输出，同时将 $p$ 赋值为 $1$ ，如果不符合条件（$!(p&#x3D;c)$），那么就 $p &#x3D;p+1$ . 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, c;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; c;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (p == c) &#123;<br>            cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            p = <span class="hljs-number">1</span>;<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            q.<span class="hljs-built_in">push</span>(q.<span class="hljs-built_in">front</span>());<br>            q.<span class="hljs-built_in">pop</span>();<br>            p += <span class="hljs-number">1</span>;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass 新 C 班选拔测试题解</title>
    <link href="/posts/52544bc3.html"/>
    <url>/posts/52544bc3.html</url>
    
    <content type="html"><![CDATA[<h1 id="终于考完了"><a href="#终于考完了" class="headerlink" title="终于考完了"></a>终于考完了</h1><p>额，这次一共 6 题，3 个小时，时间还是有点紧张，但是由于题目太难，最后还是比较舒服的拿了 15 名（总共多少人就不说了）。但是，满分 600 只<del>骗</del>拿到了 150。确实菜了点，下面总结一下每一道题目</p><h2 id="A-P3256-排队"><a href="#A-P3256-排队" class="headerlink" title="A. #P3256. 排队"></a><a href="http://www.oiclass.com/p/P3256">A. #P3256. 排队</a></h2><p>这一题一看就是打卡题，但是也是正常比赛我唯一 AC 的一题，呜呜。这道题又是一道 oiclass 从其他地方搬运的题，好像是来自 JZOI 的，但是我没有找到。直接进入正题</p><h3 id="先看题目"><a href="#先看题目" class="headerlink" title="先看题目"></a>先看题目</h3><p>一共有 $n$ 个 <strong>TYoier</strong> ，有一些是<strong>巨佬</strong>一些是<strong>蒟蒻</strong>，然后因为巨佬比较喜欢打架，所以巨佬时间必须有 $≥k$ 个的蒟蒻隔着，才不会打架。然后这个时候，闲得发慌的 CXL 就想让我们把不会打架的方案个数算出来（幸好不用输出每一种方案）。</p><p>看完题目</p><h3 id="分析样例"><a href="#分析样例" class="headerlink" title="分析样例"></a>分析样例</h3><p>样例的情况是 $n&#x3D;4,\ \ k&#x3D;2$ 也就是说至少要隔开两个蒟蒻，大佬们才不会打架。那么我们分析一下究竟是哪几种方案是不会打架的</p><ul><li>首先是没有大佬的情况，这个时候只有一种可能，即全是蒟蒻。</li><li>其次是有一位大佬的情况，这个时候有以下几种可能（<code>B</code> 为大佬，<code>C</code> 为蒟蒻）：$\left{\begin{array}{lr}CBBB\BCBB\BBCB\BBBC \end{array} \right.$   一共四种情况。</li><li>在最后是有两位大佬的情况，这是只有一种可能，即：$BCCB$。</li></ul><p>$\therefore 一共有\ 6\ 种可能，即\ ans&#x3D;6$</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们这道题采用<strong>动态规划</strong>（DP）的方法。我们以每一个位置为一个阶段，并将阶段储存在一维数组 $f$ 内，也就是说有 $n$ 个阶段。</p><p>对于第 $i$ 个阶段（$0&lt;i≤n$），有两种可能：<br>$$<br>\begin{array}{lr}<br>若\ i≤k:\<br>则: f_i&#x3D;(i+1)\ mod\ 5000011\<br>若：i&gt;k\<br>则:f_i&#x3D;(f_{i-1}+f_{i-k-1})\ mod\ 5000011<br>\end{array}<br>$$<br>也就是说我们的状态转移方程是这样的：<br>$$<br>f_i&#x3D;\left{\begin{array}{lr}<br>i≤k\ \ \ \ \ (i+1)\ mod\ 5000011\<br>i&gt;k\ \ \ \ \ (f_{i-1}+f_{i-k-1})\ mod\ 5000011<br>\end{array}\right.<br>$$<br>那么我们的边界条件是什么呢？通过我们的分析，我们可以看出，边界条件就是 $f_i&#x3D;i+1\ \ (0&lt;i≤k)$ </p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现的话很简单，只需要模拟就可以，注意一点：循环一定要从 $0$ 开始，如果不是的话，那么等着 WA 吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, k, f[<span class="hljs-number">100009</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt;= k) &#123;<br>            f[i] = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">5000011</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            f[i] = (f[i - <span class="hljs-number">1</span>] + f[i - k - <span class="hljs-number">1</span>]) % <span class="hljs-number">5000011</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="B-C-D-E-F-未完待续，欢迎催更"><a href="#B-C-D-E-F-未完待续，欢迎催更" class="headerlink" title="B, C, D, E, F 未完待续，欢迎催更"></a>B, C, D, E, F 未完待续，欢迎催更</h2>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1266 题解</title>
    <link href="/posts/9f2847e6.html"/>
    <url>/posts/9f2847e6.html</url>
    
    <content type="html"><![CDATA[<h1 id="这道题绝对称得上是-DP-Ultra"><a href="#这道题绝对称得上是-DP-Ultra" class="headerlink" title="这道题绝对称得上是 DP Ultra"></a>这道题绝对称得上是 <strong>DP Ultra</strong></h1><p>So, what is <em>DP Ultra</em> ? The answer is: 环形区间 DP ！！！！！！！真的离谱！！！</p><h2 id="1-划分阶段"><a href="#1-划分阶段" class="headerlink" title="1. 划分阶段"></a>1. 划分阶段</h2><p>一共有 $2 \times n$ 个阶段，每个阶段表示 $i$ 开始 $j$ 结束的区间里面一共最多能产生多少能量。</p><h2 id="2-定义状态变量"><a href="#2-定义状态变量" class="headerlink" title="2. 定义状态变量"></a>2. 定义状态变量</h2><p>直接搞一个万能二维数组 $f$ ， $f_{i,\ j}$ 表示一个阶段，也就是表示 $i$ 开始 $j$ 结束的区间里面一共最多能产生多少能量</p><h2 id="3-写出状态转换方程"><a href="#3-写出状态转换方程" class="headerlink" title="3. 写出状态转换方程"></a>3. 写出状态转换方程</h2><p>这里用递归来解，<code>func(int x, int y)</code> 就是本次的主角——递归函数。为了尽量优化，这里使用了记忆化的方法进行剪枝（用于记忆的是二维数组 $f$），速度还行吧，至少没超时，对于函数体。如果 $x&#x3D;y$ 那么直接退出，毕竟全部遍历完了，如果 $f_{x,\ y}$ 已经有值，那么直接返回就行，如果都不行，那么进行计算，计算需要便利 $x \to y$ 的每一个点，然后通过方程计算他的值，取所有值的最大值即可，用于计算的公式如下：<br>$$<br>f_{x,\ y}&#x3D;\max(f_{x,\ y}, func(x, i) + func(i + 1, y) + a_x * a_{i + 1} * a_{y + 1});<br>$$</p><h2 id="4-边界条件"><a href="#4-边界条件" class="headerlink" title="4. 边界条件"></a>4. 边界条件</h2><p>边界条件是这道题目最为良心的了，因为头尾相同的时候，最大值一定为 $0$ ，毕竟一颗珠子都没有，所以这个题目的边界条件就是：<br>$$<br>f_{i,\ i}&#x3D;0<br>$$<br>因为他 $&#x3D;0$ 所以很庆幸，我们不需要对数组进行任何操作，初始值就是 $0$，大妙了</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>实现绝非易事，首先要考虑到这个东西是项链！！也就是环，那么我们采用经典的破环为链的方法（高情商），也可以说是用数组模拟一个环（低情商），简单说就是把数组镜像一遍贴在原数组的尾部（Ctrl - C + Ctrl - V），也就形成了一个主观上的环型了。为了形成这个环形，我们的数组实际上存储了 $2 \times n$ 个数据，虽然听起来时间空间翻倍，但是这已经是最优解了。计算的时候我们首先遍历 $a_{1 \to n}$ 的每一个位置，调用函数 <code>func(i, i + n - 1)</code> 计算当前起点的最大值，然后将其与目前存储的最大值比较，得到新的最大值，在函数内部，我们用 （3）中提到的逻辑进行计算，同时使用记忆化的方式进行剪枝，避免空间时间双爆的满江红。下面看一下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, ans = <span class="hljs-number">-2147483647</span>, a[<span class="hljs-number">1000009</span>], f[<span class="hljs-number">5009</span>][<span class="hljs-number">5009</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x == y) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (f[x][y]) &#123;<br>        <span class="hljs-keyword">return</span> f[x][y];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt; y; i++) &#123;<br>        f[x][y] = <span class="hljs-built_in">max</span>(f[x][y], <span class="hljs-built_in">func</span>(x, i) + <span class="hljs-built_in">func</span>(i + <span class="hljs-number">1</span>, y) + a[x] * a[i + <span class="hljs-number">1</span>] * a[y + <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[x][y];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        a[i + n] = a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">func</span>(i, i + n - <span class="hljs-number">1</span>));<br>    &#125;<br>    cout &lt;&lt; ans;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1238 题解</title>
    <link href="/posts/c035109b.html"/>
    <url>/posts/c035109b.html</url>
    
    <content type="html"><![CDATA[<h1 id="又是一道烧脑的模板题"><a href="#又是一道烧脑的模板题" class="headerlink" title="又是一道烧脑的模板题"></a>又是一道烧脑的<strong>模板题</strong></h1><p>进入正题，以下是传统得无与伦比的五步</p><h2 id="1-划分阶段"><a href="#1-划分阶段" class="headerlink" title="1. 划分阶段"></a>1. 划分阶段</h2><p>这里以每一种花为一个阶段，表示从第 $1$ 种花到这一种花之间的所有花一共最多能有几种方案</p><h2 id="2-状态和状态变量"><a href="#2-状态和状态变量" class="headerlink" title="2. 状态和状态变量"></a>2. 状态和状态变量</h2><p>直接用一个二维数组 $f$ 用来存状态，状态： $f_{i,\ j}$ 表示 表示第 $i$ 种花共摆了 $j$ 盆时一共最多能有几种方案，也就是一个最优解。</p><h2 id="3-确定决策和状态转移方程"><a href="#3-确定决策和状态转移方程" class="headerlink" title="3. 确定决策和状态转移方程"></a>3. 确定决策和状态转移方程</h2><p>这里，状态还算简单：<br>$$<br>f_{i,\ j}&#x3D;f_{i,\ j} + f_{i-1,\ j-k}<br>$$<br>不过如果你直接这样算，会直接爆掉，因为你忘记 $%1000007$ 这是非常重要的一个部分，所以改进一下，方程应改变成这样：<br>$$<br>f_{i,\ j}&#x3D;(f_{i,\ j}+f_{i-1,\ j-k})<br>$$</p><h2 id="4-边界"><a href="#4-边界" class="headerlink" title="4. 边界"></a>4. 边界</h2><p>$$<br>f_{0\to n,\ 0}&#x3D;1<br>$$</p><h2 id="5-实现："><a href="#5-实现：" class="headerlink" title="5. 实现："></a>5. 实现：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> m, n, a[<span class="hljs-number">109</span>], f[<span class="hljs-number">109</span>][<span class="hljs-number">109</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        f[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= <span class="hljs-built_in">min</span>(j, a[i]); k++) &#123;<br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j - k] + f[i][j];<br>                f[i][j] %= <span class="hljs-number">1000007</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[n][m] % <span class="hljs-number">1000007</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1255 题解</title>
    <link href="/posts/282a7cc0.html"/>
    <url>/posts/282a7cc0.html</url>
    
    <content type="html"><![CDATA[<h1 id="又是一个我背不动的背包"><a href="#又是一个我背不动的背包" class="headerlink" title="又是一个我背不动的背包"></a>又是一个我背不动的背包</h1><p>这次是 0&#x2F;1 背包 plus——多重背包，下面是经典的五步</p><h2 id="1-划分阶段"><a href="#1-划分阶段" class="headerlink" title="1. 划分阶段"></a>1. 划分阶段</h2><p>以每一个物品为一个阶段，表示这个物品前的物品的最大值（包括这个物品自身）。</p><h2 id="2-确定状态和状态变量"><a href="#2-确定状态和状态变量" class="headerlink" title="2. 确定状态和状态变量"></a>2. 确定状态和状态变量</h2><p>搞一个一维数组 $f$ ，即 $f_i$ 表示第 $1$ 个物品到第 $i$ 个物品之间（算头算尾）的最优解，也就是在空间不超过 $v$ 的情况下最大的价值总和。</p><h2 id="3-确定决策并写出状态转移方程"><a href="#3-确定决策并写出状态转移方程" class="headerlink" title="3. 确定决策并写出状态转移方程"></a>3. 确定决策并写出状态转移方程</h2><p>决策方式不算复杂，对于一个状态 $f_i$ 他可以有以下两种取值方式：<br>$$<br>\left{<br>\begin{array}{lr}<br>f_{i}&#x3D;f_{i-1}\<br>f_i&#x3D;f_{i-w_i}+v_i<br>\end{array}<br>\right.<br>$$<br>对于这两种取值的方式，调大的就行，不用考虑太多，简化一下就是这样：<br>$$<br>f_i&#x3D;\max(f_{i-1},\ f_{i-w_i}+v_i)<br>$$</p><h2 id="4-边界条件"><a href="#4-边界条件" class="headerlink" title="4. 边界条件"></a>4. 边界条件</h2><p>对于几乎所有背包，所有边界条件都是没有边界条件，也就是边界条件为 $0$ 。这道题目也不例外</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>直接模拟，记得第二层循环要倒序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, v, W, S, M, total, w[<span class="hljs-number">20009</span>], s[<span class="hljs-number">20009</span>], f[<span class="hljs-number">2009</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; v;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; M &gt;&gt; W &gt;&gt; S;<br>        M = <span class="hljs-built_in">min</span>(M, v / W);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= M; j &lt;&lt;= <span class="hljs-number">1</span>) &#123;<br>            w[++total] = W * j;<br>            s[total] = S * j;<br>            M -= j;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (M &gt; <span class="hljs-number">0</span>) &#123;<br>            w[++total] = W * M;<br>            s[total] = S * M;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= total; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = v; j &gt;= w[i]; j--) &#123;<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - w[i]] + s[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[v];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1246 题解</title>
    <link href="/posts/b1de6f60.html"/>
    <url>/posts/b1de6f60.html</url>
    
    <content type="html"><![CDATA[<h1 id="你说为什么-01-背包模板不是偷东西呢？"><a href="#你说为什么-01-背包模板不是偷东西呢？" class="headerlink" title="你说为什么 01 背包模板不是偷东西呢？"></a>你说为什么 01 背包模板不是偷东西呢？</h1><p>额，搞错了，再来！</p><h2 id="1-划分阶段"><a href="#1-划分阶段" class="headerlink" title="1. 划分阶段"></a>1. 划分阶段</h2><p>一共划分 $M$ 个阶段，每个阶段表示在这个阶段可以采的最多的草药</p><h2 id="2-确定状态和状态变量"><a href="#2-确定状态和状态变量" class="headerlink" title="2. 确定状态和状态变量"></a>2. 确定状态和状态变量</h2><p>状态变量就用一个二维数组 $f$ 吧，也就是说 $f_{i,\ j}$ 表示前 $i$ 颗草药在前 $j$ 的时间可以获得最大价值，也就是说我们想求的是用 $j$ 的时间，如何在 $a_{1 \to i}$ 的草药中获得最大价值，<del>简单说就是他想赚多点钱</del></p><h2 id="3-写出状态转换方程并确定决策"><a href="#3-写出状态转换方程并确定决策" class="headerlink" title="3. 写出状态转换方程并确定决策"></a>3. 写出状态转换方程并确定决策</h2><p>这里我们现出不的写出一条状态转移方程：<br>$$<br>f_{i,\ j} &#x3D; \max\left(f_{i-1,\ j-t_{i}}+v_i,\ f_{i-1,\ j}\right)\ \ \ \ （\ t\ 数组为采药耗时，v\ 数组为草药价值\ ）<br>$$<br>然后我们可以发现，如果 $j&lt;t_i$ 这个式子他就乱套了，数组下标怎么能是负的呢。所以我们需要特判一下 $j&lt;t_i$ 的情况，避免 RE 。那么在这种情况的时候，状态要怎么计算呢，我们可以发现，在这个时候，我们无法采摘新的草药，也就是说我们可以直接沿用 $f_{i-1,\ j}$ 的情况。那么我们就可以写出完整地方程了：<br>$$<br>f_{i,\ j} &#x3D; \left{\begin{array}{lr}<br>j&lt;t_i\ \ \ \ \ f_{i-1,\ j}\<br>j≥t_i\ \ \ \ \ f_{i-1,\ j-t_{i}}+v_i<br>\end{array}\right.<br>$$<br>行，那么我们可以进行下一步了对..吧…..。额，这个方程看起来不够<strong>简洁优雅</strong>观察一下可以发现，实际上这个方程可以被压缩成一维的，这样可读性就高很多了。我们考虑一下，究竟是减掉可选物品呢？还是减掉时间呢？很明显，时间对我们来说更重要，所以我们尝试减掉物品这一维。我们首先直接无脑去掉他。发现会有一个问题，就是一个物品会有重复选择的问题。我们观察可以发现，如果我们这一步的操作是 $f_{i,\ j} &#x3D; f_{i-1,\ j}$ 的话，实际上就是直接复制了上一项的值，这里相信大家都是清楚的，那么如果我们这一步的操作是 $f_{i,\ j} &#x3D; f_{i-1,\ j-t_i}+v_i$  的话这又意味着什么呢？仔细想一下，我们可以发现着意味着我们使用 $t_i$ 的时间使得我们多得到了 $v_i$ 的价值所以我们需要回退倒 <em><strong>只能选上一颗草药，只有 $j-t_i$ 的时间</strong></em> 时的最优解然后在其基础上增加 $v_i$ 的价值，所以我们发现实际上对我们有用的只有原数组的 $j$ 下标，而 $i$ 下标只是纯粹递增的而已。所以到这里，我们可以基本确定，我们的确可以去掉 $i$ 下标，同时保持程序正常运行。那么你就会发现，虽然理论上可以，但是实际翻车了，这里是因为：我们在计算 $f_j\ (\ 即\ f_{i,\ j}\ )$ 的时候，我们需要 $f_{j-t_i}\ (\ 即\ f_{i,\ j-t_i}\ )$ 的值，而因为 $j&lt;j-t_i$ 所以如果我们按照正常的顺序遍历的方法，会造成一个结果被重复使用，也就是一颗草药被摘很多次的情况，很显然这是我们不想看到的，因此我们需要倒叙遍历这个数组，方程也就简化成这样了：<br>$$<br>f_j&#x3D;\left{\begin{array}{lr}<br>j&lt;t_i\ \ \ \ \ f_j\<br>j≥t_i\ \ \ \ \ f_{j-t_i}+v_i<br>\end{array}\right.<br>$$</p><p>而这条公式又可以简化成一行，同时不造成值的错误（尽管有些溢出的风险）：<br>$$<br>f_j&#x3D;\max(f_j,\ f_{j-t_i}+v+i)<br>$$<br>终于搞完了</p><h2 id="4-初始条件"><a href="#4-初始条件" class="headerlink" title="4. 初始条件"></a>4. 初始条件</h2><p>在什么时间都没有的情况下，我们不可能摘到草药，所以 $f_0&#x3D;0$ 而又因为数组的初始值就是 $0$ 所以我们再次不需要进行任何操作，妙啊！！！！</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>直接模拟，上代码！：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> times, m, t[<span class="hljs-number">109</span>], v[<span class="hljs-number">109</span>], f[<span class="hljs-number">10001</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; times &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        cin &gt;&gt; t[i] &gt;&gt; v[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = times; j &gt;= t[i]; j--) &#123;<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - t[i]] + v[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[times];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1928 题解</title>
    <link href="/posts/2faeff2f.html"/>
    <url>/posts/2faeff2f.html</url>
    
    <content type="html"><![CDATA[<h1 id="这道题简直拓宽了回文这个词的定义"><a href="#这道题简直拓宽了回文这个词的定义" class="headerlink" title="这道题简直拓宽了回文这个词的定义"></a>这道题简直拓宽了<strong>回文</strong>这个词的定义</h1><p>天哪，我见回文数，回文分解，回文日，还真的没有见过回文词，而且这个词还毫无任何美感可言，其他回文可都是很优雅的呀。不吐槽了，进入正题</p><h2 id="1-划分阶段"><a href="#1-划分阶段" class="headerlink" title="1. 划分阶段"></a>1. 划分阶段</h2><p>这里定义两个字符串，$a$ 和 $b$ ，$a$ 是输入的字符串，$b$ 是 $a$ 的反串。对于这两个字符串，一共有  $2 \times a.length()$ 种状态，也可以说有 $a.length() + b.length()$ 种状态</p><h2 id="2-确定状态和状态变量"><a href="#2-确定状态和状态变量" class="headerlink" title="2. 确定状态和状态变量"></a>2. <strong>确定状态和状态变量</strong></h2><p>状态变量用一个二维数组 $f$ ，对于一个状态 $f_{i,\ j}$ 他表示的是字符串 $a$ 的前 $i$ 个字符的子串和字符串 $b$ 的前 $j$ 个字符最长公共子序列的长度，额，为什么是最长公共子序列呢？我们可以发现，对于这两个字符串，他们的最长公共子序列实际上就是可以回文的部分，通过计算这一部分，我们就可以反向计算出我们需要添加多少个字符 从而使这个字符串整个变得回文。</p><h2 id="3-确定状态转移方程"><a href="#3-确定状态转移方程" class="headerlink" title="3. 确定状态转移方程"></a>3. 确定状态转移方程</h2><p>直接复制粘贴 LCS 的就 OK 了，简单贴一下吧：</p><blockquote><p>  决策很简单呢，如果相同，那么就 $+1$ 如果不同，那么就选择复制 $f_{i-1,\ j}$ 和 $f_{i,\ j-1}$ 中大的那一个，很简单，写出方程如下：<br>  $$<br>  f_{i,\ j} &#x3D; \left{<br>  \begin{array}{lr}<br>  a_i &#x3D; b_j\ \ \ \ f_{i - 1,\ j-1} + 1\<br>  a_i ≠ b_j\ \ \ \ \max(f_{i-1,\ j},\ f_{i,\ j-1})<br>  \end{array}<br>  \right.<br>  $$</p></blockquote><h2 id="4-边界"><a href="#4-边界" class="headerlink" title="4. 边界"></a>4. 边界</h2><p>对于这道题，边界也是非常简单，和 LCS 一模一样，根本不用赋值，这是在上一篇中的解释：</p><blockquote><p>  初始值想都不用想，全都是 蛋（$0$），那么也就很简单了，什么都不用干，只需要创建数组，完事儿</p></blockquote><p>额，好像和没有解释一样，还是讲一下吧。你想一下，我们的 LCS 在什么字符都没有，也就是 $f_{i,\ 0}$ 和 $f_{0,\ i}$ 的时候，他必定没有任何字符可以与他形成最长公共子序列，所以这两列（行）就一定是 $0$ 而有因为全局数组的初始值就是 $0$ 所以什么都不需要干。</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>实现依旧是很简单，实际上只需要把 LCS 的代码稍加修改即可，也就是把 $b$ 串设定为 $a$ 串的反串，输出的时候输出 $a.length()-f_{a.length(),\ a.length()}$ 即可，而又因为题目中已经给到了我们字符串的长度，所以只需要输出 $n-f_{n,\ n}$ 即可。除了不是很优雅，这道题简直是非常妙。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string a, b;<br><span class="hljs-type">int</span> n, f[<span class="hljs-number">5009</span>][<span class="hljs-number">5009</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; a;<br>    b = a;<br>    <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[i - <span class="hljs-number">1</span>] == b[j - <span class="hljs-number">1</span>]) &#123;<br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; n - f[n][n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1241 题解</title>
    <link href="/posts/bb1b6679.html"/>
    <url>/posts/bb1b6679.html</url>
    
    <content type="html"><![CDATA[<h1 id="这次是-LIS-的兄弟-LCS（最长公共子序列）"><a href="#这次是-LIS-的兄弟-LCS（最长公共子序列）" class="headerlink" title="这次是 LIS 的兄弟 LCS（最长公共子序列）"></a>这次是 <strong>LIS</strong> 的兄弟 <strong>LCS</strong>（最长公共子序列）</h1><p>一个词概括，模板题。但是，模板题也很难啊啊啊啊啊啊。又是经典的五步：</p><h2 id="1-划分状态"><a href="#1-划分状态" class="headerlink" title="1. 划分状态"></a>1. 划分状态</h2><p>假设 $a$ 和 $b$ 是本次主角字符串（好想把他们拉出去斩了） ，那么一共有 $a.length() \times b.length()$ 种状态，每一种状态表示下标 $i$ 之前的 $a$ 的子串（即 <code>a.substr(0, i)</code>）与下标 $j$ 前的 $b$ 的子串（即 <code>b.substr(0, j)</code>）的最长公共子序列的长度。</p><h2 id="2-确定状态和状态变量"><a href="#2-确定状态和状态变量" class="headerlink" title="2. 确定状态和状态变量"></a>2. 确定状态和状态变量</h2><p>状态就是 （1） 里面说的，那么状态变量我用一个二维数组 $f$ ，也就是说 $f_{i,\ j}$ 就是一个表示下标 $i$ 之前的 $a$ 的子串（即 <code>a.substr(0, i)</code>）与下标 $j$ 前的 $b$ 的子串（即 <code>b.substr(0, j)</code>）的最长公共子序列的长度的状态</p><h2 id="3-写出状态转移方程并确定决策"><a href="#3-写出状态转移方程并确定决策" class="headerlink" title="3. 写出状态转移方程并确定决策"></a>3. 写出状态转移方程并确定决策</h2><p>决策很简单呢，如果相同，那么就 $+1$ 如果不同，那么就选择复制 $f_{i-1,\ j}$ 和 $f_{i,\ j-1}$ 中大的那一个，很简单，写出方程如下：<br>$$<br>f_{i,\ j} &#x3D; \left{<br>\begin{array}{lr}<br>a_i &#x3D; b_j\ \ \ \ f_{i - 1,\ j-1} + 1\<br>a_i ≠ b_j\ \ \ \ \max(f_{i-1,\ j},\ f_{i,\ j-1})<br>\end{array}<br>\right.<br>$$</p><h2 id="4-初始值"><a href="#4-初始值" class="headerlink" title="4. 初始值"></a>4. 初始值</h2><p>初始值想都不用想，全都是 蛋（$0$），那么也就很简单了，什么都不用干，只需要创建数组，完事儿</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>实现直接模拟就可以 AC，注意一点，如果想我一样图方便把循环的原始值设置成 $0$ 的话，会有一个问题，你在继承值的时候涉及到 $-1$ 的操作，这就会导致数组越界，轻则算不准，重则 RE $0\ pts$ ，避完坑之后就可以放心打代码了，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> f[<span class="hljs-number">2009</span>][<span class="hljs-number">2009</span>];<br>string a, b;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a.<span class="hljs-built_in">length</span>(); i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= b.<span class="hljs-built_in">length</span>(); j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[i - <span class="hljs-number">1</span>] == b[j - <span class="hljs-number">1</span>]) &#123;<br>                f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[a.<span class="hljs-built_in">length</span>()][b.<span class="hljs-built_in">length</span>()];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1240 题解</title>
    <link href="/posts/d967b576.html"/>
    <url>/posts/d967b576.html</url>
    
    <content type="html"><![CDATA[<h1 id="这道题是真的难啊"><a href="#这道题是真的难啊" class="headerlink" title="这道题是真的难啊"></a>这道题是真的难啊</h1><p>这道题目中 $\Huge 相邻$ 这个该 * 的词很容易 让人误以为这道题有后效性，当时我们全班都认为这道题有后效性，然而我们<strong>美丽</strong>的又<strong>和蔼</strong>的 Lily 却和我们说没有。仔细分析后发现，直接观察确实这道题目有后效性，但是如果深入分析，就会发现，只有前面的一项会影响它本身，在计算后一项的时候，对他本身并不会产生影响，他始终是最优解，行，确定能用 DP 了，开工！！！！</p><h2 id="1-划分阶段"><a href="#1-划分阶段" class="headerlink" title="1. 划分阶段"></a>1. 划分阶段</h2><p>划分阶段还算简单，一共有 $n \times m$ 个阶段，也就是说每个房间一个。</p><h2 id="2-确定状态和状态变量"><a href="#2-确定状态和状态变量" class="headerlink" title="2. 确定状态和状态变量"></a>2. 确定状态和状态变量</h2><p>状态全部存储在二维数组 $f$ 里面，$f_{i,\ j}$ 就表示在第 $i$ 层第 $j$ 间房的最优解，即盖章的最小费用</p><h2 id="3-写状态转移方程"><a href="#3-写状态转移方程" class="headerlink" title="3. 写状态转移方程"></a>3. 写状态转移方程</h2><p>对于一个状态 $f_{i,\ j}$ 他可以继承自他的 <strong>下</strong>、 <strong>左</strong> 、<strong>右</strong> 三个方向，为什么不能从上面？——你去问小胖啊，反正就是不行（doge）。</p><p>针对这三种方式，我们有以下的方程：<br>$$<br>\left{<br>\begin{array}{lr}<br>f_{i,\ j} &#x3D; f_{i-1,\ j} + a_{i,\ j}\ \ (上)\<br>f_{i,\ j} &#x3D; f_{i,\ j - 1} + a_{i,\ j}\ \ (左)\<br>f_{i,\ j} &#x3D; f_{i,\ j + 1} + a_{i,\ j}\ \ (右)<br>\end{array}<br>\right.<br>$$</p><p>那么我们只需要取这几种之中的最小值就可以了。所以我们可以用 $\min$ 函数吗？——不行，我们还要输出路径啊啊啊啊啊啊啊，我真的会谢。输出路径的话我们就还需要一个数组 $pre$ 用来存储路径，正常我们在存储的时候都是存储上一项的下标，但是我们在这里没有办法存下标，所以我们有一种很巧妙的方法，刚刚我们不是有方向吗？那么我们直接把方向存进去，输出的时候根据方向算方位就行了，我真是个<strong>大聪明</strong>。那么就可以愉快的进入下一步了</p><h2 id="4-初始状态"><a href="#4-初始状态" class="headerlink" title="4. 初始状态"></a>4. 初始状态</h2><p>初始状态很简单，因为走到一楼的任何一个房间都不需要路过任何一个房间，所以初始状态就是这样的的：<br>$$<br>f_{1,\ j} &#x3D; a_{1,\ j}<br>$$</p><p>然后你可别忘记我们还有一个叫做 $pre$ 的默默无闻的（<del>垃圾</del>） 数组，他也是要初始值的啊。因为任何一个房间都有可能是最后一个房间，所以我们要把他们全部都标记成 $-1$  方便输出的时候判断是否到达最后一个房间</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>到了开心有愉快的实现环节咯！！！Nice！！</p><p>实现<strong>非常非常非常非常非常非常非常非常</strong>简单，按照分析模拟就可以了（就是有一点点长~~），如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m, p, minn = <span class="hljs-number">2147483647</span>, a[<span class="hljs-number">509</span>][<span class="hljs-number">509</span>], f[<span class="hljs-number">509</span>][<span class="hljs-number">509</span>], pre[<span class="hljs-number">509</span>][<span class="hljs-number">509</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pre[x][y] == <span class="hljs-number">-1</span>) &#123;<br>        cout &lt;&lt; y &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pre[x][y] == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">print</span>(x - <span class="hljs-number">1</span>, y);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre[x][y] == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">print</span>(x, y - <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre[x][y] == <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-built_in">print</span>(x, y + <span class="hljs-number">1</span>);<br>    &#125;<br>    cout &lt;&lt; y &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">127</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            cin &gt;&gt; a[i][j];<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>                pre[<span class="hljs-number">1</span>][j] = <span class="hljs-number">-1</span>;<br>                f[<span class="hljs-number">1</span>][j] = a[<span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            f[i][j] = f[i - <span class="hljs-number">1</span>][j] + a[i][j];<br>            pre[i][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (f[i][j - <span class="hljs-number">1</span>] + a[i][j] &lt; f[i][j]) &#123;<br>                f[i][j] = f[i][j - <span class="hljs-number">1</span>] + a[i][j];<br>                pre[i][j] = <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">1</span>; j--) &#123;<br>            <span class="hljs-keyword">if</span> (f[i][j + <span class="hljs-number">1</span>] + a[i][j] &lt; f[i][j]) &#123;<br>                f[i][j] = f[i][j + <span class="hljs-number">1</span>] + a[i][j];<br>                pre[i][j] = <span class="hljs-number">3</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (minn &gt; f[m][i]) &#123;<br>            minn = f[m][i];<br>            p = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(m, p);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1242 题解</title>
    <link href="/posts/3594619a.html"/>
    <url>/posts/3594619a.html</url>
    
    <content type="html"><![CDATA[<h1 id="这道题真的离谱"><a href="#这道题真的离谱" class="headerlink" title="这道题真的离谱"></a>这道题真的离谱</h1><h2 id="1-划分阶段"><a href="#1-划分阶段" class="headerlink" title="1. 划分阶段"></a>1. 划分阶段</h2><p>对于这道题目，我以每一个字母为一个阶段，表示第一个字符串的前 $i$  个字母和第二个字符串的前 $j$ 个字母之间的编辑距离（定义见题目）</p><h2 id="2-状态和状态变量"><a href="#2-状态和状态变量" class="headerlink" title="2. 状态和状态变量"></a>2. 状态和状态变量</h2><p>定义数组 $f$ 用于存储状态，即 $f_{i,\ j}$ 表示一个阶段（也就是(1) 里面提到的阶段），同时 $a,b$ 分别是输入的两个字符串</p><h2 id="3-确定状态转移方程"><a href="#3-确定状态转移方程" class="headerlink" title="3. 确定状态转移方程"></a>3. 确定状态转移方程</h2><p>这就是最难的部分，先从 $f_{i,\ j}$ 的三种可能性看起，他们可能有以下三种状态：<br>$$<br>\left{<br>\begin{array}{lr}<br>a_i&#x3D;”\ “\<br>b_j&#x3D;”\ “\<br>a_i≠”\ “\ &amp;&amp;\ b_j≠”\ “<br>\end{array}<br>\right.<br>$$</p><p>那么先从第一种，也就是当 $a_i$ 是空格，而 $b_j$ 不是的时候，在这个时候，状态转移方程应该如下：<br>$$<br>f_{i,\ j} &#x3D; f_{i - 1,\ j} + k\ \ （k\ 与题目中的定义相同）<br>$$</p><p>然后是第二种，也就是 $b_j$ 是空格，但是 $a_i$ 不是空格的时候，方程如下：<br>$$<br>f_{i,\ j} &#x3D; f_{i,\ j-1} + k\ \ \ （k\ 的定义与题目中相同）<br>$$<br>然后是最后一种，实际上也是最简单的一种：<br>$$<br>f_{i,\ j} &#x3D; f_{i - 1,\ j- 1} + |a_i-b_j|<br>$$<br>行，这就是所有的状态转移方程，总结一下，如下：<br>$$<br>f_{i,\ j} &#x3D;<br>\left{<br>\begin{array}{lr}<br>a_i &#x3D;”\ “\ \ \ f_{i - 1,\ j} + k\<br>b_j&#x3D;”\ “ \ \ \ f_{i,\ j - 1} + k\<br>a_i≠”\ “\ &amp;&amp;\ b_j≠”\ “\ \ \ \ f_{i-1,\ j-1} + |a_i - b_j|<br>\end{array}<br>\right.<br>$$</p><h2 id="4-边界条件"><a href="#4-边界条件" class="headerlink" title="4. 边界条件"></a>4. 边界条件</h2><p>观察样例可以发现，边界条件就是这样的：<br>$$<br>\begin{array}{lr}<br>f_{i,\ 0} &#x3D; f_{i-1,\ 0} + k\<br>f_{0,\ j} &#x3D; f_{0,\ j-1} + k\<br>\end{array}<br>$$</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>终于到了最最最最最最简单的一步：实现（手动洒花</p><p>实现真的很简单，只需要以下几步：</p><ul><li>输入</li><li>给边界条件赋值</li><li>计算，也就是取 $f_{i,\ j}$ 三种可能性之中值最小的一种给 $f_{i,\ j}$ 赋值</li><li>输出，把 $f_{a.length(),\ b.length()}$ 输出</li><li>等 AC</li></ul><p>下面是实际代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> k, f[<span class="hljs-number">2009</span>][<span class="hljs-number">2009</span>];<br>string a, b;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a.<span class="hljs-built_in">length</span>(); i++) &#123;<br>        f[i][<span class="hljs-number">0</span>] = k + f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= b.<span class="hljs-built_in">length</span>(); i++) &#123;<br>        f[<span class="hljs-number">0</span>][i] = k + f[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a.<span class="hljs-built_in">length</span>(); i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= b.<span class="hljs-built_in">length</span>(); j++) &#123;<br>            f[i][j] = <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-built_in">abs</span>((<span class="hljs-type">int</span>) a[i - <span class="hljs-number">1</span>] - (<span class="hljs-type">int</span>) b[j - <span class="hljs-number">1</span>]), <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j] + k, f[i][j - <span class="hljs-number">1</span>] + k));<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[a.<span class="hljs-built_in">length</span>()][b.<span class="hljs-built_in">length</span>()];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1263 题解</title>
    <link href="/posts/d7c84982.html"/>
    <url>/posts/d7c84982.html</url>
    
    <content type="html"><![CDATA[<h1 id="这真是一场-愉快-的传球游戏"><a href="#这真是一场-愉快-的传球游戏" class="headerlink" title="这真是一场**愉快**的传球游戏"></a>这真是一场**<del>愉快</del>**的传球游戏</h1><p>再次是传统的五步</p><h2 id="1-划分阶段"><a href="#1-划分阶段" class="headerlink" title="1. 划分阶段"></a>1. 划分阶段</h2><p>这里我划分的状态是：每次传球完一种状态</p><h2 id="2-确定状态和状态变量"><a href="#2-确定状态和状态变量" class="headerlink" title="2. 确定状态和状态变量"></a>2. 确定状态和状态变量</h2><p>对于状态变量，我定义一个二维数组 $f$ ，对于 $f_{i,\ j}$ 他表示的是在 $i$ 次传球后，$j$ 手上的球的数量。</p><h2 id="3-确定决策和状态转移公式"><a href="#3-确定决策和状态转移公式" class="headerlink" title="3. 确定决策和状态转移公式"></a>3. 确定决策和状态转移公式</h2><p>对于这道题，决策的方式稍稍有那么一点点复杂，对于一种状态 （$f_{i,\ j}$）它有以下几种可能</p><ul><li>当 $j&#x3D;1$ 也就是说是第一个人的时候，方程为：$f_{i,\ j} &#x3D; f_{i-1,\ n}+f_{i-1,\ 2}$</li><li>当 $j &#x3D; n$ 也就是说是最后一个人的时候，方程为：$f_{i,\ j}&#x3D;f_{i-1, j-1}+f_{i-1, 1}$</li><li>在其余的情况，方程为：$f_{i,\ j}&#x3D;f_{i-1,\ j-1}+f_{i-1,\ j+1}$</li></ul><h2 id="4-确定边界"><a href="#4-确定边界" class="headerlink" title="4. 确定边界"></a>4. 确定边界</h2><p>通过上面的分析和对题目<del>不完全</del>的理解，我们<del>不难</del>（很难）看出，边界条件就是:<br>$$<br>f_{0,\ 1} &#x3D; 1<br>$$</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>终于到了最简单的一步：实现，[欢呼]</p><p>OK，进入正题，实际上这道题的实现很简单，只需要这样几步就可以 <strong>AC</strong>：</p><ul><li>输入（不输入算个啥？）</li><li>给边界条件赋值（不赋值就等s吧）</li><li>用状态转移公式计算每一个状态</li><li>输出</li></ul><p>我相信你明白了？对吧？（反正我就这么看是没看明白）还有一个问题就是输出的时候究竟输出什么东西，我们可以把我们定义的二维数组 $f$ 的内容写个表写来，发现 $f_{m,\ 1}$ 就是我们想要的数，直接输出就 OK 了。</p><p>下面是我的代码，我为了方便，把数组 $f$ 改成了我平时更常用的数组名 $a$ ，见谅：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">31</span>][<span class="hljs-number">31</span>], m, n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span>) &#123;<br>                a[i][j] = a[i - <span class="hljs-number">1</span>][n] + a[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == n) &#123;<br>                a[i][j] = a[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + a[i - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                a[i][j] = a[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; a[m][<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1993 题解</title>
    <link href="/posts/f0917da4.html"/>
    <url>/posts/f0917da4.html</url>
    
    <content type="html"><![CDATA[<h1 id="又是一道-DP"><a href="#又是一道-DP" class="headerlink" title="又是一道 DP"></a>又是一道 DP</h1><p>看到题目，我的第一反应就是：这鼹鼠是什么玩意儿？</p><p>额，$\Huge 搞错了$ 再来</p><p>下面是传统的五步</p><h2 id="1-划分阶段"><a href="#1-划分阶段" class="headerlink" title="1. 划分阶段"></a>1. 划分阶段</h2><p>以每一只耐造的鼹鼠为一个阶段，表示在这只鼹鼠前面（包括这只鼹鼠）可以打到的鼹鼠的数量</p><h2 id="2-确定状态和状态变量"><a href="#2-确定状态和状态变量" class="headerlink" title="2. 确定状态和状态变量"></a>2. 确定状态和状态变量</h2><p>这里使用两个数组 $f,\ a$ ，分别存储状态和输入的数据</p><h2 id="3-确定决策和状态转移公式"><a href="#3-确定决策和状态转移公式" class="headerlink" title="3. 确定决策和状态转移公式"></a>3. 确定决策和状态转移公式</h2><p>因为每一只鼹鼠都可以和他前面的任何一只鼹鼠结合，所以我们只需要知道究竟是与前面的结合好还是自己好即可，这一点很与最长不下降子序列（<strong>LIS</strong>） 完全相同，所以公式可以完全照搬：<br>$$<br>\begin{array}{lr}<br>(0\ &lt;\ j\ ≤\ n)\<br>f_i &#x3D; \max(f_i,\ f_j + 1)<br>\end{array}<br>$$</p><h2 id="4-边界条件"><a href="#4-边界条件" class="headerlink" title="4. 边界条件"></a>4. 边界条件</h2><p>因为每一只鼹鼠都有可能是第一只鼹鼠而且第一只鼹鼠的初始值，也就是我们的边界条件一定是 $1$ 。所以我们的边界条件就是每一项都是一：<br>$$<br>f_{1\to n}&#x3D;1<br>$$</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>前面的思路都整理清楚了，实现就非常简单了，基本就是最长不下降子序列改一下，注意：题目要我们求的不是抓的鼹鼠，而是幸存的鼹鼠，所以输出的时候要输出 $n-ans\ (ans为计算出来的被抓的鼹鼠数量)$ ，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m, ans, t[<span class="hljs-number">10009</span>], x[<span class="hljs-number">10009</span>], y[<span class="hljs-number">10009</span>], f[<span class="hljs-number">10009</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        cin &gt;&gt; t[i] &gt;&gt; x[i] &gt;&gt; y[i];<br>        f[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(x[i] - x[j]) + <span class="hljs-built_in">abs</span>(y[i] - y[j]) &lt;= <span class="hljs-built_in">abs</span>(t[i] - t[j])) &#123;<br>                f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, f[i]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1227 题解</title>
    <link href="/posts/e6e1674.html"/>
    <url>/posts/e6e1674.html</url>
    
    <content type="html"><![CDATA[<h1 id="这道题需要两次动规-LIS-DP"><a href="#这道题需要两次动规-LIS-DP" class="headerlink" title="这道题需要两次动规 (LIS DP)"></a>这道题需要两次动规 (<strong>LIS DP</strong>)</h1><p>OK，再再再再是经典的五步</p><h2 id="1-划分状态"><a href="#1-划分状态" class="headerlink" title="1. 划分状态"></a>1. 划分状态</h2><p>在这道题，我用每个人划分状态，每个人有两个状态，分别是以这个人结尾的最长不下降子序列长度和以这个人开头的最长不下降自序列的长度</p><h2 id="2-确定状态和状态变量"><a href="#2-确定状态和状态变量" class="headerlink" title="2. 确定状态和状态变量"></a>2. 确定状态和状态变量</h2><p>我使用三个数组 $a,\ b,\ c$ 分别：存储输入的数据、存储状态一（以这个人结尾的最长不下降子序列长度）、存储状态二（以这个人开头的最长不下降自序列的长度）。状态如上</p><h2 id="3-确定决策并写出状态转移方程"><a href="#3-确定决策并写出状态转移方程" class="headerlink" title="3. 确定决策并写出状态转移方程"></a>3. 确定决策并写出状态转移方程</h2><p>决策很简单，就按最长不下降自序列（<strong>LIS</strong>）长度计算的方法来回算两边就可以算出两种状态了（状态的定义见上文），两种状态分别放在数组 $b,\ c$ 之中。状态转移方程：<br>$$<br>\begin{array}{lr}<br>0&lt;j≤n\<br>b_i&#x3D;\max(b_i,b_j+1)<br>\<br>c_i&#x3D;\max(c_i,c_j+1)\<br>\end{array}<br>$$</p><h2 id="4-边界条件"><a href="#4-边界条件" class="headerlink" title="4. 边界条件"></a>4. 边界条件</h2><p>$$<br>b_i&#x3D;c_i&#x3D;1<br>$$</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>代码实际上很简单，一次正序的 LIS 和一次倒叙的 LIS 就可以求出所有状态，再来比较哪一个人左右两边正确排序的人最多（$ans&#x3D;\max(ans,\ b_i+c_i-1)$），输出即可，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, ans, a[<span class="hljs-number">109</span>], b[<span class="hljs-number">109</span>], c[<span class="hljs-number">109</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        b[i] = c[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= i - <span class="hljs-number">1</span>; j--) &#123;<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j]) &#123;<br>                b[i] = <span class="hljs-built_in">max</span>(b[i], b[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[j]) &#123;<br>                c[i] = <span class="hljs-built_in">max</span>(c[i], c[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        ans = <span class="hljs-built_in">max</span>(b[i] + c[i] - <span class="hljs-number">1</span>, ans);<br>    &#125;<br>    cout &lt;&lt; n - ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1229 题解</title>
    <link href="/posts/1be40446.html"/>
    <url>/posts/1be40446.html</url>
    
    <content type="html"><![CDATA[<h1 id="这道题思路稍稍有那么一点绕"><a href="#这道题思路稍稍有那么一点绕" class="headerlink" title="这道题思路稍稍有那么一点绕"></a>这道题思路稍稍有那么一点绕</h1><p>先理解一下题目，交叉着一点还是挺难理解的，我们把样例的图片画出来的话大概是这样的：</p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E6%88%AA%E5%B1%8F2023-01-05%2014.38.33.png" srcset="/img/loading.gif" lazyload alt="截屏2023-01-05 14.38.33"></p><p>我们仔细观察一下，会发现，不交叉的的几项在下面（南岸）形成了一个上升序列（也可以说是不下降序列），那么求有多少项不交叉是不是可以改成当北岸按升序排好时南岸的数的最长不下降子序列的长度？这就很好理解了。先把北岸排序，让南岸跟着动，然后求南岸的最长不下降子序列的长度就可以得到答案了，下面就直接放代码了，最长不下降子序列（<strong>LIS</strong>）可以看<a href="https://codingcow.netlify.app/post/oiclass%20p1226%20%E9%A2%98%E8%A7%A3">这篇文章</a>（也是我写的）</p><p>OK，直接看代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">country</span> &#123;<br>    <span class="hljs-type">int</span> n, s;<br>&#125; a[<span class="hljs-number">5009</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(country a, country b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.n &lt; b.n;<br>&#125;<br><br><span class="hljs-type">int</span> n, x, y, ans, f[<span class="hljs-number">5009</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; x &gt;&gt; y &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i].n &gt;&gt; a[i].s;<br>        f[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>, cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[j].s &lt; a[i].s) &#123;<br>                f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>                ans = <span class="hljs-built_in">max</span>(ans, f[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1226 题解</title>
    <link href="/posts/c2c416ea.html"/>
    <url>/posts/c2c416ea.html</url>
    
    <content type="html"><![CDATA[<h1 id="话不多说，这又是一道-DP-题"><a href="#话不多说，这又是一道-DP-题" class="headerlink" title="话不多说，这又是一道 DP 题"></a>话不多说，这又是一道 <strong>DP</strong> 题</h1><p>看题目就知道，这就是大名鼎鼎的最长不下降子序列 <strong>LIS</strong> 。所以我们用十分传统的五步（第六步是送的）解决这个问题</p><h2 id="1-划分阶段"><a href="#1-划分阶段" class="headerlink" title="1. 划分阶段"></a>1. 划分阶段</h2><p>我们的以每一个数划分阶段，也就是说每一个阶段存储的是以某个数结尾的子序列</p><h2 id="2-确定状态和状态变量"><a href="#2-确定状态和状态变量" class="headerlink" title="2. 确定状态和状态变量"></a>2. 确定状态和状态变量</h2><p>这里使用数组 $f$ 来存放状态，数组 $a$ 存储输入的数据，即状态 $f_i$ 为以数字 $a_i$ 结尾的最长不下降子序列的长度。</p><h2 id="3-确定决策并写出状态转移方程"><a href="#3-确定决策并写出状态转移方程" class="headerlink" title="3. 确定决策并写出状态转移方程"></a>3. 确定决策并写出状态转移方程</h2><p>对于数字 $a_i$ 他可以与位于他前面的任何一个数连在一起形成一个子序列，当然了，如果 $a_i$ 嫌弃前面的子序列态太短，他也可以自己形成一个新的子序列，使得他自己所在的子序列是最短的，基于这些分析，我们可以写出以下状态转移方程：<br>$$<br>f_i &#x3D; \max\left(\max_{j\ &#x3D; \ 1,\ j++}^{0\ &lt;\ j\ &lt;\ i} ,\ f_i\right)<br>$$</p><h2 id="4-寻找边界条件"><a href="#4-寻找边界条件" class="headerlink" title="4. 寻找边界条件"></a>4. 寻找边界条件</h2><p>因为每一个数字都可以成为一个单独的子序列，所以边界条件就是所有的数字代表的状态都是 $1$ 也就是说：<br>$$<br>f_i &#x3D; 1\ \ (0\ &lt;\ i\ ≤\ n)\ n为数组长度<br>$$</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>实现非常简单，只需要在输入的时候把边界条件赋值，然后用状态转移公式计算出每一个状态在取所有状态的最大值输出就可以了，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, a[<span class="hljs-number">1009</span>], f[<span class="hljs-number">1009</span>], ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        f[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[j] &lt;= a[i]) &#123;<br>                f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>                ans = <span class="hljs-built_in">max</span>(f[i], ans);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-送的"><a href="#6-送的" class="headerlink" title="6. 送的"></a>6. 送的</h2><p>如果你都看到这里了，说明你对 <strong>LIS</strong> 很感兴趣，那么相信你也对我写的题解很感兴趣吧（疯狂暗示点赞）。</p><p>有些**<del>友好</del>**的题目可能会要求你输出这个最长不下降子序列，那么这个时候要怎么办呢？如果你写过需要输出路径的深搜（DFS）或者广搜(BFS) 那么你可能会有一些思路，毕竟原理差不多。在这里，我们需要定义一个数组，用来存储第 $i$ 个数字的上一个数字（可以理解为指针），这里我使用数组 $pre$ 对于 $pre$ 的初始值，我将其设置为 $-1$ （后面会讲到为什么）在我进行状态的转移的时候，例如状态 $f_i$ 假设 $f_i $ 的要转移的一项是 $f_j$ 那么 $pre_i&#x3D;j$ 。OK，那么怎么输出呢？我们可以写一个递归函数，获得上一项的位置后对自己进行递归调用，等到发现自己的值是 $-1$ 时（$pre_{self}&#x3D;-1$）<code>return</code> 那么就可以解决输出的问题，这也是为什么要把数组里每一项的初始值都设为 $-1$ 这样就可以有效输出了。好，接下来看一看代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, p, a[<span class="hljs-number">1009</span>], f[<span class="hljs-number">1009</span>], pre[<span class="hljs-number">1009</span>], ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pre[x] == <span class="hljs-number">-1</span>) &#123;<br>        cout &lt;&lt; a[x] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(pre[x]);<br>    cout &lt;&lt; a[x] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        f[i] = <span class="hljs-number">1</span>;<br>        pre[i] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[j] &lt;= a[i]) &#123;<br>                <span class="hljs-keyword">if</span> (f[i] &lt; f[j] + <span class="hljs-number">1</span>) &#123;<br>                    pre[i] = j;<br>                    f[i] = f[j] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ans &lt; f[i]) &#123;<br>            p = i;<br>            ans = f[i];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-built_in">print</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是很妙？  </p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1479 题解</title>
    <link href="/posts/5c6d314e.html"/>
    <url>/posts/5c6d314e.html</url>
    
    <content type="html"><![CDATA[<h1 id="这道题又又又又又是动规（我最近在学）"><a href="#这道题又又又又又是动规（我最近在学）" class="headerlink" title="这道题又又又又又是动规（我最近在学）"></a>这道题又又又又又是动规（我最近在学）</h1><p>传统的五步：</p><h2 id="1-划分阶段"><a href="#1-划分阶段" class="headerlink" title="1. 划分阶段"></a>1. 划分阶段</h2><p>这里划分的阶段是在某个格子上时的最优解</p><h2 id="2-确定状态和状态变量"><a href="#2-确定状态和状态变量" class="headerlink" title="2. 确定状态和状态变量"></a>2. 确定状态和状态变量</h2><p>这里的状态数组 $f$ 来进行存储，用数组 $a$ 储存输入的数组。状态从他前面的格子获得，这些格子可能是：<br>$$<br>a_{S},\ a_{S+1},\ a_{S+2}…a_{T-2},\ a_{T-1},\ a_{T}<br>$$</p><h2 id="3-确定决策并写出状态转移方程"><a href="#3-确定决策并写出状态转移方程" class="headerlink" title="3. 确定决策并写出状态转移方程"></a>3. 确定决策并写出状态转移方程</h2><p>又到了烧脑的一步，不过对于这道题，我个人觉得还好。$\huge 进入正题$ </p><p>我们从题目可以得知，我们希望 $f_n$ 的值尽量大，越大越好，所以我们要尽量从大的格子转移状态，可以得到，我们可以转移状态的格子分别是 $f_{S}\to f_T$ 的所有格子，也就是说我们要找出在 $f_S \to f_T$ 之间最大的一个格子（包含 $f_S$ 和 $f_T$）然后我们再拿上当前位置的格子，同时我们还需要考虑是直接拿上格子原来的金块多，还是拿上前面的金块多。OK，思路清晰了，开始写方程：<br>$$<br>\begin{array}{lr}<br>对于第\ i\ 个状态:f_i\<br>f_i &#x3D; \max\left<br>(\left(\max_{j&#x3D;S,\ j++}^{0\ &lt;\ j\ &lt;\ T} f_j\right)+a_i,\ f_i\right)<br>\end{array}<br>$$</p><h2 id="4-确定初始值"><a href="#4-确定初始值" class="headerlink" title="4. 确定初始值"></a>4. 确定初始值</h2><p>初始值在这道题很简单，就是第一项，毕竟在第一项的时候除了这一项，你无法获得其他项的金块，故初始值如下：<br>$$<br>f_1&#x3D;a_1<br>$$</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>有了前面的分析，实现的思路也就很清晰了。</p><ul><li>首先输入数据</li><li>枚举数组的每一个数，并使用状态转移方程计算他的值</li><li>输出 $f_n$</li></ul><p>然后依分析模拟就可以得到代码。</p><p>注意以下几点：</p><ul><li>在计算 $f_{S} \to f_T$ 的所有格子的最大值时，要注意是否存在负数下标，如果存在，不应该将此计入计算范围，否则样例都过不了</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, s, t, a[<span class="hljs-number">1009</span>], f[<span class="hljs-number">1009</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; s &gt;&gt; t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    f[<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = s; j &lt;= t; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i - j &gt; <span class="hljs-number">0</span>) &#123;<br>                f[i] = <span class="hljs-built_in">max</span>(f[i], f[i - j] + a[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1221 题解</title>
    <link href="/posts/c8011ff3.html"/>
    <url>/posts/c8011ff3.html</url>
    
    <content type="html"><![CDATA[<h1 id="这道题不用多说也知道是-DP-（看标签）"><a href="#这道题不用多说也知道是-DP-（看标签）" class="headerlink" title="这道题不用多说也知道是 DP （看标签）"></a>这道题不用多说也知道是 DP <del>（看标签）</del></h1><p>那么，究竟要怎样 DP 呢？下面依然是那熟悉的五步</p><h2 id="1-划分阶段"><a href="#1-划分阶段" class="headerlink" title="1. 划分阶段"></a>1. 划分阶段</h2><p>这里我采用的方法是划分爬到每一个位置，也就是以空间划分阶段</p><h2 id="2-确定状态和状态变量"><a href="#2-确定状态和状态变量" class="headerlink" title="2. 确定状态和状态变量"></a>2. 确定状态和状态变量</h2><p>OK，进入下一步 。在这里我定义的状态是在第 $i\ (0&lt;i≤n)$ 个位置时以跳到达和以爬到达的最优解，分别记为 $jump_i$ 和 $climb_i$ </p><h2 id="3-确定决策井写出状态转移方程"><a href="#3-确定决策井写出状态转移方程" class="headerlink" title="3. 确定决策井写出状态转移方程"></a>3. 确定决策井写出状态转移方程</h2><p>决策方式很简单，分以下两点</p><ul><li>对于爬的方法，判断究竟以跳的方式到达上一层更快还是以爬的方式到达上一层更快，选择快的一种方式，并加上从上一层爬到此层所需的时间</li><li>对于跳的方法，我们只需要判断究竟从上一层跳过来更快还是从上上层跳过来更快，由于我们必须爬一层再跳，所以我们根本不需要考虑到达上一层或者上上层的方式，直接认为只有爬这一种方式即可，很简单对吧？</li></ul><p>OK，分析完了，那么就把方程写出来吧，如下：<br>$$<br>\begin{array}{lr}<br>jump_i &#x3D; \min(climb_{i-1},\ climb_{i-2})\<br>climb_i&#x3D;\min(climb_{i-1},\ jump_{i-1}) +a_i\ \ &#x2F;&#x2F;a为输入的数列<br>\end{array}<br>$$</p><h2 id="4-寻找边界条件"><a href="#4-寻找边界条件" class="headerlink" title="4. 寻找边界条件"></a>4. 寻找边界条件</h2><p>很容易发现，边界条件就是：<br>$$<br>\begin{array}{lr}<br>jump_1&#x3D;0\<br>climb_1&#x3D;a_1<br>\end{array}<br>$$</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>终于到了最激动人心的一步了（对于其他不是 DP 的题目），才怪，对于这道题，只需要按照分析模拟，最后判断究竟是爬的方法更快还是跳的方法更快，输出即可。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, a[<span class="hljs-number">10009</span>], jump[<span class="hljs-number">10009</span>], climb[<span class="hljs-number">10009</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    climb[<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        climb[i] = <span class="hljs-built_in">min</span>(climb[i - <span class="hljs-number">1</span>], jump[i - <span class="hljs-number">1</span>]) + a[i];<br>        jump[i] = <span class="hljs-built_in">min</span>(climb[i - <span class="hljs-number">1</span>], climb[i - <span class="hljs-number">2</span>]);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">min</span>(climb[n], jump[n]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P3314 题解</title>
    <link href="/posts/20495.html"/>
    <url>/posts/20495.html</url>
    
    <content type="html"><![CDATA[<h1 id="这道题从题面就可以看出是经典的最长不下降子序列"><a href="#这道题从题面就可以看出是经典的最长不下降子序列" class="headerlink" title="这道题从题面就可以看出是经典的最长不下降子序列"></a>这道题从题面就可以看出是经典的<strong>最长不下降子序列</strong></h1><p>对于这道<strong>一点都不简单</strong>的最长连续子序列和的模板题，我们还是直接暴力，代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> ans, n, a[<span class="hljs-number">1009</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        a[i] += a[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, a[j] - a[i - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>额，$\Huge 搞错了，进入正题$</p><p>这道题的正解是采用 <strong>DP</strong> 的方法，时间复杂度为 $\Large O(n)$ 相比暴力的 $\Large O<br>(n^2)$ 可以说是质的飞跃。OK，接下来就是经典的不能再经典的五步</p><h2 id="1-划分阶段"><a href="#1-划分阶段" class="headerlink" title="1. 划分阶段"></a>1. 划分阶段</h2><p>我们将阶段划分为以各个数字为序列的末尾时的最优解</p><h2 id="2-确认状态和状态变量"><a href="#2-确认状态和状态变量" class="headerlink" title="2. 确认状态和状态变量"></a>2. 确认状态和状态变量</h2><p>在这道题目中，我们使用一个数组 $a$ 来保存原始数列， 数组 $f$ 来保存状态</p><h2 id="3-确认决策并写出状态转移方程"><a href="#3-确认决策并写出状态转移方程" class="headerlink" title="3. 确认决策并写出状态转移方程"></a>3. 确认决策并写出状态转移方程</h2><p>我们的决策很简单，确定以这个位置的数为数列末位时将其加入上一个数的数列还是新建一个数列能使和更大就行了，也就是说如果 $f_{i-1} &lt; 0$ , 应当选择 $f_i &#x3D; a_i$ ，也就是新建数列。当 $f_{i-1} ≥ 0$ ，选择 $f_i &#x3D; f_{i-1} + a_i$ ，也就是将 $a_i$ 合并入 $f_{i -1}$  所在的数列。 简单写出方程是这样的：<br>$$<br>f_i&#x3D;\max\left(f_{i-1},\ 0\right) + a_i<br>$$<br>就这么简单，实现也是一样简单</p><h2 id="4-初始状态"><a href="#4-初始状态" class="headerlink" title="4. 初始状态"></a>4. 初始状态</h2><p>简单分析可以得到，有定值的状态就是第一个（$f_1$） 因为它是数列的第一个，所以他的前面一定没有数列，他的最大值一定是它本身，即：<br>$$<br>f_1 &#x3D; a_1<br>$$</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>通过上面的操作，我们已经明白如何确定每一种状态的最优解了，那么招到全局最优解也是易如反掌的事情了，我们只需要在左右局部最优解里找到一个最大的就行了，我们可以直接模拟，代码简单，就不贴出来了。当然为了更加优雅，也可以把 $a$ 和 $f$ 合并为一个数组，同时在输入的过程中直接进行计算得到答案。好的，这里就产生一个问题了：为什么我可以直接在输入个过程中进行计算呢？这里利用了 DP 的无后效性，也就是说后面的数据对前面算出来的最优解是不会产生影响的，这也是这道题可以用 DP 求解的原因。</p><p>OK，讲了这么多，该贴代码了，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> ans, n, a[<span class="hljs-number">1009</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        <span class="hljs-keyword">if</span> (a[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>            a[i] += a[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        ans = <span class="hljs-built_in">max</span>(ans, a[i]);<br>    &#125;<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="搞定收工"><a href="#搞定收工" class="headerlink" title="搞定收工"></a>搞定收工</h1>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1220 题解</title>
    <link href="/posts/11840.html"/>
    <url>/posts/11840.html</url>
    
    <content type="html"><![CDATA[<h1 id="从标签题面可以看出这是一道动规（DP）"><a href="#从标签题面可以看出这是一道动规（DP）" class="headerlink" title="从标签题面可以看出这是一道动规（DP）"></a>从<del>标签</del>题面可以看出这是一道动规（<strong>DP</strong>）</h1><p>进入正题，依旧是传统的五步</p><h2 id="1-划分阶段"><a href="#1-划分阶段" class="headerlink" title="1. 划分阶段"></a>1. 划分阶段</h2><p>这里我的思路是将每公里的数值作为一个阶段，即 $n$ 公里就有 $n$ 个阶段，分别是:<br>$$<br>1, 2, 3, 4, 5, 6 ….(n-2),(n-1),(n)<br>$$</p><h2 id="2-确定状态和状态变量"><a href="#2-确定状态和状态变量" class="headerlink" title="2. 确定状态和状态变量"></a>2. 确定状态和状态变量</h2><p>这里使用一个数组 $f$ 来保存状态，即第 $i$ 个状态为 $f_i$ ，然后就没有了</p><h2 id="3-确定决策并写出状态转移方程"><a href="#3-确定决策并写出状态转移方程" class="headerlink" title="3. 确定决策并写出状态转移方程"></a>3. 确定决策并写出状态转移方程</h2><p>我们观察可以发现，对于一个状态 $f_i$ 他将由 $f_{i-?} 与 \large {a}<em>?$ 组成，那么”?” 究竟是什么呢？不难发现，？可以是 $1\to10$ 的任意一个值，那么我们在这里就可以枚举 ？所代表的值，然后对这些计算出来的状态取最小值，也就是求他们的 $\min$ 值。思路清晰了，就可以动手写出状态转移方程了，如下<br>$$<br>f_i&#x3D;\min\left (\min</em>{j&#x3D;i-1\ ,\ j–}^{j&gt;(i-10)} f_j+a_{i-j},\ f_i\right)<br>$$<br>但是这个方程也有特例，仔细看不难看出，$j ≤ 0$ 也是有可能的，对于数学，这没有问题，但是来到计算机上，数组下标为负是万万不可以的，所以，我们需要特判一下，也就是说当 $j ≤ 0$ 的时候，我们的 $f_i &#x3D; a_i$ 并将其计入 $\min$ 的范围，修改后如下<br>$$<br>f_i&#x3D;\min\left (\min_{j&#x3D;i-1\ ,\ j–}^{j\ &gt;\ (i-10)\ &amp;&amp;\ j\ &gt;\ 0} f_j+a_{i-j},\ f_i,\ a_i\right)<br>$$<br>OK，复杂的方程写完了，下面的就很简单了</p><h2 id="4-寻找边界条件"><a href="#4-寻找边界条件" class="headerlink" title="4.  寻找边界条件"></a>4.  寻找边界条件</h2><p>边界条件很简单，$f_1 &#x3D; a_1$</p><h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h2><p>直接模拟，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">12</span>], f[<span class="hljs-number">200</span>], n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">127</span>, <span class="hljs-keyword">sizeof</span> f);<br>    f[<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= i - <span class="hljs-number">10</span>; j--) &#123;<br>            <span class="hljs-keyword">if</span> (j &lt;= <span class="hljs-number">0</span>) &#123;<br>                f[i] = <span class="hljs-built_in">min</span>(f[i], a[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                f[i] = <span class="hljs-built_in">min</span>(f[i], f[j] + a[i - j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[n];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1235 题解</title>
    <link href="/posts/33165.html"/>
    <url>/posts/33165.html</url>
    
    <content type="html"><![CDATA[<h1 id="简单的一维动规"><a href="#简单的一维动规" class="headerlink" title="简单的一维动规"></a><del>简单</del>的一维动规</h1><h2 id="按照老师的要求"><a href="#按照老师的要求" class="headerlink" title="按照老师的要求"></a><del>按照老师的要求</del></h2><h3 id="1-划分阶段"><a href="#1-划分阶段" class="headerlink" title="1. 划分阶段"></a>1. 划分阶段</h3><p>非常容易的可以看出这道题目的阶段就是各个位置，即 $i,\ j$ 。在这种划分下，每一种阶段的最优解可以由上一个阶段得到，且不会被右面的阶段所改变，故<strong>无后效性</strong>。综上，该题可以用 <strong>DP</strong> 求解</p><h3 id="2-确定状态和状态变量"><a href="#2-确定状态和状态变量" class="headerlink" title="2. 确定状态和状态变量:"></a>2. 确定状态和状态变量:</h3><p>由 (1) 得：该题无后效性，故可用 <strong>递推的DP</strong> 进行求解，对于状态 $i,\ j$ 的最优解，用 $f_{i,j}$ 表示而 $f_{i,j}$ 可由 $a_{i,j}$ （输入的数组）及 $f_{i - 1,j -1}$ 与 $f_{i - 1,j}$ 得到</p><h3 id="3-确定决策井写出状态转移方程"><a href="#3-确定决策井写出状态转移方程" class="headerlink" title="3. 确定决策井写出状态转移方程"></a>3. 确定决策井写出状态转移方程</h3><p>通过 (2) 的分析，可以观察出状态状态转移方程如下：<br>$$<br>f_{i,j} &#x3D; \max(f_{i-1, j-1}\ ,\ f_{i -1, j}) + a_{i,j}<br>$$</p><h3 id="4-边界条件"><a href="#4-边界条件" class="headerlink" title="4. 边界条件"></a>4. 边界条件</h3><p>分析样例可以得到，递推的边界条件为：<br>$$<br>f_{1, 1} &#x3D;a_{1,1}<br>$$</p><p>故，递推式为：<br>$$<br>\begin{array}{lr}<br>当\ i,j\ ≥0:\<br>F_{1,1} &#x3D; a_{1,1}\<br>F_{i,j}&#x3D;a_{i,j} + \max(F_{i -1, j-1}\ ,\ F_{i -1, j})<br>\end{array}<br>$$</p><h3 id="5-实现"><a href="#5-实现" class="headerlink" title="5. 实现"></a>5. 实现</h3><p>实现可以直接模拟，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">30</span>][<span class="hljs-number">30</span>], f[<span class="hljs-number">30</span>][<span class="hljs-number">30</span>],ans, n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>            cin &gt;&gt; a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;<br>            f[i][j] += <span class="hljs-built_in">max</span>(a[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], a[i - <span class="hljs-number">1</span>][j]) + a[i][j];<br>            ans = <span class="hljs-built_in">max</span>(ans, f[i][j]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然。也可以基于上面的思路及代码稍加优化，使得空间复杂度减半 ，同时代码更加简洁优雅。如下 ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">30</span>][<span class="hljs-number">30</span>], ans, n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>            cin &gt;&gt; a[i][j];<br>            a[i][j] += <span class="hljs-built_in">max</span>(a[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], a[i - <span class="hljs-number">1</span>][j]);<br>            ans = <span class="hljs-built_in">max</span>(ans, a[i][j]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1213 题解</title>
    <link href="/posts/51988.html"/>
    <url>/posts/51988.html</url>
    
    <content type="html"><![CDATA[<h1 id="很明显，这道题是二分答案"><a href="#很明显，这道题是二分答案" class="headerlink" title="很明显，这道题是二分答案"></a>很明显，这道题是二分答案</h1><hr><p>那么，需要二分的是什么？有脑子都知道是，间距。那么求的究竟是最大值最小还是最小值最大呢？我们看到题目，我们需要求的是 <strong>“那么相邻两块土地之间的间隔的最大值”</strong> 也就是最小值最大。好的，那么框架有了，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;<br><span class="hljs-comment">// l 是田之间的距离</span><br><span class="hljs-keyword">while</span> (r - l &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;<br>        l = mid;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r = mid;<br>    &#125;<br>&#125;<br>cout &lt;&lt; l;<br></code></pre></td></tr></table></figure><p>那么 <code>bool check(int x)</code> 的函数题怎么写呢？额，我也不知道（doge）</p><hr><p>$\tiny 才怪。$ 开个玩笑。$\Huge 进入正题$。</p><p>题目要求我们寻找的这个数是两块土地之间的间隔的最大值，也就是说我们要在保证种满 $m$ 块田的情况下让间距尽量远，我们用<strong>二分</strong>的方法枚举田之间的距离，然后判断距离是否可行，如果可行，就尝试更大的值，如果不行，就尝试更小的值，直到形成半封闭区间：$r - l ≤ 1$ 时， $l$ 的值即为所求，注意，输入的数组 $a$ 是无序的，需要先排序(<code>sort(a + 1, a + n + 1)</code>)</p><p>对于函数 <code>bool check(int x)</code> 我们希望他能够判断在距离为 $x$ 的情况下是否有 $≥ m$ 的田被耕种，如果是，返回 $true$ 否则为 $false$ 。为了达到这个功能，我们需要从第一块田开始，枚举间距大于 $n$ 的所有田，将数量计入变量 $cnt$ 最后会有两种可能<br>$$<br>\left{<br>\begin{array}{lr}<br>cnt\ge m,\ return\ true; \newline<br>cnt &lt; m, \ return\ false;<br>\end{array}<br>\right.<br>$$<br>非常简单 $\Huge 才怪$  当我兴致勃勃的把代码打出来的时候，我翻车了，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m, a[<span class="hljs-number">100009</span>], l, r;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span> </span>&#123;<br>    <span class="hljs-type">int</span> start = a[<span class="hljs-number">1</span>], cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        cnt += <span class="hljs-number">1</span>;<br>        i = <span class="hljs-built_in">lower_bound</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>, start + mid) - a;<br>        start = a[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt &gt;= m;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>);<br>    r = a[n] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (r - l &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;<br>            l = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r = mid;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; l;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="http://www.oiclass.com/record/63b26b598f2c059a51819a9e">提交记录</a></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E6%88%AA%E5%B1%8F2023-01-02%2013.57.47.png" srcset="/img/loading.gif" lazyload alt="截屏2023-01-02 13.57.47"></p><p>非常成功的失败了，但是我久久找不出原因</p><hr><p>两个星期后已经是新的一年了（2023），我终于找到了错误的原因。简单重写了一下代码，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m, a[<span class="hljs-number">1000009</span>], l, r;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, start = a[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span> (start + x &lt;= a[i])&#123;<br>            start = a[i];<br>            cnt += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt &gt;= m;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>);<br>    r = a[n];<br>    <span class="hljs-keyword">while</span> (r - l &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> mid = (r + l) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;<br>            l = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r = mid;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; l;<br>&#125;<br></code></pre></td></tr></table></figure><p>没有采用 <code>lower_bound()</code> 直接算 $i$ 的方法，而是以 $O(n)$ 的时间复杂度便利数组，激动的心，颤抖的手，我点了编译运行，复制样例，粘贴，$\Huge 输出\ 1\ ?$ <img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E6%88%AA%E5%B1%8F2023-01-02%2014.12.47.png" srcset="/img/loading.gif" lazyload alt="截屏2023-01-02 14.12.47">我当场差点 $\Tiny 去世$ 好吧，让我康康有什么 BUG。原来如此。我真的是个 $\Huge 大聪明$ 我居然忘记把 $a[i]$ 给算进种过的田里面，也就是说，我的 $cnt$ 一直是比正常的 $cnt$ 小一的($cnt_{我的} + 1&#x3D;cnt_{正常的}$) 那么就让我把 $cnt$ 的初始值设置为 $1$ 吧，编译运行，果然成功<img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E6%88%AA%E5%B1%8F2023-01-02%2014.16.27.png" srcset="/img/loading.gif" lazyload alt="截屏2023-01-02 14.16.27"></p><p> OK，那么下面就是激动人心的提交时刻，复制粘贴提交$\Huge AC\ !!!!$ </p><p> <img src="https://cdn.jsdmirror.com/gh/lixuannan/img/%E6%88%AA%E5%B1%8F2023-01-02%2014.17.36.png" srcset="/img/loading.gif" lazyload alt="截屏2023-01-02 14.17.36"></p><p>终于完成了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P3309 题解</title>
    <link href="/posts/22979.html"/>
    <url>/posts/22979.html</url>
    
    <content type="html"><![CDATA[<h1 id="这道是模拟题"><a href="#这道是模拟题" class="headerlink" title="这道是模拟题"></a>这道是模拟题</h1><h2 id="思路如下"><a href="#思路如下" class="headerlink" title="思路如下"></a>思路如下</h2><ul><li>先输入 $n$ 和 字符串</li><li>遍历字符串，如果没有出现过且$当前排队人数&lt;n$ ，将其标记，并将当前排队人数 $+1$，如果$当前排队人数 ≥n$ ，不标记，同时将答案 $+1$</li><li>如果已经出现过了，将当前人数 $-1$ 同时将其标位为出现</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现起来很简单，首先定义一个整数 $n$ 、一个字符串 $str$ 、一个布尔数组 $p[200]$，分别用于存储：题目中的 $n$  、题目中的字符串、标记字母是否出现过</p><p>然后按思路模拟，注意输出的时候 $ans$ 要 $÷ 2$ 也可以 $&gt;&gt;1$ 更快一些（尽管只有几纳秒）</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, cnt, ans;<br>string str;<br><span class="hljs-type">bool</span> p[<span class="hljs-number">200</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; str;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> i: str) &#123;<br>        <span class="hljs-keyword">if</span> (!p[i]) &#123;<br>            p[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (cnt &gt;= n) &#123;<br>                p[i] = <span class="hljs-literal">false</span>;<br>                ans += <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cnt += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p[i] = <span class="hljs-literal">false</span>;<br>            cnt -= <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; (ans &gt;&gt; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P2107 题解</title>
    <link href="/posts/58343.html"/>
    <url>/posts/58343.html</url>
    
    <content type="html"><![CDATA[<h1 id="这道题的思路非常奇怪（至少我觉得是这样）"><a href="#这道题的思路非常奇怪（至少我觉得是这样）" class="headerlink" title="这道题的思路非常奇怪（至少我觉得是这样）"></a>这道题的思路非常奇怪（至少我觉得是这样）</h1><h2 id="你需要把它当做一道找规律题"><a href="#你需要把它当做一道找规律题" class="headerlink" title="你需要把它当做一道找规律题"></a>你需要把它当做一道找规律题</h2><p>$\Huge{进入正题}$</p><h2 id="先看题目："><a href="#先看题目：" class="headerlink" title="先看题目："></a>先看题目：</h2><p>小 S 想计算一个自然数 n $(n &lt; 2000)$ 的所有回文分解的个数 $% 1000000007$ 的值。</p><p>我们来看一下 $1\to10$ 的所有整数的回文分解个数。简单在草稿纸上枚举可以发现，分别是：</p><p>$$<br>1,2,2,4,4,6,6,10,10,14<br>$$</p><p>可以看出，奇数位（$1,3,5,7,9$）的数是它的上一位（除了 $1$）。那么偶数位的什么呢？我们要从数列里面找，可以看出：</p><p>$$<br>\begin{array}{l}<br>4 &#x3D; 2 + 2 \newline<br>6 &#x3D; 4 + 2 \newline<br>10 &#x3D; 6 + 4 \newline<br>14 &#x3D; 10 + 4<br>\end{array}<br>$$</p><p>那么究竟是哪个数加上哪个数呢？如果把这个数列看作 $F$ 那么如下：</p><p>$$<br>\begin{array}{l}<br>4 &#x3D; F_{4} &#x3D; 2 + 2 &#x3D; F_{2} + F_{2} &#x3D; F_{4 - 2} + F_{4 \times \frac{1}{2}} \newline<br>6 &#x3D; F_{6} &#x3D; 4 + 2 &#x3D; F_{4} + F_{3} &#x3D; F_{6 - 2} + F_{6 \times \frac{1}{2}} \newline<br>同理 ………….<br>\end{array}<br>$$</p><p>所以，$F_{n} &#x3D; F_{n - 2} + F_{n \times \frac{1}{2}} \ \ \ \ (n \ge 4)$</p><p>那么我们就可以写代码了，直接写一个循环递推就可以了，非常短小精悍。但是写的时候要注意，要先给 $F_{1},\ F_{2},\ F_{3}$ 赋值，赋值后就可以计算了记得计算的时候 $% \ 1000000007$，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> n, a[<span class="hljs-number">10000000</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    a[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    a[<span class="hljs-number">2</span>] = a[<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            a[i] = (a[i - <span class="hljs-number">2</span>] + a[i / <span class="hljs-number">2</span>]) % <span class="hljs-number">1000000007</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            a[i] = a[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; a[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>直接   $\tiny轻松 \Huge AC$</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass P1202 题解</title>
    <link href="/posts/15962.html"/>
    <url>/posts/15962.html</url>
    
    <content type="html"><![CDATA[<h1 id="这道题一看就是连通块"><a href="#这道题一看就是连通块" class="headerlink" title="这道题一看就是连通块"></a>这道题一看就是连通块</h1><h2 id="因为求连通块-DFS-最简单，所以我用-BFS"><a href="#因为求连通块-DFS-最简单，所以我用-BFS" class="headerlink" title="因为求连通块 DFS 最简单，所以我用 BFS"></a>因为求连通块 DFS 最简单，所以我用 BFS</h2><h3 id="简单思路："><a href="#简单思路：" class="headerlink" title="简单思路："></a>简单思路：</h3><p>首先把外围的 <code>0</code> 给清除掉，然后统计数组里面还有多少个 <code>0</code>。</p><p>那么难点来了，究竟怎样能一次把外围所有的 <code>0</code> 给清除呢？记不记得我们在输入的时候一般都会从 <code>[1][1]</code> 开始输入，那么是不是从 <code>[1][1]</code> 到 <code>[n][n]</code> 都有值？没错，有脑子都知道有值，那么这个矩阵的四周是不是空出了一圈是没有值的，就像这样：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\0</span> <span class="hljs-string">\0</span> <span class="hljs-string">\0</span><br><span class="hljs-string">\0</span> 值 <span class="hljs-string">\0</span><br><span class="hljs-string">\0</span> <span class="hljs-string">\0</span> <span class="hljs-string">\0</span><br></code></pre></td></tr></table></figure><p>那么我们如果将外围的所有部分当做一个连通块来求的话，我们就可以把被 <code>*</code> 包围的 <code>0</code> 以外的所有部分找到，那么如果我们把所有部分都标记成 <code>*</code> 然后再遍历一次数组，把所有的 <code>0</code> 的个数统计起来，输出，那么是不是就可以 <strong>AC</strong> 了，不好意思，你太天真了，如果我们将这样的思路直接模拟出代码，那么 bfs 函数应该是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pos</span>&#123;<br>    <span class="hljs-type">int</span> x, y;<br>&#125;;<br><br>queue&lt;pos&gt; q;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>    q.<span class="hljs-built_in">push</span>((pos)&#123;x, y&#125;);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>        pos k = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span> (c[k.x + xx[i]][k.y + yy[i]] != <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                q.<span class="hljs-built_in">push</span>((pos)&#123;k.x + xx[i], k.y + yy[i]&#125;);<br>                c[k.x + xx[i]][k.y + yy[i]] = <span class="hljs-string">&#x27;*&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果就这样自信运行的话那么你就会发现他报错 <code>EXC_BAD_ACCESS (code=2, address=0x10b999e28)</code> （我用 LLDB 看的）为什么呢？</p><p>如果我们用 LLDB 检测两个下标的数值，就会发现我们的下标变成了负数（我也是服了），要怎么避免呢？我们可以引入一个 <code>bool check(int x, int y)</code> 函数，用来检查下标的有效性。函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt; a + <span class="hljs-number">1</span> || y &gt; b + <span class="hljs-number">1</span> || c[x][y] == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可能会好奇为什么要检查是否过大呢？实际上这样可以使得速度加快，减少 BFS 的块。</p><p>好的，那么坑都解决了，对吗？可能对吧，至少我遇到过的就这些，那么代码写出来是什么样子的呢？</p><h3 id="就长这样：-都看到这里了，点个赞吧，球球了"><a href="#就长这样：-都看到这里了，点个赞吧，球球了" class="headerlink" title="就长这样：(都看到这里了，点个赞吧，球球了)"></a>就长这样：(都看到这里了，点个赞吧，球球了)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pos</span> &#123; <span class="hljs-comment">// 存储位置的结构体</span><br>    <span class="hljs-type">int</span> x, y;<br>&#125;;<br><br><span class="hljs-type">int</span> a, b, cnt, xx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, yy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// 偏移量，一些基本的变量，a: x, b: y</span><br><span class="hljs-type">char</span> c[<span class="hljs-number">520</span>][<span class="hljs-number">520</span>]; <span class="hljs-comment">// 数字看起来不错吧</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt; a + <span class="hljs-number">1</span> || y &gt; b + <span class="hljs-number">1</span> || c[x][y] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123; <span class="hljs-comment">// 检测越界和围墙</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br>queue&lt;pos&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-comment">// 这个函数用来清空外围被水淹的服务器，函数本质上就是广搜找连通块，然后标记</span><br>    q.<span class="hljs-built_in">push</span>((pos) &#123;x, y&#125;);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        pos k = q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 获取对首</span><br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(k.x + xx[i], k.y + yy[i])) &#123; <span class="hljs-comment">// 确认不是围墙或者数组越界</span><br>                q.<span class="hljs-built_in">push</span>((pos) &#123;k.x + xx[i], k.y + yy[i]&#125;); <span class="hljs-comment">// 将其加入队列</span><br>                c[k.x + xx[i]][k.y + yy[i]] = <span class="hljs-string">&#x27;*&#x27;</span>; <span class="hljs-comment">// 标记为围墙，即清空</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 简单输入不用讲吧</span><br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= b; j++) &#123;<br>            cin &gt;&gt; c[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 用 [0][0] 来检测外部的连通块用来清除被洪水淹没的服务器</span><br>    <span class="hljs-built_in">clear</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 检测清除完以后还有多少台幸存的服务器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= a; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= b; j++) &#123;<br>            <span class="hljs-keyword">if</span> (c[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                cnt += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 无脑输出</span><br>    cout &lt;&lt; cnt;<br>&#125;<br></code></pre></td></tr></table></figure><p>![截屏2022-12-05 09.10.01](<a href="https://cdn.jsdmirror.com/gh/lixuannan/img/%E6%88%AA%E5%B1%8F2022-12-05">https://cdn.jsdmirror.com/gh/lixuannan/img/截屏2022-12-05</a> 09.10.01.png)</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>OiClass</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass Q&amp;A P1106</title>
    <link href="/posts/17897.html"/>
    <url>/posts/17897.html</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/n2rZbLt3TgzsCeE.png" srcset="/img/loading.gif" lazyload></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cstring&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, cnt, t;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> a[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> a);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span> (a[j] &gt; a[j<span class="hljs-number">+1</span>])&#123;<br>                t = a[j];<br>                a[j] = a[j + <span class="hljs-number">1</span>];<br>                a[j + <span class="hljs-number">1</span>] = t;<br>                cnt += <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//    for (int i=1; i &lt;= n; i++)&#123;</span><br><span class="hljs-comment">//        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span><br><span class="hljs-comment">//    &#125;</span><br>    cout &lt;&lt; cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="超神奇的三次运行结果："><a href="#超神奇的三次运行结果：" class="headerlink" title="超神奇的三次运行结果："></a>超神奇的三次运行结果：</h2><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/scAzYh1L_uEK7PSm8v0WQ.png" srcset="/img/loading.gif" lazyload alt="image"><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/yiwF1-5fHv3pwoaLkXYdT.png" srcset="/img/loading.gif" lazyload alt="image"></p><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/RdHkX9EzxzOgmsxmtxJTd.png" srcset="/img/loading.gif" lazyload></p><h2 id="经过大佬的提醒，事实问题在于数组没有设全局，修改思路如下："><a href="#经过大佬的提醒，事实问题在于数组没有设全局，修改思路如下：" class="headerlink" title="经过大佬的提醒，事实问题在于数组没有设全局，修改思路如下："></a>经过大佬的提醒，事实问题在于数组没有设全局，修改思路如下：</h2><p>把数组改成全局，并在交换的时候判断 <code>a[j]</code>和 <code>a[j + 1]</code>是否不为0，从而解决无效交换的问题，最终，历经千辛万苦，这道题还是AC了。实现的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cstring&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10001</span>];<br><span class="hljs-type">int</span> n, cnt, t;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span> (a[j] &gt; a[j<span class="hljs-number">+1</span>] &amp;&amp; a[j] != <span class="hljs-number">0</span> &amp;&amp; a[j + <span class="hljs-number">1</span>] != <span class="hljs-number">0</span>)&#123;<br>                t = a[j];<br>                a[j] = a[j + <span class="hljs-number">1</span>];<br>                a[j + <span class="hljs-number">1</span>] = t;<br>                cnt += <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//    for (int i=1; i &lt;= n; i++)&#123;</span><br><span class="hljs-comment">//        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span><br><span class="hljs-comment">//    &#125;</span><br>    cout &lt;&lt; cnt;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>OiClass</tag>
      
      <tag>Q&amp;A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OiClass.com Q&amp;A P1194</title>
    <link href="/posts/4116.html"/>
    <url>/posts/4116.html</url>
    
    <content type="html"><![CDATA[<h3 id="这次提问的人是自己"><a href="#这次提问的人是自己" class="headerlink" title="这次提问的人是自己"></a>这次提问的人是自己</h3><h1 id="P1194-阿克曼函数超时怎么破？"><a href="#P1194-阿克曼函数超时怎么破？" class="headerlink" title="P1194 阿克曼函数超时怎么破？"></a><a href="http://oiclass.com/p/P1194">P1194 阿克曼函数</a>超时怎么破？</h1><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> x, y, ans;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ack</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> n += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">0</span> &amp;&amp; n == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ack</span>(m - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">0</span> &amp;&amp; n &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ack</span>((m - <span class="hljs-number">1</span>), <span class="hljs-built_in">ack</span>(m, n - <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; x &gt;&gt; y;<br>    ans = <span class="hljs-built_in">ack</span>(x, y);<br>    cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/1DV9vkxQSo2q4QUsCGINk.png" srcset="/img/loading.gif" lazyload alt="image"></p><h2 id="解决方法：（超水（nan））"><a href="#解决方法：（超水（nan））" class="headerlink" title="解决方法：（超水（nan））"></a>解决方法：（超水（nan））</h2><p>拿出草稿纸，把阿克曼函数m值从0到3的展开算了一遍，如下：</p><p>$ack(0, n) &#x3D; n + 1$</p><p>$ack(1, n) &#x3D; n + 2$</p><p>$ack(2, n) &#x3D; 2n + 3$</p><p>$ack(3, n) &#x3D; 2^{y + 3} - 3$</p><h3 id="最终代码实现："><a href="#最终代码实现：" class="headerlink" title="最终代码实现："></a>最终代码实现：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cmath&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> x, y;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; x &gt;&gt; y;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)&#123;<br>        cout &lt;&lt; y + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>)&#123;<br>        cout &lt;&lt; y + <span class="hljs-number">2</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">2</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-number">2</span> * y + <span class="hljs-number">3</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">3</span>)&#123;<br>        cout &lt;&lt; <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, y + <span class="hljs-number">3</span>) - <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>OiClass</tag>
      
      <tag>Q&amp;A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass Q&amp;A P1626</title>
    <link href="/posts/58457.html"/>
    <url>/posts/58457.html</url>
    
    <content type="html"><![CDATA[<h1 id="OiClass-com-Q-A-P1626"><a href="#OiClass-com-Q-A-P1626" class="headerlink" title="OiClass.com Q&amp;A P1626"></a>OiClass.com Q&amp;A P1626</h1><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/Ah6qjHOStdLYyEX.png" srcset="/img/loading.gif" lazyload></p><h3 id="提问："><a href="#提问：" class="headerlink" title="提问："></a>提问：</h3><h5 id="帮我解决的人是我爸"><a href="#帮我解决的人是我爸" class="headerlink" title="帮我解决的人是我爸"></a>帮我解决的人是我爸</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> space <span class="hljs-string">&#x27; &#x27;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">33333</span>];<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a<span class="hljs-number">+1</span>,a+n<span class="hljs-number">+1</span>);<br>    <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>        cout&lt;&lt;(a[n/<span class="hljs-number">2</span>]+a[n/<span class="hljs-number">2</span><span class="hljs-number">+1</span>])/<span class="hljs-number">2</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;a[n/<span class="hljs-number">2</span><span class="hljs-number">+1</span>];<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这道题哪里错了啊QAQ</p><h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>这个人竟然用我用不了的万能开头，不可饶恕！！！（开玩笑）</p><p>老规矩（只用了一次），先看题目，求中间数这种简单的事情还用问。开干（事非经过不知难），按照我一开始的思路，我写了一个桶排，一运行，发现不对劲，示例数据里面有重复的。如果用桶排的话重复数据就没了，然后我又尝试冒泡排序，也不行，实在是太慢了。最后没办法上度娘查，好不容易找到一篇CSDN的文章才知道原来在<code>algorithm</code>库有一个sort排序算法时间复杂度那可不是比冒泡快一星半点，而且逻辑代码不用自己写，调用函数就行了，NICE！！！搞定了排序，剩下的就很简单了，实现的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;algorithm&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, a[<span class="hljs-number">30001</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a, a + n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; (a[n / <span class="hljs-number">2</span>] + a[n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; a[n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="搞定，轻松加愉快！"><a href="#搞定，轻松加愉快！" class="headerlink" title="搞定，轻松加愉快！"></a>搞定，轻松加愉快！</h4><h5 id="哦，对了，那个说要叫爹，说到做到哦"><a href="#哦，对了，那个说要叫爹，说到做到哦" class="headerlink" title="哦，对了，那个说要叫爹，说到做到哦~~~~"></a>哦，对了，那个说要叫爹，说到做到哦~~~~</h5>]]></content>
    
    
    
    <tags>
      
      <tag>OiClass</tag>
      
      <tag>Q&amp;A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oiclass Q&amp;A P2569</title>
    <link href="/posts/25835.html"/>
    <url>/posts/25835.html</url>
    
    <content type="html"><![CDATA[<h1 id="OiClass-Q-A-P2569"><a href="#OiClass-Q-A-P2569" class="headerlink" title="OiClass Q&amp;A P2569"></a>OiClass Q&amp;A P2569</h1><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p><img src="https://cdn.jsdmirror.com/gh/lixuannan/img/UtHGf1Yimr6dZNK.png" srcset="/img/loading.gif" lazyload alt="oiclassq&amp;ap1problem.png"></p><p>很显然这是一道很简单的问题（大水题），让我们来看看提问： </p><h3 id="哪位兄台能告诉我哪里错了吗，输入输出符合要求的："><a href="#哪位兄台能告诉我哪里错了吗，输入输出符合要求的：" class="headerlink" title="哪位兄台能告诉我哪里错了吗，输入输出符合要求的："></a>哪位兄台能告诉我哪里错了吗，输入输出符合要求的：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> sum,m,s,u,n;<br>    cin&gt;&gt;m&gt;&gt;s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=m;i++)&#123;<br>        sum=(<span class="hljs-built_in">pow</span>(m,s));<br>    &#125;<br>    u=sum%<span class="hljs-number">10</span>;<br>    n=sum%<span class="hljs-number">100</span>/<span class="hljs-number">10</span>;<br>    cout&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;u;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答:"></a>解答:</h3><p>我们可以看到题目中的数据范围为N,K(2≤N，K≤100000000)，稍微一算我们就能知道题目算法中sum的数值很容易就达到一亿的一亿次方算出来有多大大家不用脑子知道吧。就算用<code>long long</code>类型也绝对存不下。那要怎么办呢？</p><p>目光转向题目，我们可以很轻松的发现题目只需要后两位，也就是个位和十位，那么前面是什么对我们就完全不重要了，反而是后面两位需要保存好。既然只要后两位，那我就干脆把数值在乘方的过程中<code>%100</code>不就行了？所以这道题应该是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,k,power=<span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>        power *= n;<br>        power %= <span class="hljs-number">100</span>;<br>    &#125;<br>    cout&lt;&lt;power/<span class="hljs-number">10</span>%<span class="hljs-number">10</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;power%<span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而不是向前面提问的老哥那样直接用<code>cmath</code>库求n的k次方，方法应该没错，试提交一下。</p><h1 id="AC！！！"><a href="#AC！！！" class="headerlink" title="AC！！！"></a>AC！！！</h1>]]></content>
    
    
    
    <tags>
      
      <tag>OiClass</tag>
      
      <tag>Q&amp;A</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p>好吧，今天终于想起来写简介了。哈哈哈哈</p><p>首先讲一下现在我是干什么的吧，我现在是一个 TYOIer。平常就喜欢切切水题，写写 TJ，研究一些奇怪的数学。除了在 TYOI 之外我还在学校的宣传部干活（最没错，我是一个初中生）。现在主要的工作就是在学校水课，然后回家出去拍拍照，写一写代码。除了做题以外我的大部分代码都是写在了 github 上，大家可以去看一下我的 github 主页，有很多很好玩的项目。</p><p>现在这个博客主要是记录一些我的题解、项目、分享一些摄影的经历。以后可能在 B 站也会有一些内容的分享，大家可以去关注的 B 站账号呀~</p>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[!(function() {  /** 计时起始时间，自行修改 **/  var start = new Date("2022/08/01 12:23:04");  function update() {    var now = new Date();    now.setTime(now.getTime()+250);    days = (now - start) / 1000 / 60 / 60 / 24;    dnum = Math.floor(days);    hours = (now - start) / 1000 / 60 / 60 - (24 * dnum);    hnum = Math.floor(hours);    if(String(hnum).length === 1 ){      hnum = "0" + hnum;    }    minutes = (now - start) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);    mnum = Math.floor(minutes);    if(String(mnum).length === 1 ){      mnum = "0" + mnum;    }    seconds = (now - start) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);    snum = Math.round(seconds);    if(String(snum).length === 1 ){      snum = "0" + snum;    }    document.getElementById("timeDate").innerHTML = "本站安全运行&nbsp"+dnum+"&nbsp天";    document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";  }  update();  setInterval(update, 1000);})();]]></content>
    
  </entry>
  
  
  
</search>
